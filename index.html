<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/xzpq.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="找回当年那个被寄予厚望的自己">
<meta property="og:type" content="website">
<meta property="og:title" content="P0rZ9&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="P0rZ9&#39;s blog">
<meta property="og:description" content="找回当年那个被寄予厚望的自己">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="P0rZ9&#39;s blog">
<meta name="twitter:description" content="找回当年那个被寄予厚望的自己">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>P0rZ9's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">P0rZ9's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/天猫项目实战总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/天猫项目实战总结/" itemprop="url">仿天猫(SSM版)_项目总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-23T08:15:41+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>断断续续写了有十来天,写这个的目的就是为了熟悉SSM这个框架,很多都参考了how2j的教程,有许多可以改进的地方,后期再维护吧！</p>
</blockquote>
<hr>
<h2 id="项目大概"><a href="#项目大概" class="headerlink" title="项目大概"></a>项目大概</h2><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><p>1.表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>中文含义</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Category</td>
<td>分类表</td>
<td>存放分类信息</td>
</tr>
<tr>
<td>Property</td>
<td>属性表</td>
<td>分类的属性信息</td>
</tr>
<tr>
<td>PropertyValue</td>
<td>属性值表</td>
<td>属性值信息</td>
</tr>
<tr>
<td>Product</td>
<td>产品表</td>
<td>产品信息</td>
</tr>
<tr>
<td>ProductImage</td>
<td>产品图片表</td>
<td>产品图片信息</td>
</tr>
<tr>
<td>Review</td>
<td>评论表</td>
<td>产品的评论信息,评论内容</td>
</tr>
<tr>
<td>User</td>
<td>用户表</td>
<td>用户信息表,用户账号密码</td>
</tr>
<tr>
<td>Order</td>
<td>订单表</td>
<td>订单信息表,含订单号,地址等信息</td>
</tr>
<tr>
<td>OrderItem</td>
<td>订单项表</td>
<td>订单项表,含购买种类,数量</td>
</tr>
</tbody>
</table>
<p>2.表之间的关系            </p>
<p>正确分析表之间的关系:<br>一个分类对应一个多个产品<br>一个产品对应一个分类        所以分类与产品的关系为<strong>一对多</strong>        </p>
<p>上面表的一对多的关系:            </p>
<table>
<thead>
<tr>
<th>一</th>
<th>多</th>
</tr>
</thead>
<tbody>
<tr>
<td>Category-分类</td>
<td>Product-产品</td>
</tr>
<tr>
<td>Category-分类</td>
<td>Property-属性</td>
</tr>
<tr>
<td>Product-产品</td>
<td>Review-评价</td>
</tr>
<tr>
<td>User-用户</td>
<td>Review-评价</td>
</tr>
<tr>
<td>Order-订单</td>
<td>OrderItem-订单项</td>
</tr>
<tr>
<td>Product-产品</td>
<td>OrderItem-订单项</td>
</tr>
<tr>
<td>User-用户</td>
<td>OrderItem-订单项</td>
</tr>
<tr>
<td>User-用户</td>
<td>Order-订单</td>
</tr>
<tr>
<td>Product-产品</td>
<td>ProductImage-产品图片</td>
</tr>
<tr>
<td>Property-属性</td>
<td>PropertyValue-属性值</td>
</tr>
<tr>
<td>Product-产品</td>
<td>PropertyValue-属性值</td>
</tr>
</tbody>
</table>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>项目名称tmall_ssm</p>
<pre><code>Java源代码
    controller 控制层        
    interceptor 拦截器            
    mapper Mapper类
    pojo 实体类                
    service Service层            
    util 工具类
    comparator 比较类    
resources
    mapper 映射文件
    配置文件
web目录        
    css
    img
    js
    Web-INF
        views
            admin    后台所用的Jsp文件
            fore    前台的Jsp文件
            include    包含的Jsp文件

pom.xml    Maven配置文件            
</code></pre><h3 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h3><p>前台功能:<br>    用户管理<br>        会员注册<br>        会员登陆<br>        退出登陆<br>        登陆验证拦截器<br>    订单管理<br>        查看订单状态<br>        付款<br>        确认收货<br>        评价订单<br>        删除<br>    购物车<br>        查看购物车<br>        添加删除<br>        结算<br>    产品展示<br>        搜索产品<br>        产品详情<br>        展示产品</p>
<p>后台功能:<br>    分裂,订单,用户,属性等的CURD操作</p>
<p>其他:<br>    分页功能<br>    事务管理(创建订单时将OrderItem的oid设置为Order表的id值)<br>    产品搜索(使用比较器)                </p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><pre><code>1.MVC设计模式            
2.MYBATIS逆向工程重构            
3.模块化的Jsp开发(将每个页面拆分成几个小的Jsp页面)    
4.后台所有分页页面使用相同的分页机制(admin_page.jsp)            
</code></pre><p><a href="https://github.com/P0rZ9/tmall_ssm" target="_blank" rel="noopener">源代码</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/分页功能详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/分页功能详解/" itemprop="url">分页知识详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-12T08:15:41+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>分页使用场景:当取到的数据量到达一定程度时,需要使用分页来进行数据分割</p>
</blockquote>
<h4 id="分页分类"><a href="#分页分类" class="headerlink" title="分页分类:"></a>分页分类:</h4><h5 id="a-真分页-物理分页"><a href="#a-真分页-物理分页" class="headerlink" title="a.真分页(物理分页)"></a>a.真分页(物理分页)</h5><pre><code>原理:每次点击下一页时去数据库查询。                
select * from user where id &gt; 1 limit #{param1}, #{param2}    
优点:不会造成内存溢出    
缺点:翻页速度较慢    
</code></pre><h5 id="b-假分页-逻辑分页"><a href="#b-假分页-逻辑分页" class="headerlink" title="b.假分页(逻辑分页)"></a>b.假分页(逻辑分页)</h5><pre><code>原理:一次将所有数据取出放入内存中,每次查询直在内存中取出数据。    优点:分页速度较快            
缺点:可能造成内存溢出                        
</code></pre><p>假分页容易实现,即准备一个集合保存从数据库中取出所有数据,根据当前码数,取出对应范围的数据,我们这里主要学习物理分页。            </p>
<h4 id="实现简单物理分页"><a href="#实现简单物理分页" class="headerlink" title="实现简单物理分页"></a>实现简单物理分页</h4><p>1.准备一个Page工具类:    </p>
<pre><code>public class Page {

  int start;
  int count;
  int total;

  //构造方法
  public Page(int start,int count){
      super();
      this.start = start;
      this.count = count;
  }

  //计算得到尾页
  public int getLast(){
      int last;
      //假设total=50  count=5
      if(total % count == 0)
          //最后一页开头为45
         last = total - count;
      else
          //不整除 最后一页开头为50
          last = total - total % count;

      last = last &lt; 0 ? 0 : last;
      return last;
  }

  //是否有上一页 下一页
  public boolean isHasPreviouse(){
      if (start == 0)
          return false;
      return true;
  }
  public boolean isHasNext(){
      if(getLast() == 0)
          return false;
      return true;
  }

  //计算得到总页数
  public int getTotalPage(){
      int totalPage;

      if(total % count == 0)
          totalPage = total / count;
      else
          totalPage = total / count + 1;
      if(totalPage == 0)
          totalPage = 1;

      return totalPage;
  }

/* getter and setter */
}
</code></pre><p>前台设计:</p>
<pre><code>&lt;ul class=&quot;pagination&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;laquo;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-12.10.39.23-image.png" alt="2019-02-12.10.39.23-image.png"></p>
<p>前台分页设计:</p>
<pre><code>&lt;ul class=&quot;pagination&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;?page.start=0&quot;&gt;&lt;span&gt;«&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt;&lt;span&gt;‹&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;

    &lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;?page.start=${status.index*page.count}&quot; class=&quot;current&quot;&gt;${status.count}&lt;/a&gt;
    &lt;/li&gt;
    &lt;/c:forEach&gt;

    &lt;li&gt;&lt;a href=&quot;?page.start=${page.start+page.count}&quot;&gt;&lt;span&gt;›&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;?page.start=${page.last}&quot;&gt;&lt;span&gt;»&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>a.没有边界判断,即在首页仍然可以点击前一页,不符合逻辑<br>b.会显示所有的分页,如果totalPage有100多页,则会全部显示出来,影响美观            </p>
<h4 id="改良版本"><a href="#改良版本" class="headerlink" title="改良版本"></a>改良版本</h4><p>1.写好头与尾:</p>
<pre><code>&lt;nav class=&quot;pageDIV&quot;&gt;
  &lt;ul class=&quot;pagination&quot;&gt;
  .....
  &lt;/ul&gt;
&lt;/nav&gt;
</code></pre><p>2.对<code>« ‹</code>增加边值判断        </p>
<pre><code>&lt;li &lt;c:if test=&quot;${!page.hasPrevious}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt;
     &lt;a href=&quot;?page.start=0&quot;&gt;
         &lt;span&gt;
             «
         &lt;/span&gt;
     &lt;/a&gt;
 &lt;/li&gt;

 &lt;li &lt;c:if test=&quot;${!page.hasPrevious}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt;
     &lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt;
         &lt;span&gt;
             ‹
         &lt;/span&gt;
     &lt;/a&gt;
 &lt;/li&gt;
</code></pre><p>获取JavaBean的属性,只需要.符号就可以操作。<code>${hero.name}</code>就会自动调用其getName()方法。如果属性为boolean类型,就会自动调用isXXX方法。<br>所以使用page.hasPrevious就会自动调用isHasPrevious()方法。<br>并用js对其禁止:</p>
<pre><code>&lt;script&gt;
  $(function () {
      $(&quot;ui.pagination li.disabled a&quot;).click(function () {
          return false;
      });
  });
&lt;/script&gt;
</code></pre><p>3.中间页码的编写    </p>
<pre><code>&lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt;
    &lt;c:if test=&quot;${status.count*page.count-page.start&lt;=30 &amp;&amp; status.count*page.count-page.start&gt;=-10}&quot;&gt;
        &lt;li &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt;
            &lt;a href=&quot;?page.start=${status.index*page.count}&quot;
               &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;current&quot;&lt;/c:if&gt;
            &gt;${status.count}&lt;/a&gt;
        &lt;/li&gt;
    &lt;/c:if&gt;
&lt;/c:forEach&gt;
</code></pre><p>从0循环到<code>page.totalPage-1</code>,varStatus相当于循环变量<br>status.count是从1开始遍历<br>status.index是从0开始遍历<br>要求:显示页码的前2个与后2个即可,即在第3页时,显示<code>1,2,3,4,5</code>的页码<br>测试条件:-10&lt;当前页*每页显示数目-当前页开始编号&lt;=30<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-12.13.29.28-image.png" alt="2019-02-12.13.29.28-image.png"></p>
<p>4.后台实现分页<br>使用上面的Page工具类,我们在dao层定义一个<code>List&lt;User&gt; list(int start, int count);</code>方法,经过Mapper映射</p>
<pre><code>&lt;select id=&quot;list&quot; resultMap=&quot;students&quot;&gt;
    select * from user order by user_id desc limit #{param1}, #{param2}
&lt;/select&gt;
</code></pre><p>然后在controller中:</p>
<pre><code>// 获取分页参数
int start = 0;
int count = 10;

try {
    start = Integer.parseInt(request.getParameter(&quot;page.start&quot;));
    count = Integer.parseInt(request.getParameter(&quot;page.count&quot;));
} catch (Exception e) {
}
Page page = new Page(start, count);

List&lt;User&gt; users = userService.list(page.getStart(), page.getCount());
int total = userService.getTotal();
page.setTotal(total);
request.setAttribute(&quot;users&quot;, users);
request.setAttribute(&quot;page&quot;, page);

return &quot;listUser&quot;;
</code></pre><p>即可完成分页功能        </p>
<h4 id="SSM项目中的分页"><a href="#SSM项目中的分页" class="headerlink" title="SSM项目中的分页"></a>SSM项目中的分页</h4><p>在SSM项目中,我们可以使用MyBatis的一款分页插件<br><a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">PageHelper</a><br><strong>使用方法:</strong><br>1.pom.xml添加依赖包        </p>
<pre><code>&lt;!-- pageHelper --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;5.1.2-beta&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--jsqlparser--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;
    &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>2.spring-mybatis.xml配置文件</p>
<pre><code>&lt;!-- 配置SqlSessionFactory对象 --&gt;
&lt;bean&gt;
......
    &lt;property name=&quot;plugins&quot;&gt;
        &lt;array&gt;
            &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
                &lt;property name=&quot;properties&quot;&gt;
                    &lt;!-- config params as the following --&gt;
                    &lt;value&gt;
                        helperDialect=mysql
                    &lt;/value&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>3.UserController:</p>
<pre><code>PageHelper.offsetPage(page.getStart(),page.getCount());
List&lt;User&gt; users = userService.list();
int total = (int) new PageInfo&lt;&gt;(users).getTotal();
page.setTotal(total);
modelMap.addAttribute(&quot;page&quot;,page);
modelMap.addAttribute(&quot;users&quot;,users);
</code></pre><p>需要注意的是:<code>PageHelper.offsetPage(page.getStart(),page.getCount);只对该语句以后的第一个查询语句得到的数据进行分页</code>,所以这句话应该放在得到users前面。                </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/ssm整合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/ssm整合/" itemprop="url">ssm整合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-25T08:15:41+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>模仿网上的教程,使用ssm完成一个对用户进行增删改查的小demo</p>
</blockquote>
<hr>
<h3 id="使用Maven构建SSM项目"><a href="#使用Maven构建SSM项目" class="headerlink" title="使用Maven构建SSM项目"></a>使用Maven构建SSM项目</h3><pre><code>1.导入 jar 包(如果使用 maven 则配置 pom.xml)
2.配置 web.xml 文件
3.配置 spring.xml springMVC.xml myBatis.xml
4.配置资源文件，database.properties，log4j.properties 等等
5.设计 entity 实体类
6.编写 DAO 层接口和 Mapper.xml
7.编写 service 业务层
8.编写 cotroller 控制器
9.视图代码：前台 jsp 页面

1.在pom.xml项目中添加SSM项目需要的jar包    
2.配置Spring mvc的相关配置信息(自动扫描cn.test包下带有注解的类)            
3.通过xml方式配置日志与数据库
4.创建实体类User Dao类UserDao 业务类UserService
5.创建控制器UserController并返回数据到视图层`view/*.jsp`
</code></pre><p>测试界面:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-24.10.42.18-image.png" alt="2019-01-24.10.42.18-image.png"></p>
<p>项目结构:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-24.20.17.58-image.png" alt="2019-01-24.20.17.58-image.png"></p>
<h3 id="学生管理系统-SSM版"><a href="#学生管理系统-SSM版" class="headerlink" title="学生管理系统(SSM版)"></a>学生管理系统(SSM版)</h3><p>ssm框架基本结构图：<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-25.22.17.27-image.png" alt="2019-01-25.22.17.27-image.png"></p>
<p>用户访问SSM流程图:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-25.21.00.51-image.png" alt="2019-01-25.21.00.51-image.png"></p>
<p><a href="https://github.com/P0rZ9/SSM" target="_blank" rel="noopener">源代码</a>    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/Mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/Mybatis/" itemprop="url">ssm基础之MyBatis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-23T09:15:41+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习了MYBATIS,记录一波    </p>
</blockquote>
<h3 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h3><blockquote>
<p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。</p>
</blockquote>
<p><strong>持久层</strong>： 可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。<br><strong>优点</strong>： 可以使用巨大的磁盘空间存储相当量的数据，并且很廉价<br><strong>缺点</strong>：慢（相对于内存而言）</p>
<p><strong>为什么使用Mybatis</strong>        </p>
<blockquote>
<p>传统JDBC中,除了自己提供sql语句外,还必须操作Connection,Statement,ResultSet,非常繁琐。使用Mybatis后,只需要提供sql语句即可,我们只需要重点关注增删改查这些操作层面上。并且Mybatis支持使用简单的XML或注解来配置和映射原生信息,将接口和Java对象映射为数据库中的记录。            </p>
</blockquote>
<p>Mybatis运行程序原理图:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-22.20.51.18-image.png" alt="2019-01-22.20.51.18-image.png"></p>
<pre><code>程序执行顺序:
1.应用程序找Mybatis要数据            
2.Mybatis从数据库找来数据        
    2.1 通过mybatis-config.xml定位数据库        
    2.2 通过User.xml执行对应的select语句        
    2.3 基于User.xml把返回的数据库记录封装在User对象中
    2.4 将多个User对象封装在一个User集合中        
3.返回一个User集合
</code></pre><h3 id="第一个Mybatis程序"><a href="#第一个Mybatis程序" class="headerlink" title="第一个Mybatis程序"></a>第一个Mybatis程序</h3><p>1.Maven pom.xml    </p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.43&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Mybatis依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>2.Mybatis 配置文件 mybatis-config.xml<br>作用主要就是提供连接数据库用的驱动,数据名称,编码方式,账号密码等</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;

&lt;configuration&gt;


    &lt;typeAliases&gt;
        &lt;package name=&quot;com.test.pojo&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;com/test/pojo/User.xml&quot;/&gt;
    &lt;/mappers&gt;

&lt;/configuration&gt;
</code></pre><p>3.配置文件User.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.test.pojo&quot;&gt;
    &lt;select id=&quot;listUser&quot; resultType=&quot;User&quot;&gt;
            select * from user
    &lt;/select&gt;

    &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot;&gt;
        insert into user ( name ) values (#{name})
    &lt;/insert&gt;

    &lt;delete id=&quot;delUser&quot; parameterType=&quot;User&quot;&gt;
        delete from user where id = #{id}
    &lt;/delete&gt;

    &lt;select id=&quot;getUser&quot; parameterType=&quot;_int&quot; resultType=&quot;User&quot;&gt;
        select * from user where id=#{id}
    &lt;/select&gt;

    &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot; &gt;
        update user set name = #{name} where id=#{id}
    &lt;/update&gt;

    &lt;!--模糊查询--&gt;
    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;User&quot;&gt;
        select * from user where name like &apos;%${value}%&apos;
    &lt;/select&gt;


&lt;/mapper&gt;
</code></pre><p>由于在主配置文件里配置了<code>&lt;typeAliases&gt;</code>别名,所以在这里的resultType可以直接写User,不用写全名pojo.User<br>namespace属性就是对SQL语句进行分类管理,实现不同业务的SQL隔离。            </p>
<p>4.测试类  TestMybatis.java    </p>
<pre><code>TestMybatis.java            
package com.test;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import com.test.pojo.User;

public class TestMybatis {

public static void main(String[] args) throws IOException {
    String resource = &quot;mybatis-config.xml&quot;;
    InputStream inputStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    SqlSession session=sqlSessionFactory.openSession();


    //插入用户
    User user1 = new User();
    user1.setName(&quot;test1&quot;);
    session.insert(&quot;addUser&quot;,user1);

   //修改用户
    User user2 = session.selectOne(&quot;getUser&quot;,5);
    user2.setName(&quot;test_after&quot;);
    session.update(&quot;updateUser&quot;,user2);

    //删除用户
    User user3 = new User();
    user3.setId(3);
    session.delete(&quot;delUser&quot;,user3);

    //获取用户
    User user4 = session.selectOne(&quot;getUser&quot;,5);
    System.out.println(user4.getName());

    //模糊查询
    List&lt;User&gt; users = session.selectList(&quot;findUserByName&quot;,&quot;te&quot;);
    for(User user : users){
        System.out.println(user.getId()+&quot;:&quot;+user.getName());
    }

    //获取全部用户
    listAll(session);
    session.commit();
    session.close();
}

private static void listAll(SqlSession session){

    //列出全部用户
    List&lt;User&gt; users=session.selectList(&quot;listUser&quot;);
    for (User user : users) {
        System.out.println(user.getName());
    }
}
}
</code></pre><p>xml文件几个概念:<br>parameterType：指定输入参数类型,可为基本数据类型(int float)与包装数据类型(String Interger)以及用户编写的JavaBean类<br>resultType: 指定从数据库返回的信息对应的Java数据类型。</p>
<p>#{}： 占位符,该符号接收输入参数,花括号中编写参数名称来接收对应参数。当#{}接收简单类型时可用value或者其他名称来获取。<br>${}：表示拼接符,可在原有SQL语句上拼接新的符合SQL语法的语句。            </p>
<p>MyBatis使用场景:通过上面的入门程序,MyBatis的特点就是以Sql语句为核心的不完全的ORM(关系型映射)框架。使用场景为:对SQL语句优化要求比较高,项目需求经常变动。            </p>
<h3 id="MyBatis深入学习"><a href="#MyBatis深入学习" class="headerlink" title="MyBatis深入学习"></a>MyBatis深入学习</h3><h4 id="编写日志输出环境配置文件"><a href="#编写日志输出环境配置文件" class="headerlink" title="编写日志输出环境配置文件"></a>编写日志输出环境配置文件</h4><h4 id="MyBatis高级映射"><a href="#MyBatis高级映射" class="headerlink" title="MyBatis高级映射"></a>MyBatis高级映射</h4><h5 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h5><p>查询number对应的学生姓名。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-22.23.40.15-image.png" alt="2019-01-22.23.40.15-image.png"></p>
<h6 id="使用resultType-只能映射到一个确定的Java包装类"><a href="#使用resultType-只能映射到一个确定的Java包装类" class="headerlink" title="使用resultType    (只能映射到一个确定的Java包装类)"></a>使用resultType    (只能映射到一个确定的Java包装类)</h6><p>1.首先更改主配置文件加载的<mappers>的内容:    </mappers></p>
<pre><code>  &lt;mappers&gt;
    &lt;mapper resource=&quot;com/test/pojo/Student.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>2.Student.xml            </p>
<pre><code>&lt;select id=&quot;findStudentByCard&quot; parameterType=&quot;_int&quot; resultType=&quot;Student&quot;&gt;
  SELECT
    student.*,
    card.*
  FROM
    student,card
  WHERE student.card_id = card.id AND card.number = #{value}
&lt;/select&gt;
</code></pre><h6 id="使用-resultMap-实现"><a href="#使用-resultMap-实现" class="headerlink" title="使用 resultMap 实现"></a>使用 resultMap 实现</h6><p>使用resultMap可以将数据字段映射到名称不一样的响应实体类属性中,重要的是可映射到实体类包裹的其他实体类。<br>1.首先更改主配置文件加载的<mappers>的内容:    </mappers></p>
<pre><code>  &lt;mappers&gt;
    &lt;mapper resource=&quot;com/test/pojo/Student.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>2.创建一个新的实体类(包含Student与card)<br>StudentWithCard.java </p>
<pre><code>package com.test.pojo;
  public class StudentWithCard {
    Student student;
    int number;
    int id;

      //geter and seter
  }
</code></pre><p>3.Student.xml</p>
<pre><code>&lt;mapper namespace=&quot;com.test.pojo&quot;&gt;
&lt;select id=&quot;findStudentByCard&quot; parameterType=&quot;_int&quot; resultMap=&quot;StudentInfoMap&quot;&gt;
  SELECT
    student.*,
    card.*
  FROM
    student,card
  WHERE student.card_id = card.id AND card.number = #{value}
&lt;/select&gt;

&lt;resultMap id=&quot;StudentInfoMap&quot; type=&quot;StudentWithCard&quot;&gt;
&lt;!-- id 标签表示对应的主键
     column 对应查询结果的列值
     property 对应封装类中的属性名称
--&gt;
      &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
      &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
      &lt;!-- association 表示关联的嵌套结果，
           可以简单理解就是为封装类指定的标签
           --&gt;
      &lt;association property=&quot;student&quot; javaType=&quot;Student&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
        &lt;result column=&quot;card_id&quot; property=&quot;card_id&quot;/&gt;
      &lt;/association&gt;
&lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre><p>4.测试类(取出number为1111的学生的信息):</p>
<pre><code>StudentWithCard student = session.selectOne(&quot;findStudentByCard&quot;,1111);
System.out.println(student.getStudent().getName());
</code></pre><p>  <img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-23.11.35.57-image.png" alt="2019-01-23.11.35.57-image.png"></p>
<h5 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h5><p>查询选修了同一个班级的同学信息<br>  <img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-23.11.42.33-image.png" alt="2019-01-23.11.42.33-image.png"><br>1.首先更改主配置文件加载的<mappers>的内容:    </mappers></p>
<pre><code>&lt;mappers&gt;
  &lt;mapper resource=&quot;com/test/pojo/Class.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>2.创建class实体类    </p>
<pre><code>package com.test.pojo;
import java.util.List;
public class Class {
    private int id;
    private String name;
    private List&lt;Student&gt; students;
      //geter and seter
  }
</code></pre><p>3.映射文件Class.xml            </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.test.pojo&quot;&gt;

    &lt;resultMap id=&quot;Students&quot; type=&quot;Student&quot;&gt;
        &lt;id column=&quot;student_id&quot; property=&quot;student_id&quot; /&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;
    &lt;/resultMap&gt;

    &lt;select id=&quot;listStudentByClassName&quot; parameterType=&quot;String&quot; resultMap=&quot;Students&quot;&gt;
        select student.* from student, class where student.student_id = class.student_id and class.name = #{value}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>子元素说明:<br>  id: 设置主键字段与模型属性的映射关系<br>  result: 设置普通字段与模型属性的关系            </p>
<p>配置属性:<br>  property: 映射到JavaBean的属性名称<br>  column: 数据表的列名或者标签别名<br>  javaType: 一个完整的类名,匹配的是一个JavaBean,MyBatis会自动检测</p>
<p>4.测试类(输出课程为Java课的学生信息):</p>
<pre><code>List&lt;Student&gt; students = session.selectList(&quot;listStudentByClassName&quot;,&quot;Java课&quot;);
for (Student student : students){
    System.out.println(&quot;ID:&quot;+student.getStudent_id()+&quot;,NAME:&quot;+student.getName());
}  
</code></pre><p>  <img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-23.12.28.48-image.png" alt="2019-01-23.12.28.48-image.png"></p>
<p>结合sql语句与映射文件,就可以很方便的操作数据库        </p>
<h3 id="Mapper-代理实例编写"><a href="#Mapper-代理实例编写" class="headerlink" title="Mapper 代理实例编写"></a>Mapper 代理实例编写</h3><p>1.Mybatis-config.xml        </p>
<pre><code>&lt;mappers&gt;
    &lt;mapper resource=&quot;com/test/pojo/StudentMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>2.StudentMapper.xml        </p>
<pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.test.pojo.mapper.StudentMapper&quot;&gt;
    &lt;!-- 查询学生 --&gt;
    &lt;select id=&quot;findStudentById&quot; parameterType=&quot;_int&quot; resultType=&quot;com.test.pojo.Student&quot;&gt;
        SELECT * FROM student WHERE student_id = #{id}
    &lt;/select&gt;
    &lt;!-- 增加用户 --&gt;
    &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;com.test.pojo.Student&quot;&gt;
        INSERT INTO student(student_id, name) VALUES(#{id}, #{name})
    &lt;/insert&gt;
    &lt;!-- 删除用户 --&gt;
    &lt;delete id=&quot;deleteStudent&quot; parameterType=&quot;_int&quot;&gt;
        DELETE FROM student WHERE student_id = #{id}
    &lt;/delete&gt;
    &lt;!-- 修改用户 --&gt;
    &lt;update id=&quot;updateStudent&quot; parameterType=&quot;com.test.pojo.Student&quot;&gt;
        UPDATE student SET name = #{name} WHERE student_id = #{id}
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre><p>如果需要使用StudentMapper.xml的Mapper代理,需要先定义一个接口,名为StudentMapper,然后新建方法定义,分别对应配置文件的增删改查配置,然后将StudentMapper中的namespace改为接口定义的地方,即可在业务类中使用Mapper代理。<br>3.StudentMapper.java接口类(pojo/mapper/StudentMapper.java)    </p>
<pre><code>package com.test.pojo.mapper;
import com.test.pojo.Student;
public interface StudentMapper {

    // 根据 id 查询学生信息
    public Student findStudentById(int id) throws Exception;

    // 添加学生信息
    public void insertStudent(Student student) throws Exception;

    // 删除学生信息
    public void deleteStudent(int id) throws Exception;

    // 修改学生信息
    public void updateStudent(Student student) throws Exception;
}
</code></pre><p>4.测试类Test.java            </p>
<pre><code>  package com.test;

import java.io.InputStream;
import com.test.pojo.Student;
import com.test.pojo.mapper.StudentMapper;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;



public class Test {

    public static void main(String[] args) throws Exception {
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        SqlSession session=sqlSessionFactory.openSession();

        // 获取Mapper代理
        StudentMapper studentMapper = session.getMapper(StudentMapper.class);


        //执行 Mapper 代理独享的查询方法
        Student student = studentMapper.findStudentById(1);
        System.out.println(student.getName());

        //insertStudent
        Student student1 = new Student();
        student1.setName(&quot;test_1&quot;);
        student1.setStudent_id(3);
        studentMapper.insertStudent(student1);

        //deleteStudent
        studentMapper.deleteStudent(3);

        //updateStudent
        Student student2 = new Student();
        student2.setStudent_id(2);
        student2.setName(&quot;student_2&quot;);
        studentMapper.updateStudent(student2);

        session.close();
    }}
</code></pre><h3 id="注解开发MyBatis"><a href="#注解开发MyBatis" class="headerlink" title="注解开发MyBatis"></a>注解开发MyBatis</h3><p>依照刚才Mapper的例子:<br>1.我们将StudentMapper.xml的配置的sql语句用注释配置在StudentMapper接口中:</p>
<pre><code>  public interface StudentMapper {

    // 根据 id 查询学生信息
    @Select(&quot;SELECT * FROM student WHERE student_id = #{id}&quot;)
    public Student findStudentById(int id) throws Exception;

    // 添加学生信息
    @Insert(&quot;INSERT INTO student(student_id, name) VALUES(#{id}, #{name})&quot;)
    public void insertStudent(Student student) throws Exception;

    // 删除学生信息
    @Delete(&quot;DELETE FROM student WHERE student_id = #{id}&quot;)
    public void deleteStudent(int id) throws Exception;

    // 修改学生信息
    @Update(&quot;UPDATE student SET name = #{name} WHERE student_id = #{id}&quot;)
    public void updateStudent(Student student) throws Exception;
}
</code></pre><p>2.修改mybatis-config.xml(将之前配置的映射注释掉)</p>
<pre><code>&lt;!-- 映射文件 --&gt;
&lt;mappers&gt;
    &lt;!--&lt;mapper resource=&quot;com/test/pojo/StudentMapper.xml&quot;/&gt;--&gt;
    &lt;mapper class=&quot;com.test.pojo.mapper.StudentMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>3.测试类代码不变,即可运行程序            </p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/c77e3691867d" target="_blank" rel="noopener">https://www.jianshu.com/p/c77e3691867d</a><br><a href="http://how2j.cn/k/mybatis/mybatis-tutorial/1087.html" target="_blank" rel="noopener">http://how2j.cn/k/mybatis/mybatis-tutorial/1087.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/Spring_mvc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/Spring_mvc/" itemprop="url">ssm基础之Spring MVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-23T08:15:41+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>跟着大佬的几篇文章学习了SpringMVC,记录一下。</p>
</blockquote>
<p>SpringMVC:<br>springmvc是一个基于mvc的web框架。</p>
<h4 id="Spring-MVC基本配置"><a href="#Spring-MVC基本配置" class="headerlink" title="Spring MVC基本配置"></a>Spring MVC基本配置</h4><p>1.在web.xml配置入口Servlet    </p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; 
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;    
</code></pre><p>Servlet名字为:mvc-dispatcher   uri-pattern为/:拦截所有请求<br>2.SpringMVC的映射配置文件<br>在<code>mvc-dispatcher-servlet.xml</code>,配置SpringMVC的一些Controller的初始化,静态文件的映射策略,视图的配置等,这里只说下视图解析器的相关配置:        </p>
<pre><code>&lt;!--ViewResolver 视图解析器--&gt;
&lt;!--用于支持Servlet、JSP视图解析--&gt;
&lt;bean id=&quot;jspViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>在SpringMVC中,controller会返回一个字符串(jsp名字)。在jspViewResolver的2个属性分别为jsp文件的前缀(/WEB-INF/pages/)与后缀(.jsp),这样在controller里面,如果返回的字符串是index(<code>return &quot;index&quot;</code>),SpringMVC就会找到<code>/WEB-INF/pages/index.jsp</code>文件    </p>
<p>3.Maven自动导入jar包<br> 既然我们做SpringMVC开发,肯定少不了相关的jar包,但是随着项目增大,原来那种下载包然后导入感觉太麻烦,现在使用Maven就变得简单了。    其实maven的工作原理简单理解就是自动将你需要的jar包下载到本地,然后关联到项目中,所有的包都存储在几个中央仓库里面,需要什么包,就取出什么包<br> pom.xml<br> 重点看<code>&lt;dependencies&gt;</code>标签，将对每个包的需求都看成一个依赖<code>&lt;depedency&gt;</code>,定义在<code>&lt;dependencies&gt;</code>中,在每个<code>&lt;dependencies&gt;</code>中,需要提供jar包的groupid,artifactId和version,我们引入一个junit包的格式:</p>
<pre><code>  &lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;3.8.1&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p>要引入其他包,查询:<a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-15.21.52.56-image.png" alt="2019-01-15.21.52.56-image.png"><br> 在pom.xml中填写<code>&lt;dependencies&gt;</code>标签的内容即可</p>
<p>4.数据库配置<br>SpringMVC集成Spring Data JPA（由 Hibernate JPA 提供），来进行强大的数据库访问<br>在之前接触MVC模式中,数据库的一张表往往对应着一个JavaBean,在SpringMVC中,这个JavaBean就相当于model,且Idea会自动帮我们生成这些类<br>配置数据库有2种方法,由于刚开始学习,先使用较简单的,直接在<code>mvc-dispatcher-servlet.xml</code>中配置:    </p>
<pre><code>&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;
        &lt;property name=&quot;persistenceUnitName&quot; value=&quot;defaultPersistenceUnit&quot;/&gt;
        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.gaussic.model&quot; /&gt;
        &lt;property name=&quot;jpaVendorAdapter&quot;&gt;
            &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt;
        &lt;/property&gt;
        &lt;property name=&quot;jpaProperties&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/springdemo?useSSL=false&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.username&quot;&gt;root&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.password&quot;&gt;111111&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;false&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.useUnicode&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.characterEncoding&quot;&gt;UTF-8&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.use_sql_comments&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.autoReconnect&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/prop&gt;
            &lt;prop key=&quot;connection.autoReconnectForPools&quot;&gt;true&lt;/prop&gt;
            &lt;prop key=&quot;connection.is-connection-validation-required&quot;&gt;true&lt;/prop&gt;

            &lt;prop key=&quot;hibernate.c3p0.validate&quot;&gt;true&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.service.jdbc.connections.internal.C3P0ConnectionProvider&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.min_size&quot;&gt;5&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.max_size&quot;&gt;600&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.timeout&quot;&gt;1800&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.max_statements&quot;&gt;50&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.preferredTestQuery&quot;&gt;SELECT 1;&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.testConnectionOnCheckout&quot;&gt;true&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.idle_test_period&quot;&gt;3000&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>修改上面的连接信息,然后使用Persistence工具再进行配置<br>参考:<a href="https://my.oschina.net/gaussik/blog/513444" target="_blank" rel="noopener">https://my.oschina.net/gaussik/blog/513444</a></p>
<p>5.JPA操作<br>JPA是Java Persistence API的简称,就是定义对数据库的操作。首先新建一个repository包,在repository包中的2个接口:UserRepository，BlogRepository并让其都继承JpaRepository。<br>在JpaRepository中定义了几个简化操作数据库的方法        </p>
<pre><code>   findAll()：查找表中所有记录；
findOne(Integer id)：按id来查找某一条记录
findByXXX(Object xxx)：在这里XXX是一个字段名，根据该字段的值开查找所有记录；
save()和delete()：添加一条记录以及删除一条记录
</code></pre><p>除此之外,我们可以在该接口中定义新的方法,如项目中定义的更新用户信息的例子:</p>
<pre><code>@Repository
public interface UserRepository extends     JpaRepository&lt;UserEntity, Integer&gt; {

@Modifying      // 说明该方法是修改操作
@Transactional  // 说明该方法是事务性操作
// 定义查询
// @Param注解用于提取参数
@Query(&quot;update UserEntity us set us.nickname=:qNickname, us.firstName=:qFirstName, us.lastName=:qLastName, us.password=:qPassword where us.id=:qId&quot;)
public void updateUser(@Param(&quot;qNickname&quot;) String nickname, @Param(&quot;qFirstName&quot;) String firstName,
                       @Param(&quot;qLastName&quot;) String qLastName, @Param(&quot;qPassword&quot;) String password, @Param(&quot;qId&quot;) Integer id);
}
</code></pre><p>然后在controller中使用以下语句更新即可</p>
<pre><code>userRepository.updateUser(user.getNickname(), user.getFirstName(),
                user.getLastName(), user.getPassword(), user.getId());
userRepository.flush();   //刷新
</code></pre><p>6.SpringMVC 拦截器<br>IndexInterceptor.java            </p>
<pre><code>package com.interceptor;
import java.util.Date;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;



/*在业务处理器处理请求(controller)之前被调用
false：从当前拦截器往回执行所有拦截器的afterCompletion()
true:依次执行,直到preHandle都完成---&gt;controller--&gt;从最后一个往回执行postHandle()---&gt;从最后一个往回执行afterCompletion()*/


public class IndexInterceptor extends HandlerInterceptorAdapter {

public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response, Object handler) throws Exception {

    System.out.println(&quot;preHandle(), 在访问Controller之前被调用&quot;);
    return true;

}


 //controller之后,view之前        
public void postHandle(HttpServletRequest request,
                       HttpServletResponse response, Object handler,
                       ModelAndView modelAndView) throws Exception {
    System.out.println(&quot;postHandle(), 在访问Controller之后，访问视图之前被调用,这里可以注入一个时间到modelAndView中，用于后续视图显示&quot;);
    modelAndView.addObject(&quot;date&quot;,&quot;由拦截器生成的时间:&quot; + new Date());
}

 //view之后,用于清理资源    
 public void afterCompletion(HttpServletRequest request,
                            HttpServletResponse response, Object handler, Exception ex)
        throws Exception {

    System.out.println(&quot;afterCompletion(), 在访问视图之后被调用&quot;);
}

}
</code></pre><p>多定义几个拦截器即可理解其执行顺序:<br>在浏览器访问localhost:8080/index时,控制台打印:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-18.09.59.30-image.png" alt="2019-01-18.09.59.30-image.png"></p>
<h4 id="Spring-MVC请求流程"><a href="#Spring-MVC请求流程" class="headerlink" title="Spring MVC请求流程"></a>Spring MVC请求流程</h4><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-20.23.10.44-image.png" alt="2019-01-20.23.10.44-image.png"></p>
<p>1.首先,请求离开浏览器后,第一步到达DispatcherServlet,拦截请求并发送给相应的Spring MVC控制器(DispatcherServlet的任务就是拦截请求并发给控制器)<br>2.处理器映射<br>处理器会根据请求携带的url来进行决策请求对应的控制器是哪个,我们配置控制simpleURLHandlerMapping将/hello地址交给helloController处理:</p>
<pre><code>&lt;bean id=&quot;simpleUrlHandlerMapping&quot;
      class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
    &lt;property name=&quot;mappings&quot;&gt;
        &lt;props&gt;
            &lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt;
            &lt;prop key=&quot;/hello&quot;&gt;helloController&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt;
</code></pre><p>也可以用注释:</p>
<pre><code>@Controller
public class HelloController{

@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
public String hello{
    //处理逻辑
    //返回视图名
}
</code></pre><p>用了注释就不需要在xml文件中指定controller了,不过需要加上<code>&lt;context:component-scan base-package=&quot;com.controller&quot;/&gt;</code><br>3.控制器处理好相关业务后,将需要返回的数据(Model)和用于渲染输出的视图名(Jsp)返回给DispatcherServlet            </p>
<pre><code>public String getUsers(ModelMap modelMap) {

    //处理逻辑

    //返回模型数据
    modelMap.addAttribute(&quot;userList&quot;, userList);

    //返回用于渲染输出的视图名
    return &quot;admin/users&quot;;
}
</code></pre><p>4.视图解析器            </p>
<pre><code>&lt;bean id=&quot;viewResolver&quot;
      class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot; /&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>这是一个Spring MVC内置的一个视图解析器,该解析器遵循:在controller中返回的视图名上添加前缀和后缀,进而确定一个web应用中视图资源的物理路径。上面的解析器说明需要返回目录webapp/WEB-INF/page/admin下的users.jsp文件                </p>
<p>5.视图(users.jsp)<br>在视图文件中接收Controller返回的数据(Model)并用于展示    </p>
<pre><code>&lt;c:forEach items=&quot;${userList}&quot; var=&quot;user&quot;&gt;
    ${user.id}
    ${user.nickname}
    ${user.firstName} ${user.lastName}
    ${user.password}
&lt;/c:forEach&gt;
</code></pre><h4 id="控制器接收请求数据"><a href="#控制器接收请求数据" class="headerlink" title="控制器接收请求数据"></a>控制器接收请求数据</h4><p>1.Servlet原生API        </p>
<pre><code>@RequestMapping(value = &quot;/admin/login1&quot;, method = RequestMethod.POST)
public  String loginp1(HttpServletRequest request, HttpServletResponse response){
    String username1 = request.getParameter(&quot;username1&quot;);
    String password1 = request.getParameter(&quot;password1&quot;);
</code></pre><p>2.使用@RequestParam(“前台参数名”)</p>
<pre><code>@RequestMapping(value = &quot;/admin/login3&quot;, method = RequestMethod.POST)
public  String loginp3(@RequestParam(&quot;username&quot;) String username3, @RequestParam(&quot;password&quot;) String password3){

    System.out.println(username3);
    System.out.println(password3);
    return null;
}
</code></pre><p>3.使用同名匹配规则        </p>
<pre><code>@RequestMapping(value = &quot;/admin/login2&quot;, method = RequestMethod.POST)
public  String loginp2(String username2,String password2){

    System.out.println(username2);
    System.out.println(password2);
    return null;
}
</code></pre><p>4.使用模型(model)传参数<br>要求:前台参数名与模型字段名相同。            </p>
<pre><code>User模型
package pojo;

public class User {

    String userName;
    String password;

    /* getter and setter */
}
</code></pre><p>在控制器中使用:            </p>
<pre><code>@RequestMapping(&quot;/login&quot;)
public String get_(User user){
    //user.getUsername();
    //user.getPassword();
}
</code></pre><h4 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h4><p>同servlet一样,只对POST方法有效(因为直接处理的request)<br>通过配置SpringMVC的字符编码过滤器来完成,web.xml中添加</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;!-- 设置编码格式 --&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h4 id="控制器回显数据"><a href="#控制器回显数据" class="headerlink" title="控制器回显数据"></a>控制器回显数据</h4><p>1.使用 Servlet 原生 API 来实现    </p>
<pre><code>@RequestMapping(&quot;/value&quot;)
public ModelAndView hand(HttpServletRequest request,                              
HttpServletResponse response) {
    request.setAttribute(&quot;message&quot;,&quot;成功！&quot;);
    return new ModelAndView(&quot;test1&quot;);
}
</code></pre><p>2.使用 Spring MVC 所提供的 ModelAndView 对象</p>
<pre><code>@RequestMapping(value = &quot;/admin/login&quot;, method = RequestMethod.GET)
  public ModelAndView login(HttpRequest request, HttpResponse response){
      ModelAndView mv = new ModelAndView(&quot;admin/login&quot;);
      mv.addObject(&quot;message&quot;,&quot;测试&quot;);
      return mv;
  }
</code></pre><p>3.使用 Model 对象(常用)            </p>
<pre><code>session.setAttribute(&quot;count&quot;,i);
modelMap.addAttribute(&quot;count&quot;,i);
</code></pre><p>使用@ModelAttribute注解            </p>
<pre><code>@ModelAttribute
public void model(Model model) {
    model.addAttribute(&quot;message&quot;, &quot;注解成功&quot;);
}

@RequestMapping(&quot;/value&quot;)
public String handleRequest() {
    return &quot;test1&quot;;
}
</code></pre><p>这样程序就会在调用该控制器所有的方法前,调用model()方法将message添加到页面参数中去,在视图中可直接调用。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h4><p><a href="https://my.oschina.net/gaussik/blog/385697" target="_blank" rel="noopener">https://my.oschina.net/gaussik/blog/385697</a><br><a href="http://how2j.cn/k/springmvc/springmvc-springmvc/615.html" target="_blank" rel="noopener">http://how2j.cn/k/springmvc/springmvc-springmvc/615.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/ssm基础之Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/10/ssm基础之Spring/" itemprop="url">ssm基础之Spring</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-10T08:15:41+08:00">
                2019-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>早几天就将Java Web的实验收尾了,项目代码(简易论坛)已经上传到Github了,没事儿看看ssm框架,争取早日撸个商城出来。</p>
</blockquote>
<hr>
<p><a href="https://github.com/P0rZ9/Java_Web/tree/master/Java_Web_BBS" target="_blank" rel="noopener">Java_Web_Bbs项目地址</a></p>
<p>SSM <strong>(Spring+SpringMVC+MyBatis)</strong> 框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。先了解一波Spring。</p>
<blockquote>
<p>Spring是一个开源框架，主要是为了解决项目开发中的紧耦合的问题，采用了控制反转和AOP技术简化了企业级应用的开发，让开发者能够更专注于业务的开发，减少了流程式的代码，简化了开发过程，所以受到开发人员的欢迎。</p>
</blockquote>
<h2 id="IOC-DI-控制反转-依赖注入"><a href="#IOC-DI-控制反转-依赖注入" class="headerlink" title="IOC/DI 控制反转/依赖注入"></a>IOC/DI 控制反转/依赖注入</h2><blockquote>
<p>在java开发中，如果要使用另外一个类的定义的功能，譬如在A类中需要调用B类的方法，那么一般的做法就是在A类中实例化一个B的对象,通过A.b.method()这样的方式来调用，那么这样造成了什么后果呢？那就是A强烈的依赖于B，这个时候就要求B中方法保持稳定，不能随意变动。这个时候B中的代码就被A给“限制”了，如果这个时候你要修改B中的方法，譬如将method()改为methodA()，那么同时也就要修改A中的代码以适应这个改变，这样的程序改动起来很大，也就是说扩展性很低。<br>控制反转就是为了解决这类问题所提出来的一种概念，主要就是通过一个容器来管理对象之间的依赖关系，Spring就提供了这样的一个容器来管理对象之间的依赖。就以上面的场景来说，A需要用到B中的功能，A只需要向容器提出我需要包含xx功能的对象，容器就能给你一个这样的对象，至于这个对象到底是不是B？你管那么多呢？只要能用就行对吧。<br>Spring中提供的这样的容器就是我们经常提到的ApplicationContext。</p>
</blockquote>
<h2 id="AOP-Aspect-Oriented-Program-面向切面编程"><a href="#AOP-Aspect-Oriented-Program-面向切面编程" class="headerlink" title="AOP(Aspect Oriented Program)面向切面编程"></a>AOP(Aspect Oriented Program)面向切面编程</h2><blockquote>
<p>在开发中，经常会遇到相同的模块，例如打印日志，安全管理这样的功能，可能每一个类都会有这样的需要。譬如我要记录每一个类的调用记录，使用参数等信息，这种功能k可以在每个类中加入相似的代码，直接打印出来就好。但是这种方法将辅助性的功能放到实际业务里去实现了，使每个方法承担的使命太多，如果能狗自动打印日志，不是更好吗？而这种通用的功能就称之为一个切面，面向切面的编程能够简化开发的实际代码，更好的关注于业务本身。</p>
</blockquote>
<h3 id="演示IOC-反转控制-和DI-依赖注入"><a href="#演示IOC-反转控制-和DI-依赖注入" class="headerlink" title="演示IOC(反转控制)和DI(依赖注入)"></a>演示IOC(反转控制)和DI(依赖注入)</h3><h4 id="运行TestSpring演示用Spring获取一个对象-并打印name"><a href="#运行TestSpring演示用Spring获取一个对象-并打印name" class="headerlink" title="运行TestSpring演示用Spring获取一个对象,并打印name"></a>运行TestSpring演示用Spring获取一个对象,并打印name</h4><p>1.<strong>Eclipse新建项目(Java Project),项目名字spring</strong><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.02.18-image.png" alt="2019-01-10.11.02.18-image.png"></p>
<p>2.<strong>下载项目所需的jar包,并导入项目中(Build Path—&gt;Add Externam JARs)</strong><br><a href="http://how2j.cn/frontdownload?bean.id=1484" target="_blank" rel="noopener">Jar包下载</a>,导入后:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.03.44-image.png" alt="2019-01-10.11.03.44-image.png"></p>
<p>3.<strong>pojo</strong><br>准备pojo Source类    </p>
<pre><code>package pojo;

public class Source {
     private int id;
    private String name;

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }  
}
</code></pre><p><strong>4.applicationContext.xml</strong><br>在src目录下新建applicationContext.xml,这是Spring的核心配置文件,通过关键字s获取Source对象,该对象获取的时候,即被注入了字符串”test1”到name属性,数值1到id属性中。    </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans         
xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xsi:schemaLocation=&quot;
   http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
 http://www.springframework.org/schema/aop
 http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
 http://www.springframework.org/schema/tx
 http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
 http://www.springframework.org/schema/context     
 http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;

&lt;bean name=&quot;s&quot; class=&quot;pojo.Source&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test1&quot; /&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot; /&gt;
&lt;/bean&gt;
</code></pre><p></p>
<p><strong>5.TestSpring</strong><br>测试代码,演示通过spring获取Source对象,以及该对象被注入的name属性。如图所示,打印通过Spring拿到的Source对象的name与id属性。    </p>
<pre><code>package test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import pojo.Source;

public class TestSpring {
public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(
            new String[] { &quot;applicationContext.xml&quot; });

    Source s = (Source) context.getBean(&quot;s&quot;);

    System.out.println(s.getName());
    System.out.println(s.getId());
    }
}
</code></pre><p>运行结果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.18.44-image.png" alt="2019-01-10.11.18.44-image.png">    </p>
<p><strong>6.原理图</strong><br>获取对象的方式比较:<br>传统:<code>Source s = new Source();</code><br>IOC:<code>Source s = (Source) context.getBean(&quot;s&quot;);</code><br>对象的声明周期由Spring来管理,直接从Spring那里去获取一个对象,IOC是控制反转(Inversion Of Control)的缩写,控制权交给了Spring。    </p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.22.29-image.png" alt="2019-01-10.11.22.29-image.png"></p>
<hr>
<p>上面第一个例子演示了注入对象的属性,下面演示注入Source对象</p>
<h4 id="向Product注入Source对象"><a href="#向Product注入Source对象" class="headerlink" title="向Product注入Source对象"></a>向Product注入Source对象</h4><p>1.Product.java    </p>
<pre><code>package pojo;

public class Product {
    private int id;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Source getSource() {
        return source;
    }
    public void setSource(Source source) {
        this.source = source;
    }
    private String name;
    private Source source;
}
</code></pre><p>2.applicationContext.xml(关键) 在创建Product的时候注入一个Source对象(使用ref来注入另一个对象)        </p>
<pre><code>&lt;bean name=&quot;s&quot; class=&quot;pojo.Source&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test1&quot; /&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot; /&gt;
&lt;/bean&gt;

&lt;bean name=&quot;p&quot; class=&quot;pojo.Product&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;product1&quot; /&gt;
    &lt;property name=&quot;source&quot; ref=&quot;s&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>3.TestSpring.java    </p>
<pre><code>package test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import pojo.Source;
import pojo.Product;

public class TestSpring {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(
                new String[] { &quot;applicationContext.xml&quot; });

        //Source s = (Source) context.getBean(&quot;s&quot;);
        Product p = (Product) context.getBean(&quot;p&quot;); 

        System.out.println(p.getName());
        System.out.println(p.getSource().getName());

    }
}
</code></pre><p>通过Spring拿到的Product对象已经被注入了Source对象<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.41.51-image.png" alt="2019-01-10.11.41.51-image.png"></p>
<h4 id="注解方式演示IOC-DI-对注入对象的注解"><a href="#注解方式演示IOC-DI-对注入对象的注解" class="headerlink" title="注解方式演示IOC/DI(对注入对象的注解)"></a>注解方式演示IOC/DI(对注入对象的注解)</h4><p>1.修改applicationContext.xml    </p>
<pre><code>&lt;context:annotation-config/&gt;  
 &lt;bean name=&quot;s&quot; class=&quot;pojo.Source&quot;&gt;
     &lt;property name=&quot;name&quot; value=&quot;test1&quot; /&gt;
 &lt;/bean&gt;
 &lt;bean name=&quot;p&quot; class=&quot;pojo.Product&quot;&gt;
     &lt;property name=&quot;name&quot; value=&quot;product1&quot; /&gt;
 &lt;/bean&gt;
</code></pre><p>2.在Product.java中,在定义对象前加<code>@Autowired</code></p>
<pre><code>@Autowired
private Source source;
</code></pre><p>也可以在setSource(Source source)前面添加    </p>
<pre><code>@Autowired
public void setSource(Source source) {
    this.source = source;
}
</code></pre><p>也可以在</p>
<pre><code>@Resource(name=&quot;s&quot;)
private Source source;
</code></pre><h4 id="对Bean本身的注解"><a href="#对Bean本身的注解" class="headerlink" title="对Bean本身的注解"></a>对Bean本身的注解</h4><p>1.修改applicationContext.xml,只新增:</p>
<pre><code>&lt;context:component-scan base-package=&quot;pojo&quot;/&gt;
</code></pre><p>作用是告诉Spring,bean都放在pojo这个包下。</p>
<p>2.注解@Component,表示该类为bean    </p>
<pre><code>@Component(&quot;p&quot;)
public class Product {

@Component(&quot;s&quot;)
public class Source {
</code></pre><p>3.因为配置在applicationContext.xml中已经删除,所以属性的初始化要在属性的声明时进行。            </p>
<pre><code>private String name=&quot;product 1&quot;;
private String name=&quot;test1&quot;;
</code></pre><p>Product.java    </p>
<pre><code>package pojo;

import javax.annotation.Resource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component(&quot;p&quot;)
public class Product {
private int id;
private String name = &quot;product 2&quot;;

@Autowired
private Source source;

public int getId() {
    return id;
}
public void setId(int id) {
    this.id = id;
}
public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}
public Source getSource() {
    return source;
}

public void setSource(Source source) {
    this.source = source;
 }

}
</code></pre><h2 id="AOP-Aspect-Oriented-Program-面向切面编程-1"><a href="#AOP-Aspect-Oriented-Program-面向切面编程-1" class="headerlink" title="AOP(Aspect Oriented Program)面向切面编程"></a>AOP(Aspect Oriented Program)面向切面编程</h2><p>1.jar包:<a href="http://how2j.cn/frontdownload?bean.id=1810" target="_blank" rel="noopener">http://how2j.cn/frontdownload?bean.id=1810</a></p>
<p>2.业务类:ProductService.java    </p>
<pre><code>package service
public class ProductService {

public void doSomeService(){

    System.out.println(&quot;doSomeService&quot;);

}
</code></pre><p>}</p>
<p>3.准备日志切面LoggerAspect.java<br>功能:在调用核心功能之前和之后分别打印日志,切面就是原理图中讲的那些辅助功能.将来与某个核心功能编制后,用于实现核心功能的代码:<code>Object object = joinPoint.proceed();</code></p>
<pre><code>package aspect;
import org.aspectj.lang.ProceedingJoinPoint;

public class LoggerAspect {

    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;start log:&quot; + joinPoint.getSignature().getName());
        Object object = joinPoint.proceed();
        System.out.println(&quot;end log:&quot; + joinPoint.getSignature().getName());
        return object;
    }
}
</code></pre><p>4.applicationContext.xml</p>
<pre><code>&lt;bean name=&quot;se&quot; class=&quot;service.ProductService&quot;&gt;
&lt;/bean&gt;   
&lt;bean id=&quot;loggerAspect&quot; class=&quot;aspect.LoggerAspect&quot;/&gt;

&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;loggerCutpoint&quot; expression=&quot;execution(* service.ProductService.*(..)) &quot;/&gt;        
    &lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;loggerAspect&quot;&gt;
    &lt;aop:around pointcut-ref=&quot;loggerCutpoint&quot; method=&quot;log&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;    
</code></pre><p>大概讲以下这个xml的含义:<br>第一行:<code>&lt;bean name=&quot;se&quot; class=&quot;service.ProductService&quot;&gt;
    &lt;/bean&gt;</code> 是声明业务对象的<br>第二行:<code>&lt;bean id=&quot;loggerAspect&quot; class=&quot;aspect.LoggerAspect&quot;/&gt;</code>是声明日志切面的<br>第三行:<code>&lt;aop:pointcut id=&quot;loggerCutpoint&quot; expression=&quot;execution(* service.ProductService.*(..)) &quot;/&gt;</code><br>表示id为该切入点的标识符,expression表示满足该正则的方法调用后,就会进行切面操作,类似于触发了切面。<br><code>expression</code>:第一个<em>表示返回任意类型,包名为<code>service.ProductService</code>开头的类的任意方法(第二个</em>表示任意方法)(..)表示参数的任意类型和个数。<br>简单来说,第三行代码意思就是service包中的ProductService类的任意一个函数被调用,不管返回值为什么,都会触发开关,去执行切面(相当于将业务对象于辅助功能编织在一起),也就是辅助功能:<br><code>&lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;loggerAspect&quot;&gt;
        &lt;aop:around pointcut-ref=&quot;loggerCutpoint&quot; method=&quot;log&quot;/&gt;</code><br>上面说的只要触发开关,就回去执行切面,这里所谓的切面其实就是一个类的方法而已。<br>id代表这个切面的名字,ref表明方法所在类,method代表方法的名字,<code>pointcut-ref=&quot;loggerCutpoint&quot;</code>表示这个切面与上面的切点关联起来的,只要上面的切点被触发,我就会在这里执行一些辅助功能。    <code>&lt;aop:around</code>表示执行的顺序。具体看AOP的基本概念。</p>
<p>5.TestSpring.java    </p>
<pre><code>package test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import service.ProductService;

public class TestSpring {
public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(
            new String[] { &quot;applicationContext.xml&quot; });
    ProductService s = (ProductService) context.getBean(&quot;se&quot;);
    s.doSomeService();
}
</code></pre><p>}</p>
<p>执行结果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.17.24.40-image.png" alt="2019-01-10.17.24.40-image.png"></p>
<h3 id="AOP的几个重要概念"><a href="#AOP的几个重要概念" class="headerlink" title="AOP的几个重要概念"></a>AOP的几个重要概念</h3><p>1.通知<br>定义了切面何时工作及工作内容,即什么时候去执行切面程序与功能具体的代码。这里一共有5种类型,分别为</p>
<pre><code>a.Before 在方法之前调用通知
b.After 在方法之后调用通知,无论是否执行成功
c.around 在方法之前与之后都调用
d.After-Return    方法执行成功后调用
e.After-throwing    方法抛出异常后调用
</code></pre><p>执行顺序:            </p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.17.05.53-image.png" alt="2019-01-10.17.05.53-image.png">            </p>
<p>&lt;aop:aspect id=”logAspect” ref=”loggerAspect”&gt;<br>            &lt;aop:around pointcut-ref=”loggerCutpoint” method=”log”/&gt;<br>        &lt;/aop:aspect&gt;</p>
<p>2.连接点<br>在执行正常功能时,能够插入切面的点,连接点可以是调用方法时、抛出异常时、甚至修改字段时,在这些点,就可以去执行切面            </p>
<p>3.切面<br>定义:切面是切点与通知的集合,通知和切点定义了切面的全部功能—(它是什么,在何时何处完成其功能)<br>声明切面:<code>&lt;aop:aspect&gt;</code>完成的,ref指定类,pointcut-ref,pointcut-ref表明与哪个切点联系,method指定要执行的方法。    </p>
<p>4.切点<br>通知定义了”何时”与”什么”,而切点定义了”何处”<br>作用:定义通知被调用的位置(在哪些连接点)<br>声明切点：<br><strong>a.在\&lt;<a href="aop:config\" target="_blank" rel="noopener">aop:config\</a>&gt;标签下使用\&lt;<a href="aop:pointcut\" target="_blank" rel="noopener">aop:pointcut\</a>&gt;声明一个切入点Bean</strong>该切入点可被多个切面使用,对于需要共享的切入点最好使用该方式。</p>
<pre><code>&lt;aop:config&gt;  
   &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* cn.javass..*.*(..))&quot;/&gt;  
   &lt;aop:aspect ref=&quot;aspectSupportBean&quot;&gt;  
      &lt;aop:before pointcut-ref=&quot;pointcut&quot; method=&quot;before&quot;/&gt;  
   &lt;/aop:aspect&gt;  
&lt;/aop:config&gt;
</code></pre><p>&lt;aop:pointcut id=”loggerCutpoint” expression=”execution(<em> service.ProductService.</em>(..)) “/&gt;        </p>
<p><strong>b.在<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下使用<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>声明一个切入点Bean</strong>该切入点一般只用于该切面。</p>
<pre><code>&lt;aop:config&gt;  
 &lt;aop:aspect ref=&quot;aspectSupportBean&quot;&gt;  
    &lt;aop:pointcut id=&quot; pointcut&quot; expression=&quot;execution(* cn.javass..*.*(..))&quot;/&gt;  
    &lt;aop:before pointcut-ref=&quot;pointcut&quot; method=&quot;before&quot;/&gt;  
 &lt;/aop:aspect&gt;  
&lt;/aop:config&gt;  
</code></pre><p><strong>c.匿名切入点Bean，可以在声明通知时通过pointcut属性指定切入点表达式，该切入点是匿名切入点，只被该通知使用</strong></p>
<pre><code>&lt;aop:config&gt;  
 &lt;aop:aspect ref=&quot;aspectSupportBean&quot;&gt;  
     &lt;aop:after pointcut=&quot;execution(* cn.javass..*.*(..))&quot; method=&quot;afterFinallyAdvice&quot;/&gt;  
 &lt;/aop:aspect&gt;  
&lt;/aop:config&gt;  
</code></pre><p>5.引入<br>允许我们向现有的类中添加方法或属性。        </p>
<p>6.织入(未理解,先占坑,有时间回来描述)        </p>
<h3 id="注解方式AOP"><a href="#注解方式AOP" class="headerlink" title="注解方式AOP"></a>注解方式AOP</h3><p>1.配置业务类    </p>
<pre><code>@Component(&quot;se&quot;)
public class ProductService {
</code></pre><p>2.注解配置切面</p>
<pre><code>@Aspect 注解表示这是一个切面
@Component 表示这是一个bean,由Spring进行管理
@Around(value = &quot;execution(* com.how2java.service.ProductService.*(..))&quot;) 表示对com.how2java.service.ProductService 这个类中的所有方法进行切面操作
</code></pre><p>LoggerAspect.java</p>
<pre><code>package aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;


@Aspect
@Component
public class LoggerAspect {

    @Around(value = &quot;execution(* service.ProductService.*(..))&quot;)
    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;start log:&quot; + joinPoint.getSignature().getName());
        Object object = joinPoint.proceed();
        System.out.println(&quot;end log:&quot; + joinPoint.getSignature().getName());
        return object;
    }
}
</code></pre><p>3.applicationContext.xml(关键)            </p>
<pre><code>//扫描aspect与service包,定位业务类与切面类
&lt;context:component-scan base-package=&quot;aspect&quot;/&gt;
&lt;context:component-scan base-package=&quot;service&quot;/&gt; 

//找到被注解了的切面类,进行切面设置
&lt;aop:aspectj-autoproxy/&gt; 
</code></pre><p>4.TestSpring.java与上一个xml设置的代码相同。<br>运行结果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.19.56.37-image.png" alt="2019-01-10.19.56.37-image.png">        </p>
<h3 id="AOP注解方式测试"><a href="#AOP注解方式测试" class="headerlink" title="AOP注解方式测试"></a>AOP注解方式测试</h3><p>1.jar包下载:<br><a href="http://how2j.cn/frontdownload?bean.id=1189" target="_blank" rel="noopener">jubit.jar</a><br><a href="http://how2j.cn/frontdownload?bean.id=1190" target="_blank" rel="noopener">hamcrest.jar</a></p>
<p>2.applicationContext.xml</p>
<pre><code>&lt;context:component-scan base-package=&quot;pojo&quot;/&gt;
</code></pre><p>3.Source.java</p>
<pre><code>package pojo;

import org.springframework.stereotype.Component;

@Component(&quot;s&quot;)
public class Source {
    private int id;
    private String name = &quot;test2&quot;;

public int getId() {
    return id;
}
public void setId(int id) {
    this.id = id;
}
public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}
</code></pre><p>}</p>
<p>3.TestSpring.java</p>
<pre><code>package test;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import pojo.Source;
import service.ProductService;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)
public class TestSpring {

@Autowired
Source s;

@Test
public void test() {
    System.out.println(s.getName());
    }
}
</code></pre><p>运行结果：<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.20.37.25-image.png" alt="2019-01-10.20.37.25-image.png">        </p>
<p>参考:<br><a href="https://www.imooc.com/learn/196" target="_blank" rel="noopener">https://www.imooc.com/learn/196</a><br><a href="http://how2j.cn/k/spring/spring-ioc-di/87.html" target="_blank" rel="noopener">http://how2j.cn/k/spring/spring-ioc-di/87.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/09/Burp插件开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/09/Burp插件开发/" itemprop="url">Burp插件开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-09T08:15:41+08:00">
                2019-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近学习Java,想起以前大佬写的Burp插件,就照猫画虎写了几个简单的插件,简单记录下过程。</p>
</blockquote>
<hr>
<p>关于Java基础语法移步笔者以前文章：<a href="https://p0rz9.github.io/2019/01/08/Java语法基础/" target="_blank" rel="noopener">https://p0rz9.github.io/2019/01/08/Java语法基础/</a></p>
<h3 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h3><h4 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h4><blockquote>
<p>接口（英文：Interface）在 Java 编程语言中是一个比较抽象的东西。熟悉 OOP 的同学可以用”类”的思想来理解接口。但是，要明白的是，类与接口有相似的地方同时也有很多不同的地方。</p>
</blockquote>
<h4 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h4><p>接口的声明语法格式如下：</p>
<pre><code>[可见度] interface 接口名称 [extends 其他的类名] {
        // 声明变量
        // 抽象方法
}
</code></pre><p>Burp的接口声明</p>
<pre><code>package burp;
public interface IBurpExtender
{
    void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks);
}
</code></pre><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><blockquote>
<p>一个接口可以被另外一个接口继承，也可以被一个类实现。当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。类使用implements关键字实现接口。</p>
</blockquote>
<p>实现接口的语法    </p>
<pre><code>#!java
... implements 接口名称[, 其他接口1, 其他接口2..., ...] ...
</code></pre><hr>
<h3 id="编写Burp插件"><a href="#编写Burp插件" class="headerlink" title="编写Burp插件"></a>编写Burp插件</h3><p>编写插件应该分为三步,导入Burp提供接口—&gt;编写功能代码—&gt;导入插件</p>
<h4 id="导入Burp插件接口"><a href="#导入Burp插件接口" class="headerlink" title="导入Burp插件接口"></a>导入Burp插件接口</h4><p>1.将Burp提供的接口文件(Burp目录)导入Java项目中<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-09.16.28.35-image.png" alt="2019-01-09.16.28.35-image.png"><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-09.16.30.37-image.png" alt="2019-01-09.16.30.37-image.png"></p>
<h4 id="编写插件代码"><a href="#编写插件代码" class="headerlink" title="编写插件代码"></a>编写插件代码</h4><p>新建一个BurpExtender.java文件,这是编写插件必须要写的一个类,然后编写所要实现功能的代码</p>
<h4 id="导出Jar文件并加载插件"><a href="#导出Jar文件并加载插件" class="headerlink" title="导出Jar文件并加载插件"></a>导出Jar文件并加载插件</h4><p>将上一步编写完成的插件,打包导入<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-09.16.40.25-image.png" alt="2019-01-09.16.40.25-image.png"></p>
<h3 id="BurpSuite官方接口"><a href="#BurpSuite官方接口" class="headerlink" title="BurpSuite官方接口"></a>BurpSuite官方接口</h3><p>其中最重要的就是编写代码部分,首先注意:<br>编写Burp插件必须编写BurpExtender类，实现接口IBurpExtender且声明为<code>public</code><br>IBurpExtender实现接口IBurpExtender,IProxyListener的demo:    </p>
<pre><code>package burp;
public class BurpExtender implements IBurpExtender{

  // 实现 IBurpExtender 接口的 registerExtenderCallbacks 方法
  @Override
  public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) {
      // TODO here
  }
}
</code></pre><p>Burp提供的接口类说明文档:<a href="https://portswigger.net/burp/extender/api/index.html" target="_blank" rel="noopener">https://portswigger.net/burp/extender/api/index.html</a><br>下面根据接口功能的不同对接口进行分类：</p>
<p>1.插件入口和帮助接口类:<code>IBurpExtender、IBurpExtenderCallbacks、 IExtensionHelpers、IExtensionStateListener</code></p>
<pre><code>IBurpExtender接口类是Burp插件的入口，所有Burp的插件均需要实现此接口，并且 类命名为BurpExtender。IBurpExtenderCallbacks接口类是IBurpExtender接口的实现类与Burp其他各个组件（Scanner、Intruder、Spider……）、各个通信对象 （HttpRequestResponse、HttpService、SessionHandlingAction）之间的连接。 IExtensionHelpers、IExtensionStateListener这两个接口类是插件的帮助和管理操作的接口定义。IBurpExtender、IBurpExtenderCallbacks、 IExtensionHelpers、IExtensionStateListener
</code></pre><p>2.UI相关接口类:<code>IContextMenuFactory、IContextMenuInvocation、ITab、ITextEditor、 IMessageEditor、IMenuItemHandler</code></p>
<pre><code>这类接口类主要是定义Burp插件的UI显示和动作的处理事件，主要是软件交互中使用。
</code></pre><p>3.Burp工具组件接口类:<code>IInterceptedProxyMessage、IIntruderAttack、 IIntruderPayloadGenerator、IIntruderPayloadGeneratorFactory、 IIntruderPayloadProcessor、IProxyListener、IScanIssue、IScannerCheck、 IScannerInsertionPoint、IScannerInsertionPointProvider、IScannerListener、IScanQueueItem、IScopeChangeListener</code></p>
<pre><code>这些接口类的功能非常好理解，Burp在接口定义的命名中使用了的见名知意的规范，看到接口类的名称，基本就能猜测出来这个接口是适用于哪个工具组件。
</code></pre><p>4.HTTP消息处理接口类：<code>ICookie、IHttpRequestResponsePersisted、IHttpRequestResponseWithMarkers、IHttpService、 IRequestInfo、IParameter、IResponseInfo</code></p>
<pre><code>这些接口的定义主要是围绕HTTP消息通信过程中涉及的Cookie、Request、 Response、Parameter几大消息对象，通过对通信消息头、消息体的数据处理，来达到控制HTTP消息传递的目的。
</code></pre><h4 id="几个写插件常用的接口"><a href="#几个写插件常用的接口" class="headerlink" title="几个写插件常用的接口:"></a>几个写插件常用的接口:</h4><p>1.<code>registerExtenderCallbacks</code>是IBurpExtender接口的实现类,与Burp的其他组件(Scanner Intruder Spider)及通信对象连接(HttpRequestResponse HttpService SessionHandlingAction)之间的连接。</p>
<p>2.HTTP消息处理接口类:IHttpListener(注册Http监听器)  </p>
<pre><code>//注册Http监听器
public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo)
{    
//toolFlag:指示了发起请求或收到响应的 Burp 工具的 ID，所有的 toolFlag 定义在 IBurpExtenderCallbacks 接口中。
//messageIsRequest:指示该消息是请求消息（值为True）还是响应消息（值为False）
//messageInfo:被处理的消息的详细信息，是一个 IHttpRequestResponse 对象
}
</code></pre><p>3.<code>IHttpRequestResponse</code>类</p>
<pre><code>byte[] request_by = messageInfo.getRequest();
byte[] response = messageInfo.getResponse();
IHttpService httpService = messageInfo.getHttpService();
String Highlight = messageInfo.getHighlight();
String Comment = messageInfo.getComment();
</code></pre><p>4.<code>IHttpListener</code>接口<br>可通过调用IBurpExtenderCallbacks.registerHttpListener()注册一个HTTP监听器,Burp的任何一个接口发起HTTP请求或者收到HTTP响应都会通知此监听器。该接口可得到这些交互数据,进行分析和修改。<br>方法:        </p>
<pre><code>void processHttpMessage(int toolFlag,boolean messageIsRequest,IHttpRequestResponse messageInfo);
参数:toolFlag  发起或收到请求的插件ID,所有的ID已经在IBurpExtenderCallbacks定义好了。
    boolean messageISRequest 提示该消息是请求消息(True)还是响应消息（False）
    IHttpRequestResponse messageInfo 被处理的消息的详细消息,是一个IHttpRequestResponse对象
</code></pre><p>5.<code>IContextMenuFactory</code>类实现菜单效果</p>
<pre><code>package burp;

import java.util.ArrayList;
import java.util.List;
import javax.swing.JMenu;
import javax.swing.JMenuItem;

public class BurpExtender implements IBurpExtender, IContextMenuFactory{

@Override
public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks){

    //插件名称
    callbacks.setExtensionName(&quot;Her0in&quot;);

    //注册菜单
    callbacks.registerContextMenuFactory(this);
}


@Override
public List&lt;JMenuItem&gt; createMenuItems(final IContextMenuInvocation invocation) {

    List&lt;JMenuItem&gt; listMenuItems = new ArrayList&lt;JMenuItem&gt;();

    //子菜单
    JMenuItem menuItem;
    menuItem = new JMenuItem(&quot;子菜单&quot;);  

    //父级菜单
    JMenu jMenu = new JMenu(&quot;父菜单&quot;);

    //菜单操作
    jMenu.add(menuItem);        
    listMenuItems.add(jMenu);


    return listMenuItems;
}


@Override
public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo,
        BurpExtender helpers) {
    // TODO Auto-generated method stub

}
</code></pre><p>}</p>
<p>加载插件:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.16.22.20-image.png" alt="2018-12-11.16.22.20-image.png"></p>
<p>查看效果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.16.23.21-image.png" alt="2018-12-11.16.23.21-image.png"></p>
<p>6.<code>ICookie</code>接口    </p>
<pre><code>// 此方法用于获取 Cookie 的域
java.lang.String    getDomain()

// 此方法用于获取 Cookie 的过期时间
java.util.Date  getExpiration()

// 此方法用于获取 Cookie 的名称
java.lang.String    getName()

// 此方法用于获取 Cookie 的路径
java.lang.String    getPath()

// 此方法用于获取 Cookie 的值
java.lang.String    getValue()
</code></pre><p>7.<code>IExtensionHelpers</code>接口:<br>此接口提供很多常用的辅助方法,可通过调用<code>IBurpExtenderCallbacks.getHelpers</code>获得此接口的实例。    </p>
<pre><code>byte[]  addParameter(byte[] request, IParameter parameter) //添加参数到指定的请求中,并更新Content-Length

IRequestInfo analyzeRequest(byte[] request)  //分析request的请求信息
IResponseInfo analyzeResponse(byte[] response)  //分析response的响应消息

byte[]  buildHttpMessage(java.util.List&lt;java.lang.String&gt; headers, byte[] body)  //构建请求包,返回响应报


byte[]  buildHttpRequest(java.net.URL url) //向指定的url发起get请求
java.lang.String    bytesToString(byte[] data)   //bytes到String的转换
java.lang.String    bytesToString(byte[] data)   //String到bytes的转换


实例：
private IExtensionHelpers helpers;

this.helpers = callbacks.getHelpers();

byte[] request = messageInfo.getRequest();
IRequestInfo a = helpers.analyzeRequest(request);
</code></pre><p>8.<code>IHttpRequestResponse</code>接口<br>该接口用于检索与更新有关HTTP消息的详细信息    </p>
<pre><code>java.lang.String getComment()          //获取用户的标注信息
java.lang.String getHighlight()       /获取用户标注的高亮信息
IHttpService getHttpService()   //获取请求响应的http服务信息    

byte[]  getRequest()  // 获取 HTTP 请求信息
byte[]  getResponse()  // 获取 HTTP 响应信息

void    setHttpService(IHttpService httpService)  //更新请求/响应HTTP服务信息
void    setRequest(byte[] message)    // 更新 HTTP 请求信息
void    setResponse(byte[] message)  // 更新 HTTP 响应信息
</code></pre><p>9.<code>IHttpService</code>接口<br>此接口用于提供关于 HTTP 服务信息的细节    </p>
<pre><code>java.lang.String getHost()    
int getPort()    
java.lang.String getProtocol()    


例子:
public void processHttpMessage(int toolFlag, boolean messageIsRequest,
        IHttpRequestResponse messageInfo) {

    IHttpService iHttpService = messageInfo.getHttpService();

    this.stdout.println(&quot;Host:&quot;+iHttpService.getHost());
    this.stdout.println(&quot;Port:&quot;+iHttpService.getPort());
    this.stdout.println(&quot;Protocol:&quot;+iHttpService.getProtocol());
}
</code></pre><p>在放掉拦截的数据包后,效果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.18.01.11-image.png" alt="2018-12-11.18.01.11-image.png"></p>
<p>10.<code>IInterceptedProxyMessage</code>接口<br>该接口不能被扩展实现,它表示已被Burp代理拦截的HTTP消息。我们可以利用接口注册一个IProxyListener以得到代理消息的细节。    </p>
<pre><code>callbacks.registerProxyListener(this);  //注册代理监听器

IHttpRequestResponse message1 = message.getMessageInfo();  //请求的详细信息
int action = message.getInterceptAction();      //当前的拦截操作类型    

//获取客户端的Ip,即代理Ip
stdout.println(message.getClientIpAddress());

//获取当前的拦截操作类型  
stdout.println(action);

//获取请求的详细信息
stdout.println(message1);

// Drop 掉所有请求
//message.setInterceptAction(IInterceptedProxyMessage.ACTION_DROP);
</code></pre><p>11.<code>Itab</code>接口:</p>
<pre><code>package burp;
import java.awt.Component;
import java.io.PrintWriter;

import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

public class BurpExtender implements IBurpExtender, ITab {
      public PrintWriter stdout;
      public IExtensionHelpers helpers;
      private JPanel jPanel1;
      private JButton jButton1;

  @Override
  public void registerExtenderCallbacks( final IBurpExtenderCallbacks callbacks) {

      this.stdout = new PrintWriter(callbacks.getStdout(), true);
      this.helpers = callbacks.getHelpers();

      //设置扩展名
      callbacks.setExtensionName(&quot;JSON劫持检测&quot;);

       //创建我们的窗体
       SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                 //我们的主窗体
                 jPanel1 = new JPanel();
                 jButton1 = new JButton(&quot;测试按钮&quot;);

                 //将按钮添加到面板中
                 jPanel1.add(jButton1);

                 //自定义我们的组件
                 callbacks.customizeUiComponent(jPanel1);
                 //添加标签到Burp主窗体
                 callbacks.addSuiteTab(BurpExtender.this);
            }
       });
  }
  @Override
  public String getTabCaption() {
       return &quot;JSON劫持检测&quot; ;
  }

  @Override
  public Component getUiComponent() {
       return jPanel1;
  }

@Override
public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo,
        BurpExtender helpers) {
    // TODO Auto-generated method stub        
}
}
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.22.21.12-image.png" alt="2018-12-11.22.21.12-image.png"></p>
<p>我们也可以学习官方插件代码,下载JD-GUI工具:<br><a href="https://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/JD-GUI.shtml" target="_blank" rel="noopener">https://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/JD-GUI.shtml</a><br>在burpsuite安装目录下的bapps目录下存放已经安装的插件源代码,用下载的JD-GUI直接打开即可看到源码。</p>
<h3 id="实战编写"><a href="#实战编写" class="headerlink" title="实战编写"></a>实战编写</h3><p>Jsonp劫持插件:<br><a href="https://github.com/P0rZ9/Burp_Extender/tree/master/Json_Hijacking" target="_blank" rel="noopener">插件源码</a></p>
<p><a href="https://github.com/P0rZ9/Burp_Extender/raw/master/Json_Hijacking/Burp/Json_Hijacking.jar" target="_blank" rel="noopener">插件成品</a></p>
<p>Http请求入库插件:<br><a href="https://github.com/P0rZ9/Burp_Extender/tree/master/Http_to_Mysql/Http_to_Mysql" target="_blank" rel="noopener">插件源码</a></p>
<p><a href="https://github.com/P0rZ9/Burp_Extender/raw/master/Http_to_Mysql/Http_to_Mysql/http-to-mysql.jar" target="_blank" rel="noopener">插件成品</a></p>
<p><strong>注:如插件要导入其他扩展包,如需要使用数据库操作(需导入mysql-connector-java-bin.jar),在加载到Burp时应将几个Jar打包为一个文件:</strong></p>
<pre><code>1.将项目引入的jar包跟项目导出的包放入当前目录下
2..将包分别解压
  jar -xvf 1.jar
  jar -xvf 2.jar
  jar -xvf 引入的jar包
3.将所有jar包移出当前目录
4.将当前目录文件打包为一个jar文件
  jar -cvfM result.jar .   (别忘了.)
5.导入BurpSuite即可  
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/Java语法基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/Java语法基础/" itemprop="url">基础知识 | JAVA语法基础<一></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-08T08:15:41+08:00">
                2019-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>终于忙完考试了,计划接下来的2周时间除了完成课设外,打算补下Java,读2本推理小说,接着更新博客。</p>
</blockquote>
<hr>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Java是一种面向对象程序设计语言,所有的数据类型都是用类描述的,Java程序也是由若干个类组成的,想学好Java,类是必须要掌握的。</p>
<h3 id="类知识"><a href="#类知识" class="headerlink" title="类知识"></a>类知识</h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><p>Java中的类分为类声明与类主体    </p>
<h5 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h5><pre><code>格式:`修饰符 class 类名 extends 父类名 implements 接口名`        
修饰符:可选,分为定义类的性质(abstract,final)和访问权限(public和默认等)    
extends:可选,继承父类,如无指定,默认继承Java.lang.Object,只支持单继承
implements:可选,用于指明该类实现的接口,允许一个类实现多个接口(,分割)。    
</code></pre><h5 id="类主体"><a href="#类主体" class="headerlink" title="类主体"></a>类主体</h5><p>包括成员变量与成员方法的定义与实现    </p>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>格式:<code>变量修饰符 变量类型 变量名</code><br>变量类型为Java语言中任意的数据类型或引用数据类型(类,数组等),成员变量通过其变量修饰符来确定访问权限。</p>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>格式:<code>方法修饰符 返回类型 方法名(参数列表)</code><br>方法修饰符:public,private,protected,final,static,abstract,synchronized。前三种说明访问权限,public(所有类都可以访问),private(只能被本类访问),protected(允许被相同包的类访问),final(修饰最终方法,被修饰过的方法不允许被子类重载),static(修饰类方法,可直接通过类名调用且不允许重载),abstract(修饰抽象方法,只有方法声明,无方法体),synchronized(修饰用于线程同步)。<br>返回类型:可以是基本数据类型或者自定义类,如不需要返回值,设置其为void即可。<br>方法名与参数列表:符合命名规范即可<br>方法体:定义功能,方法体内可定义局部变量,作用域仅在方法体内。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>当用new一个新对象时,构造方法立即执行,构造方法名必须与类名相同。    </p>
<pre><code>public 类名(参数列表){}
</code></pre><p>定义构造方法注意:<br>    1.无返回类型(包括void),修饰符只能为public,private,protected中的任一个<br>    2.不能从父类继承<br>    3.系统默认提供无参构造方法<br>    4.构造方法不能通过方法名直接调用,只能通过new运算符调用。<br>    5.构造方法可以调用当前类(this)或父类的构造方法(super),<code>必须在第一行调用</code>。</p>
<h4 id="类使用"><a href="#类使用" class="headerlink" title="类使用"></a>类使用</h4><h5 id="类声明-创建"><a href="#类声明-创建" class="headerlink" title="类声明,创建"></a>类声明,创建</h5><p>类是对象模板,只有实例化后才可使用。<br><code>Circle c1</code> //声明<br><code>Circle c1 = new Circle()</code> //new用于创建一个对象的实例并返回对象的引用。<br><code>c1.a(1,2)</code> //调用成员方法a(),参数为1,2    </p>
<h5 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h5><p>对象不再使用后,Java系统通过垃圾回收器GC,周期性地释放内存,回收工作由Java系统自动完成,减少程序员的工作量。    </p>
<h4 id="this的使用"><a href="#this的使用" class="headerlink" title="this的使用"></a>this的使用</h4><p>关键字this表示实例对象指向自己的引用,可出现再实例方法与构造方法中,不能出现在由static修饰的类方法(静态方法)。    </p>
<h5 id="实例方法和构造方法中使用this"><a href="#实例方法和构造方法中使用this" class="headerlink" title="实例方法和构造方法中使用this"></a>实例方法和构造方法中使用this</h5><p>this(color),this.h=h,this.cry() //调用本实例类的构造方法,成员变量与成员方法。</p>
<h5 id="区分成员变量与局部变量"><a href="#区分成员变量与局部变量" class="headerlink" title="区分成员变量与局部变量"></a>区分成员变量与局部变量</h5><p>成员变量在整个类中都有效,局部变量仅在方法体内有效。<code>在方法体内声明的变量与方法传入的参数称为局部变量。</code>如果在实例方法中的局部变量名字与成员变量名字相同,这个成员变量在这个方法内就会暂时失效(强龙压不过地头蛇),如果确实想引用成员变量,使用this关键字即可。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-08.11.30.00-image.png" alt="2019-01-08.11.30.00-image.png"></p>
<h5 id="返回实例对象本身的引用"><a href="#返回实例对象本身的引用" class="headerlink" title="返回实例对象本身的引用"></a>返回实例对象本身的引用</h5><p>this还可以作为成员方法的return语句的参数,用来返回对象本身的引用。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-08.11.35.39-image.png" alt="2019-01-08.11.35.39-image.png"><br>返回长大后的Dog类。    </p>
<h5 id="使用this调用类的其他构造方法"><a href="#使用this调用类的其他构造方法" class="headerlink" title="使用this调用类的其他构造方法"></a>使用this调用类的其他构造方法</h5><p>使用this调用其他类的构造方法(this(a)),至于系统具体会调用哪个方法,根据参数的类型与个数决定。    </p>
<h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><p>OOP是Java的重点,OOP的三个特性</p>
<pre><code>封装:用一个类将实现与使用分开,只保留接口与外部进行联系
继承:字类自动继承其父类的属性与方法,并且可以添加新的属性与方法
多态:虽然多个子类都有一个共同的方法,但是子类实例化后都可以获得完全不同的结果
</code></pre><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code>面向对象程序设计的一个特性就是封装,将实体特征的属性隐藏起来,对象与外界仅通过公共方法进行交流,提高程序的可靠性,安全性与可维护性。数据的隐藏与开放对外的接口可通过访问权限控制符实现,Java提供了public,protected,private和默认4种访问控制符
public
    可被同一个或不同包的任何类访问通常只将公共类或公共接口的成员方法组指定为public
protected
    可用来修饰类的成员变量与方法,可被本类、本包的其他类访问,也可被其他包的字类继承
默认
    用户没有指定,就会自动使用默认权限,只能被本类或其他一个包中的其他类、接口、成员方法引用,也被称为包权限
pricate
    声明类的私有成员,被private修饰的成员变量和方法只能被该类自身所访问或修改,而不能被其他类(包括该类的子类)来获取或引用    
getInfo和setInfo    
    为了系统设计的安全性考虑,一般将类的成员变量定义为private形式,而将类的成员方法定义为public对外公开。类中提供变量对应的get方法(得到private成员变量)和set方法(修改private成员变量),达到其他类可以操作该类的private成员变量
</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><pre><code>研究生是一类特殊的学生,研究生类在保留学生类的基本属性和行为的基础上,可以增加新的属性与行为,也可以修改学生的属性和行为。这里学生就是研究生的父类(或超类),研究生为学生的子类。父类派生子类,子类继承父类,子类也可以派生其他类,这样就构成了类的层次结构。继承机制可提高系统的可扩展性与可维护性。
</code></pre><h5 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h5><pre><code>class Graduate extends Student{    
使用extends关键字实现类的继承,如果类定义没有使用extends关键字,则默认该类的父类为java.lang.Object,Object类是Java预定义的所有类的父类，包含所有的Java使用的公共属性其中定义的属性与方法均可被任何类使用 继承或修改。Java只能继承一个父类(单继承),子类继承父类的变量和方法,可以增加父类没有的变量或方法,也可以修改已有的变量或方法。
用Eclipse打开Java文件,连按两次Ctrl+o,可得到当前类与父类的属性,方法:    
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2019-01-07.19.45.34-image.png" alt="2019-01-07.19.45.34-image.png"><br>    <code>子类可以继承父类的成员属性与方法,但受访问权限的限制。如父类与子类在不同的包中定义,子类只能public与protected权限的变量,如果父类与子类在一个包中定义,子类能访问父类的public,protected与默认权限的变量,如果要访问private类型的变量,只能使用其父类的set与get方法访问。</code></p>
<h5 id="super的使用"><a href="#super的使用" class="headerlink" title="super的使用"></a>super的使用</h5><p>子类在继承父类的属性与方法时,可能会出现变量隐藏(变量的名相同,类型不要求)或方法覆盖(子类与父类的方法名,返回类型,入口参数的数目,类型,顺序相同,只是实现的功能不同)。此时父类的变量与方法就会被覆盖,如需要调用父类被隐藏的属性与方法,可通过<code>super</code>关键字调用<br>eg:</p>
<pre><code>public class Student{
  public static void main(String[] args) {
      AClass aClass = new AClass();
      BClass bClass = new BClass();

      aClass.p1();
      bClass.p1();
      }
}
public class AClass {
    int a;
    float a1;

    public AClass() {
        a = 50;
        a1 = 99.99f;
    }
    public void p1() {
        System.out.println(&quot;method A&quot;);
        System.out.println(&quot;a=&quot;+a);
        }
}
public class BClass extends AClass{
    int a;    //与父类的成员变量名相同,属于变量隐藏
    public BClass() {
      a = 10;
      a1 = 123.6f;
  }
    public void p1() {    //与父类的成员方法相同,属于方法覆盖现象
      System.out.println(&quot;method b&quot;);
      System.out.println(&quot;a=&quot;+a);    //这里的a是bClass的变量a
      super.p1();     //通过super调用被覆盖的父类成员方法
      System.out.println(&quot;super.a=&quot;+super.a);    //通过super访问被隐藏的父类成员变量
  }
}
</code></pre><p>   运行结果:</p>
<pre><code>   method A
a=50
method b
a=10
method A
a=50
super.a=50
</code></pre><p><code>super</code>除上述的2种作用,还可显示调用父类构造方法。<br>    实例方法与构造方法的super关键字都指向父类,实例方法中的super关键字是去调用父类中的某个方法,而构造方法中使用是去调用父类的构造方法。</p>
<h5 id="子类对象的构造"><a href="#子类对象的构造" class="headerlink" title="子类对象的构造"></a>子类对象的构造</h5><p>当子类创建时,系统默认自动(显式或隐式)调用父类的无参构造方法。需要注意的是,如果父类定义了有参数的构造方法,系统就不会再提供默认的无参构造方法,此时子类一定要避免使用父类的无参构造方法。<br>调用构造方法时,遵循的规则:<br>    1.创建对象时,调用该类的父类构造方法(将第一条写为super语句即可),super可以调用父类的任何一个带参数或不带参数的构造方法。<br>    2.如果类的构造方法中第一条语句没有使用super,则编译器也会默认用super()调用父类的无参构造方法。<br>    3.用this()调用本类的构造方法。<br>    4.如父类定义了有参构造方法,子类的构造方法一定要super显式调用父类的有参构造方法。<br>所以说,在定义一个类时,如果没有特殊需求,尽量在类中定义一个无参的构造方法,防止被继承时出现错误。</p>
<h5 id="对象类型转换"><a href="#对象类型转换" class="headerlink" title="对象类型转换"></a>对象类型转换</h5><pre><code>如同数据类型的转换,对象也可以在一定范围内进行转换,由于子类具有父类的方法与属性,因此子类对象可以向上转化为父类对象(上转型对象)
 SuperClass spc = new SubClass(); //SubClass是SuperClass的子类,父类引用指向对象实例
SubClass sbc = new SuperClass(); //错误 因为父类不一定含有子类的属性与方法
</code></pre><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><pre><code>方法重载与方法覆盖是是实现继承的基本手段。重载只是方法的名字相同,而参数(参数类型,参数个数),方法覆盖是指子类的方法名与父类的方法名完全相同(参数类型,个数,返回值类型),即在子类重写了父类的方法,这样就能使用相同的方法名实现不同的功能。

class Animal{
    public void enjoy(){

    }
}
class Cat extends Animal{
    public void enjoy(){
        System.out.println(&quot;Cat....&quot;);
    }
}
class Dog extends Animal{
    public void enjoy(){
        System.out.println(&quot;Dog....&quot;);
    }
}
public class Testpolymoph{

  public static void main(String[] args){
      Testpolymoph test = new Testpolymoph();
      Cat cat = new Cat();
      Dog dog = new Dog();
      test.myEnjoy(cat);
      test.myEnjoy(dog);
  }

  public void myEnjoy(Animal pet){
      pet.enjoy();
  }

}
</code></pre><p>运行结果:</p>
<pre><code>用一个enjoy()方法就实现了不同的对象所需的操作,即不修改程序代码就可以改变程序运行时所绑定的具体代码,让程序可以选择多个运行状态,这就是实现了多态型。(像是定义一个方法,传入的参数是不同的对象,然后执行不同对象相应的相同名的成员方法)
</code></pre><h3 id="非访问控制符"><a href="#非访问控制符" class="headerlink" title="非访问控制符"></a>非访问控制符</h3><pre><code>类定义的时候除了可以使用public,private,protected和默认来设置成员变量与成员方法的访问权限,还可以使用static,final,abstract来说明其特性。 
</code></pre><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><h5 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h5><pre><code>被static修饰的成员变量或成员方法称为类变量(静态变量)和类方法(静态方法)。没有被static修饰的称为实例变量和实例方法。
实例变量依附于对象,不同实例变量占用不同的内存空间。类变量依附于类,占用公共空间,该类的每个实例对象共享同一变量的存储空间,每个对象对类变量的修改都会影响其他实例对象。
public class Student{
    public static void main(String[] args) {
      System.out.println(&quot;现在的人数:&quot;+AClass.personnum);
      AClass aClass1 = new AClass();
      AClass aClass2 = new AClass();
      System.out.println(&quot;现在的人数:&quot;+AClass.personnum);
      System.out.println(&quot;现在的人数:&quot;+aClass2.personnum);
    }
}
public class AClass {
  static int personnum = 100;

  public AClass() {
      personnum ++;
  }
}
</code></pre><p>输出结果:<br>    现在的人数:100<br>    现在的人数:102<br>    现在的人数:102<br>每次创建AClass的实例时,调用其构造方法使其personnum加1,因此personnum可以记录所产生的实例对象的个数。可通过类名(AClass.personnum)实例对象名(aClass2.personnum)访问变量。且每个对象对静态变量personnum的修改都会影响其他实例对象。</p>
<h5 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h5><pre><code>类方法的本质是该方法属于整个类,而不是某个实例,可以不创建实例,直接通过类名调用(AClass.add(1,1))。

类方法的特点：
    1.可直接调用,不需要创建实例对象,例如,Java Application的入口main()方法被声明为static类方法,不需要创建任何实例对象即可调用。
    2.类方法属于整个类,被调用时可能还没有创建任何实例对象实例,因此,类方法只能访问类变量,而不能直接访问实例变量或实例方法。
    3.类方法中不能使用this关键字,因为静态方法不属于任何一个实例。
</code></pre><p>eg:</p>
<pre><code>public class Student{
    public static void main(String[] args) {
        System.out.println(&quot;sum&quot;+AClass.sum(3, 1));
        //System.out.println(&quot;sub&quot;+AClass.sub(3,1));  会报错,不能直接调用实例方法
    }
}
public class AClass {
  //static int personnum = 100;
  int z = 3;

  public static int sum(int a,int b) {
      //return z; 会报错,因为类方法中只能使用类变量,不能使用实例变量。
      return a+b;
  }

  public int sub(int a,int b) {
      return a-b;
  }

}
</code></pre><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><pre><code>final可以修饰类,成员变量,成员方法,被final修饰过类,变量,方法的均不允许继承或覆盖。
</code></pre><h5 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h5><pre><code>被final修饰过的类称为最终类,它不可能有子类。
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-08.09.58.52-image.png" alt="2019-01-08.09.58.52-image.png"></p>
<h5 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h5><blockquote>
<p>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了    </p>
</blockquote>
<p>因此,只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final。    </p>
<h5 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h5><h6 id="final修饰普通变量"><a href="#final修饰普通变量" class="headerlink" title="final修饰普通变量"></a>final修饰普通变量</h6><pre><code>被final修饰的变量称为常量,不允许修改
final int a = 3;a = 2;  //编译器会报错
</code></pre><h5 id="final修饰引用变量"><a href="#final修饰引用变量" class="headerlink" title="final修饰引用变量"></a>final修饰引用变量</h5><pre><code>当使用final修饰引用类型变量时，它仅仅保证他的地址不变，即一直引用同一个对象，但这个对象完全可以发生改变
</code></pre><h4 id="其他修饰符"><a href="#其他修饰符" class="headerlink" title="其他修饰符"></a>其他修饰符</h4><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><pre><code>主要用于多线程程序的协调和同步,如果某个方法被该关键字修饰,意味着不管哪个县城运行到这个方法时,都要检查有没有线程正在用这个方法,若有,则要等到正在使用的线程结束后,再运行此线程,如无,则直接运行。
</code></pre><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>先了解以下抽象方法，抽象方法是一种特殊的方法:他只有声明,而没有具体的实现,由它的子类去实现。同时抽象类提供了继承的概念,它的出发点是为了继承,否则它也没有存在的意义<br>抽象方法的声明格式:<code>abstract void fun();</code>如果一个类含有抽象方法,则称这个类为抽象类。<br>定义:如果一个类中没有包含足够的信息来描述具体的对象,<br>格式:<code>abstract class 类名 extends 父类 implements 接口名</code><br>eg:</p>
<pre><code>public abstract class Animal {
    public abstract void cry();
}

public class Cat extends Animal{

    @Override
    public void cry() {
        System.out.println(&quot;喵喵&quot;);
    }
}

public class Dog extends Animal{

    @Override
    public void cry() {
        System.out.println(&quot;汪汪&quot;);
    }

}

public class Test {

    public static void main(String[] args) {
        Animal a1 = new Cat();
        Animal a2 = new Dog();

        a1.cry();
        a2.cry();
    }
</code></pre><p>结果:<br>    喵喵喵<br>    汪汪汪<br>代码定义了一个抽象类Animal,必须提供抽象方法cry(),猫,狗都是动物的子类,由于cry为抽象方法,所以Cat,Dog必须实现cry</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口在Java中是一个抽象集合,是抽象方法的集合。用来建立类与类之间的协议,它所提供的仅仅是一种协议,没有具体的实现,实现该接口的实现类必须实现该接口的所有方法,通过使用implements,表示遵循某个特定的接口。<br>接口是抽象类的延伸,一个类可以实现多个接口,弥补了类不能多继承的缺陷,一般抽象类与接口配合使用,既可以保证数据安全性又可以实现多继承。<br>注意:接口的所有方法的访问权限被系统自动定义为public,实现接口的非抽象类必须实现该接口的所有方法    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/09/java_Servlet基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/09/java_Servlet基础/" itemprop="url">基础知识 | Java_Servlet 基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-09T08:15:41+08:00">
                2018-12-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近在学习Java,完成学校给布置的Java_web实验,写一个简单论坛,实验内容还需要完善,简单记录下所学内容。</p>
</blockquote>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><blockquote>
<p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。使用 Servlet,可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p>
</blockquote>
<h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-12-03.17.54.18-image.png" alt="2018-12-03.17.54.18-image.png"></p>
<p>1.初始化阶段            </p>
<blockquote>
<p>当客户端向Servlet容器发出请求要求访问Servlet时,Servlet容器首先会解析请求,检查内存是否已经存在该Servlet对象,如果有则直接使用该Servlet对象,如果没有就创建Servlet对象,然后通过调用init()方法实现Servlet的初始化工作,需要注意的是,在Servlet的整个生命周期内,它的init()方法只被调用一次。</p>
</blockquote>
<p>2.运行阶段</p>
<blockquote>
<p>这是生命周期最核心的阶段,Servlet容器为这个请求创建代表Http请求的ServletRequest对象和代表Http响应的ServletResponse对象,然后将他们作为参数传递给Servlet的service()方法。service()方法从ServletRequest对象中获取客户端传输过来的信息并处理该请求,通过ServletResponse对象生成响应结果。在Servlet的生命周期内,每收到一次访问请求,Servlet容器都会调用一次Servlet的service()方法,并且创建新的ServletRequest和ServletResponse对象,service()方法在Servlet的生命周期内会被调用多次。</p>
</blockquote>
<p>3.销毁阶段:</p>
<blockquote>
<p>当服务器关闭或Web应用被移除容器后,Servlet会随着Web应用的销毁而销毁,在销毁Servlet之前,Servlet容器会调用Servlet的destroy()方法,以便让Servlet对象释放他所占用的资源。在Servlet的整个生命周期中,destory()方法也只被调用一次。需要注意的是,Servlet对象一旦创建就会驻留在内存中等待客户端的访问,直到服务器关闭,或Web应用被移除容器时,Servlet对象才会销毁。</p>
</blockquote>
<hr>
<p>配置Servlet:</p>
<pre><code>1.注解配置:@WebServlet(&quot;/RequestMethodServlet&quot;)  //自动创建注解,不用手动配置  现在的主流      
2.web.xml 配置
</code></pre><h3 id="运行Servlet"><a href="#运行Servlet" class="headerlink" title="运行Servlet:"></a>运行Servlet:</h3><p>由于<code>HttpServlet</code>类在重写的<code>service()</code>方法中,为每一种HTTP请求方式都定义了<code>doXXX()</code>方法,因此,当定义的类继承<code>HttpServlet</code>时,只需要根据请求方式,重写对应的<code>doxxx()</code>方法即可,而不需要重写<code>service()</code>方法:<br>重写doget与dopost方法:</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // TODO Auto-generated method stub
    PrintWriter out = response.getWriter();
    out.write(&quot;this is get method&quot;);

}

protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // TODO Auto-generated method stub
    PrintWriter out = response.getWriter();
    out.write(&quot;this is post method&quot;);
}
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-12-03.17.31.50-image.png" alt="2018-12-03.17.31.50-image.png"><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-12-03.17.31.05-image.png" alt="2018-12-03.17.31.05-image.png"></p>
<p>如果GET与POST请求的处理方式一致,则可以在<code>doPost()</code>方法中直接调用<code>doGet()</code>方法：<code>this.doGet(request, response);</code>即可。    </p>
<h3 id="ServletContext与ServletConfig接口"><a href="#ServletContext与ServletConfig接口" class="headerlink" title="ServletContext与ServletConfig接口"></a>ServletContext与ServletConfig接口</h3><h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><h5 id="1-获取WEB应用程序的初始化参数"><a href="#1-获取WEB应用程序的初始化参数" class="headerlink" title="1.获取WEB应用程序的初始化参数"></a>1.获取WEB应用程序的初始化参数</h5><p>在web.xml文件中,不仅可以配置Servlet的初始化信息,还可以配置WEB应用程序的初始化参数,web应用程序的初始化参数:</p>
<pre><code>#web.xml
&lt;context-param&gt;
      &lt;param-name&gt;companyname&lt;/param-name&gt;
      &lt;param-value&gt;itcast&lt;/param-value&gt;    
  &lt;/context-param&gt;
  &lt;context-param&gt;
      &lt;param-name&gt;address&lt;/param-name&gt;
      &lt;param-value&gt;beijing&lt;/param-value&gt;
  &lt;/context-param&gt;
</code></pre><p>Servlet中读取该配置信息:</p>
<pre><code>PrintWriter out = response.getWriter();
ServletContext context = (ServletContext) this.getServletContext();  //得到ServletContext对象
Enumeration&lt;String&gt; paramNames = context.getInitParameterNames();     //得到可遍历的数组集合Enumeration对象
out.println(&quot;there are param-name and param-value:&quot;);
while(paramNames.hasMoreElements()) {                      //hasMoreElement方法,是否包含元素,有返回true
    String name = paramNames.nextElement();
    String value = context.getInitParameter(name);
    out.println(name+&quot;:&quot;+value);

}
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-07.08.58.33-image.png" alt="2018-12-07.08.58.33-image.png"></p>
<h6 id="2-实现多个Servlet的对象共享数据"><a href="#2-实现多个Servlet的对象共享数据" class="headerlink" title="2.实现多个Servlet的对象共享数据"></a>2.实现多个Servlet的对象共享数据</h6><p>由于一个WEB应用中的所有Servlet共享同一个ServletContext对象,因此,ServletContext对象的域属性可以被该WEB应用中的所有Servlet访问</p>
<pre><code>#TestServlet04
javax.servlet.ServletContext context = this.getServletContext();
context.setAttribute(&quot;data&quot;, &quot;this servlet save data&quot;);


#TestServlet05
PrintWriter out = response.getWriter();
javax.servlet.ServletContext context = this.getServletContext();
String data = (String) context.getAttribute(&quot;data&quot;);
out.println(data);
</code></pre><p>然后启动服务器,先访问TestServlet04将数据存入ServletContext对象,然后访问TestServlet05,即可得到ServletContext对象的data属性值<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-07.09.15.29-image.png" alt="2018-12-07.09.15.29-image.png"><br>说明ServletContext对象中的数据可以被多个Servlet访问。</p>
<h5 id="3-读取WEB应用下的资源文件"><a href="#3-读取WEB应用下的资源文件" class="headerlink" title="3.读取WEB应用下的资源文件"></a>3.读取WEB应用下的资源文件</h5><p>在WebContent下面新建itcast.properties文件,写入:</p>
<pre><code>Company = itcast
Address = Beijing
</code></pre><p>我们在Servlet中读取(相对路径):</p>
<pre><code>#TestServlet06:
ServletContext context = this.getServletContext();
PrintWriter out = response.getWriter();

//获取相对路径中的输入流对象
InputStream in = context.getResourceAsStream(&quot;/itcast.properties&quot;);
Properties pros = new Properties();
pros.load(in);
out.println(&quot;Company:&quot;+pros.getProperty(&quot;Company&quot;));
out.println(&quot;address:&quot;+pros.getProperty(&quot;Address&quot;));
</code></pre><p>根据绝对路径获取WEB应用的参数:</p>
<pre><code>response.setContentType(&quot;text/html;charset=utf-8&quot;);
ServletContext context = this.getServletContext();
PrintWriter out = response.getWriter();

String path = context.getRealPath(&quot;/itcast.properties&quot;); //得到绝对路径
out.println(&quot;path:&quot;+path);
FileInputStream in = new FileInputStream(path);

Properties pros = new Properties();
pros.load(in);
out.println(&quot;Company:&quot;+pros.getProperty(&quot;Company&quot;));
out.println(&quot;address:&quot;+pros.getProperty(&quot;Address&quot;));
</code></pre><p>访问TestServlet06,可看到已经成功取出数据<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-07.10.21.31-image.png" alt="2018-12-07.10.21.31-image.png"></p>
<p>ServletConfig   </p>
<p>#####<br>当Tomcat初始化一个Servlet参数时,会将Servlet的配置信息封装到一个ServletConfig对象中,通过调用init(ServletConfig config)方法将ServletConfig对象传递给Servlet。    </p>
<h3 id="HttpServletRequest与HttpServletResponse对象"><a href="#HttpServletRequest与HttpServletResponse对象" class="headerlink" title="HttpServletRequest与HttpServletResponse对象"></a>HttpServletRequest与HttpServletResponse对象</h3><blockquote>
<p>Servlet 最主要的功能就是处理客户端请求,并向客户端做出响应。为此,针对Servlet的每次请求,Web服务器在调用service()之前,都会创建2个对象.分别是HttpServlet与HttpServletResponse。</p>
</blockquote>
<h4 id="HttpServletRequest对象"><a href="#HttpServletRequest对象" class="headerlink" title="HttpServletRequest对象"></a>HttpServletRequest对象</h4><h5 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数:"></a>获取请求参数:</h5><pre><code>获取前台form表单传输过来的参数信息:
String username = request.getparameter(&quot;username&quot;);
String pwd = request.getparameter(&quot;password&quot;);

String[] hobbys = request.getparameter(&quot;hobby&quot;);
for(int i=0;i&lt;hobbys.length();i++){
    out.print(hobbys[i]);    
}

Enumeration names = request.getParameterNames()   //返回所有参数名    
Map&lt;String,String[]&gt; map=request.getParameterMap();   //将请求参数与值放进一个Map对象中返回

Map&lt;String,String[]&gt; map=request.getParameterMap();  
     //遍历  
      for(Iterator iter=map.entrySet().iterator();iter.hasNext();){  
            Map.Entry element=(Map.Entry)iter.next();  
            //key值  
            Object strKey = element.getKey();  
            //value,数组形式  
          String[] value=(String[])element.getValue();  

          out.print(strKey.toString() +&quot;=&quot;);  
         for(int i=0;i&lt;value.length;i++){  
             out.print(value[i]+&quot;,&quot;);  
         }
</code></pre><h5 id="获取请求消息头信息"><a href="#获取请求消息头信息" class="headerlink" title="获取请求消息头信息:"></a>获取请求消息头信息:</h5><pre><code>PrintWriter out = response.getWriter();

Enumeration headerNames = request.getHeaderNames();         

while(headerNames.hasMoreElements()) {
    String paramName = (String)headerNames.nextElement();
    String paramValue = request.getHeader(paramName);
    out.print(paramName+&quot;:&quot;+paramValue);
    out.print(&quot;&lt;br /&gt;&quot;);

}
</code></pre><p>先使用HttpServletRequest的getHeaderName()读取HTTP头信息,该方法返回一个枚举,包含与当前的HTTP请求相关的头信息,我们循环枚举,使用hasMoreElements()方法遍历即可。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-09.17.08.14-image.png" alt="2018-12-09.17.08.14-image.png"></p>
<h5 id="通过Request对象传递数据"><a href="#通过Request对象传递数据" class="headerlink" title="通过Request对象传递数据"></a>通过Request对象传递数据</h5><blockquote>
<p>Request对象不仅可以获取一系列数据,还可以使用属性传递数据,在ServletRequest接口中,定义了一系列操作属性的方法。</p>
</blockquote>
<p><code>request.setAttribute()</code>将一个对象与一个name关联存入<code>ServletRequest()</code>对象中,如果已经存在相同名字,则会删除原来的属性.如果设置对象值为<code>null</code>,则相当于<code>removeAttribute()</code></p>
<pre><code>Servlet：
request.setAttribute(&quot;list&quot;, list1);

Jsp:
&lt;jsp:include page=&apos;&lt;%=&quot;/ShowAllUser&quot; %&gt;&apos;&gt;&lt;/jsp:include&gt;
${list}  即可在Jsp中接收list

request.getAttribute(String name)  返回ServletRequest对象指定name的value    
request.removeAttribute(String name)  删除ServletRequest对象指定name的value    
request.getAttributeNames()    

    request.setAttribute(&quot;name&quot;, &quot;zhangsan&quot;);
    request.setAttribute(&quot;pwd&quot;, &quot;123&quot;);
    Enumeration aa = request.getAttributeNames();

    while(aa.hasMoreElements()) {
        String name = (String) aa.nextElement();  //name
        Object str = request.getAttribute(name);  //对象
        out.print(name+&quot;:&quot;+str+&quot;&lt;br /&gt;&quot;);

    }
</code></pre><h5 id="RequestDispatcher接口"><a href="#RequestDispatcher接口" class="headerlink" title="RequestDispatcher接口"></a>RequestDispatcher接口</h5><p>当一个Web资源收到客户端的请求时,如果希望服务器通知另一个资源区处理请求,除了使用<code>response.sendRedirect()</code>,还可以使用RequestDispatcher接口实例化对象区实现。    </p>
<h5 id="请求转发-forward"><a href="#请求转发-forward" class="headerlink" title="请求转发 forward()"></a>请求转发 forward()</h5><blockquote>
<p>请求转发完给其他资源,其他WEB资源处理完请求后,直接将响应结果返回给客户端。(该方法需在提交给客户端之前调用,否则会出现错误)        </p>
</blockquote>
<pre><code>RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/TestServlet03&quot;);
dispatcher.forward(request, response);   //返回TestServlet03的输出信息
</code></pre><h5 id="请求包含-incule"><a href="#请求包含-incule" class="headerlink" title="请求包含 incule()"></a>请求包含 incule()</h5><blockquote>
<p>请求包含指的是使用include()方法将Servlet请求转发到其他Web资源进行处理,与请求转发不同,Servlet与WEB资源都返回消息给客户端（关于编码,需在Servlet设置）</p>
</blockquote>
<pre><code>RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/TestServlet03&quot;);
dispatcher.include(request, response);   //返回TestServlet02与TestServlet03的输出信息
</code></pre><h4 id="HttpServletResponse对象"><a href="#HttpServletResponse对象" class="headerlink" title="HttpServletResponse对象"></a>HttpServletResponse对象</h4><p>a.setStatus(int status)方法    设置返回状态码(默认为200)<br>b.sendError(int sc)方法    用于发送表示错误信息的状态码。</p>
<pre><code>public void sendError(int code) throws java.io.IOException  //只返回状态码
public void sendError(int code,String message) throws java.io.IOException //返回加提示信息
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-09.16.50.22-image.png" alt="2018-12-09.16.50.22-image.png"><br>c.发送响应消息头相关的方法:</p>
<pre><code>addHeader(String name,String value)   //增加同名响应头
setHeader(String name,String value)   //覆盖同名响应头

addIntHeader(String name,int value)   //设置valu值为int类型的参数,避免使用addHeader需要转换String的麻烦
setIntHeader(String name,int value)    

setContentLength(int len)   //设置响应消息的实体内容的大小
setContentType(String type)  //设置Servlet输出内容的MIME类型

setCharacterEncoding(String charset)   //设置输出内容使用的字符编码


eg:response.setHeader(&quot;refresh&quot;,&quot;3;URL=http://www.baidu.com&quot;);  //定时刷新并跳转
</code></pre><p>d.发送响应消息体相关的方法:</p>
<pre><code>ServletOutputStream out = response.getOutputStream(); //输出字节数组中的二进制数据
out.write(data.getBytes());               //使用当前文件的编码格式输出

response.getWriter().write(data);   
</code></pre><p>两者互相排斥,不可同时使用。(设计原因) 只能输出字节流或字符流。</p>
<p>e.实现请求重定向:</p>
<pre><code>response.sendRedirect(&quot;login.html&quot;);   //重定向到login.html
</code></pre><h4 id="解决乱码问题"><a href="#解决乱码问题" class="headerlink" title="解决乱码问题"></a>解决乱码问题</h4><pre><code>request.setCharacterEncoding(&quot;UTF-8&quot;);   //使接收的参数值为utf-8格式
response.setContentType(&quot;text/html;charset=utf-8&quot;);  //返回的信息为utf-8
PrintWriter out = response.getWriter();   //在response.getWriter()前设置编码
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/19/java_web_JSP技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/java_web_JSP技术/" itemprop="url">基础知识 | JSP基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-19T08:15:41+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JSP技术"><a href="#JSP技术" class="headerlink" title="JSP技术"></a>JSP技术</h2><h3 id="JSP基本语法"><a href="#JSP基本语法" class="headerlink" title="JSP基本语法"></a>JSP基本语法</h3><blockquote>
<p>JSP = HTML + Java代码 + JSP标签<br>  Java代码:Java脚本 声明 表达式<br>  JSP标签:指令 动作 注释    </p>
</blockquote>
<h4 id="JSP脚本元素"><a href="#JSP脚本元素" class="headerlink" title="JSP脚本元素"></a>JSP脚本元素</h4><p>脚本元素主要包含3种类型:</p>
<blockquote>
<p>脚本程序:&lt;% %&gt;<br>脚本程序可以包含任意量的Java语句、变量、方法或表达式(局部变量 用完即销毁 刷新)<br>声明语句:&lt;%! %&gt;<br>一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。在JSP文件中，您必须先声明这些变量和方法然后才能使用它们(类变量 存在内存)<br>表达式:&lt;%= %&gt;<br>一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。无引号</p>
</blockquote>
<p>例子:</p>
<pre><code>#
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;ISO-8859-1&quot;&gt;
&lt;title&gt;JSP title&lt;/title&gt;
&lt;/head&gt;
&lt;%!//声明语句 定义2个变量及一个print方法
    int a=1,b=2;
%&gt;
&lt;%! public String print(){
    String str = &quot;itcast&quot;;
    return str;
} %&gt;
&lt;body&gt;
&lt;% 
    out.print(a + b); //JSP脚本元素 输出a+b
%&gt;
&lt;br /&gt;
&lt;% 
    out.print(print()); //运行print()函数
%&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>总之,<code>&lt;%! %&gt;</code>是用来定义成员变量属性及方法的,<code>&lt;% %&gt;</code>主要用来输出内容的,因此,如果涉及了成员变量的操作,就应该使用<code>&lt;%! %&gt;</code>,而如果涉及到了输出内容,就应该使用<code>&lt;% %&gt;</code></p>
<p>JSP表达式,将刚才代码的<code>body</code>段改为如下即可:</p>
<pre><code>&lt;body&gt;
&lt;%= a+b %&gt;
&lt;br /&gt;
&lt;%= print() %&gt;
&lt;/body&gt;
</code></pre><p><code>&lt;%= %&gt;</code>之间只能插入表达式,不能插入语句。且最后无分号(<code>;</code>)</p>
<p>JSP注释(JSP的注释不会发送到前端)</p>
<pre><code>&lt;%--this is notes--%&gt;
</code></pre><h4 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h4><p>page指令:</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
//contentType是给浏览器看的,使其按照text/html进行解释  pageEncoding是给servlet看的
还有属性import=&quot;&quot; session=&quot;true&quot; errorPage=&quot;&quot;(错误页面) iserrorpage=&quot;true&quot;(本页面就是错误页面),只有import可以出现多次 其他都只能出现一次
</code></pre><p>include指令:</p>
<pre><code>&lt;%@ include file=&quot;date.jsp&quot;  %&gt; //引入date.jsp 将其代码合并到demo.jsp中

#date.jsp
&lt;% out.println(new java.util.Date().toLocaleString()); %&gt;

//文件路径一般用相对路径,开发后期移动方便   绝对路径:/开头
</code></pre><p>taglib指令：引入标签库的定义,可以是自定义标签</p>
<h4 id="JSP隐式对象"><a href="#JSP隐式对象" class="headerlink" title="JSP隐式对象"></a>JSP隐式对象</h4><p>1.out对象    </p>
<pre><code>&lt;%
    out.println(&quot;first line&lt;br /&gt;&quot;);  //out.print(&quot;first line&lt;br /&gt;&quot;);也可以
    out.println(out.getBufferSize()); //输出缓冲区大小
    response.getWriter().println(&quot;second line&lt;br /&gt;&quot;);

%&gt;
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-08.21.44.30-image.png" alt="2018-11-08.21.44.30-image.png"></p>
<p>我们可发现<code>out.println()</code>在前面,但它的输出内容却在后面。因为out对象通过print语句写入数据后,直到整个JSP页面结束,才会写入缓冲区输出,而<code>response.getWrite.println()</code>则是直接把内容写入<code>Servlet</code>引擎提供的缓冲区中。<code>Servlet</code>引擎按照缓冲区的数据存放顺序输出内容。<br>有时候我们希望<code>out</code>对象可以直接将数据写入缓冲区进行输出,我们可通过<code>page</code>的<code>buffer</code>属性来实现</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; buffer=&quot;0kb&quot;%&gt;
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-08.21.51.50-image.png" alt="2018-11-08.21.51.50-image.png"></p>
<p>这样就直接写入了。</p>
<p>2.pageContext</p>
<p>下面的几种是隐式对象,同时也是页面间数据共享范围<br>            范围                         有效期<br>    3.page: 当前页面                    当前页面<br>    4.request: 两两页面之间              当前请求站点<br>    5.session: 所有页面都共享 单用户      浏览器启动-浏览器关闭<br>    6.application: 所有页面,所有用户     服务器不关闭</p>
<pre><code>&lt;% session.setAttribute(&quot;str&quot;, &quot;hello&quot;); %&gt;
&lt;% out.println(session.getAttribute(&quot;str&quot;)); %&gt;   
先访问set的文件,然后str存入session中,再访问get的页面,取出str值。
</code></pre><p>7.exception对象</p>
<pre><code>#exception.jsp
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; errorPage=&quot;error.jsp&quot;%&gt;
//errorPage表明错误文件
...
&lt;body&gt;
&lt;% int a=3;
   int b=0; 
%&gt;
&lt;%= (a/b) %&gt;
&lt;/body&gt;

#error.jsp
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;true&quot;%&gt;
//isErrorPage表明当前页面为错误跳转页面
&lt;body&gt;
this is error;
&lt;%= exception.getMessage() %&gt;&lt;br /&gt;
&lt;/body&gt;
</code></pre><p>说明exception.jsp发生错误时,会自动调用error.jsp页面进行处理</p>
<p>还有两种分别为config与response对象<br>其他参考<a href="http://www.runoob.com/jsp/jsp-syntax.html" target="_blank" rel="noopener">JSP隐式对象</a></p>
<h4 id="JSP行为"><a href="#JSP行为" class="headerlink" title="JSP行为"></a>JSP行为</h4><p><strong><a href="jsp:include" target="_blank" rel="noopener">jsp:include</a></strong>:将其他资源的输出内容插入到当前页面的输出内容中。<br>元素语法:<code>&lt;jsp:include page=&quot;文件路径&quot; flush=&quot;false|true&quot;&gt;</code></p>
<pre><code>#test_include.jsp内容:
&lt;body&gt;
test_include的中文
&lt;br /&gt;
&lt;jsp:include page=&quot;include.jsp&quot; flush=&quot;true&quot; /&gt;
&lt;body&gt;

#include.jsp内容:
&lt;body&gt;
    &lt;% Thread.sleep(5000); %&gt;
    include文件的中文
&lt;/body&gt;
</code></pre><p>访问<code>127.0.0.1:8080/test_dynamic/test_include.jsp</code>,页面会先显示<code>test_include的中文</code>,然后等待5s显示<code>include文件的中文</code>。<br>若flush的属性值为false(默认),再次访问,则会等待5s后,2行内容一起显示出来。<br>与include的区别:</p>
<pre><code>a.&lt;jsp:include&gt;的文件与被包含文件是2个独立的文件,被包含文件的内容必须能被WEB容器独立执行。而include的内容只需要遵循JSP文件格式,包含与被包含文件是一个整体,需要合并才能翻译成一个Servlrt文件
b.&lt;jsp:include&gt;标签引入的资源是在运行时才包含的,而且只包含运行结果,而include引入的资源是在编译时包含的,包含的是源代码
c.&lt;jsp:include&gt;标签运行原理与RequestDispatcher.include()方法类似,即被包含的页面不能改变响应状态码及设置响应头,而include
指令没有这方面的限制。
</code></pre><p><strong><a href="jsp:forward" target="_blank" rel="noopener">jsp:forward</a></strong>:当前请求转发到其他WEB资源,在执行请求转发后的当前页面将不再执行<br>元素语法:<code>&lt;jsp:forward page=&quot;文件路径&quot; /&gt;</code>        </p>
<pre><code>#jspforward.jsp
&lt;jsp:forward page=&quot;date.jsp&quot;&gt;&lt;/jsp:forward&gt;
&lt;% out.println(1); %&gt; //不执行了

#date.jsp
&lt;% out.println(new java.util.Date().toLocaleString()); %&gt; //输出当前时间
</code></pre><p>由于请求转发是服务端的操作,浏览器并不知道请求页面,所以浏览器的地址栏不会变化(jspforward.jsp)    </p>
<p>其他JSP行为请参考:<a href="http://www.runoob.com/jsp/jsp-syntax.html" target="_blank" rel="noopener">JSP行为</a></p>
<p>判断语句:</p>
<pre><code>&lt;h3&gt;if....else例子&lt;/h3&gt;
&lt;% if (day == 1 | day == 7) { %&gt;
      &lt;p&gt;今天是周末&lt;/p&gt;
&lt;% } else { %&gt;
      &lt;p&gt;今天不是周末&lt;/p&gt;
&lt;% } %&gt;
&lt;/body&gt;
</code></pre><p><a href="http://www.runoob.com/jsp/jsp-syntax.html" target="_blank" rel="noopener">http://www.runoob.com/jsp/jsp-syntax.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">P0rZ9</p>
              <p class="site-description motion-element" itemprop="description">找回当年那个被寄予厚望的自己</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">51</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">P0rZ9</span>

  
</div>












        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
